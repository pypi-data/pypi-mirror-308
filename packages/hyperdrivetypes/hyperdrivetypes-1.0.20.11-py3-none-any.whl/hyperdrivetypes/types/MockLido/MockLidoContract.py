"""A web3.py Contract class for the MockLido contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .MockLidoTypes import (
    ApprovalEvent,
    AuthorityUpdatedEvent,
    OwnershipTransferredEvent,
    PublicCapabilityUpdatedEvent,
    RoleCapabilityUpdatedEvent,
    TargetCustomAuthorityUpdatedEvent,
    TransferEvent,
    TransferSharesEvent,
    UserRoleUpdatedEvent,
)

structs = {}

mocklido_abi: ABI = cast(
    ABI,
    [
        {
            "type": "constructor",
            "inputs": [
                {
                    "name": "_initialRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_admin",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_isCompetitionMode",
                    "type": "bool",
                    "internalType": "bool",
                },
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "allowance",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "authority",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {"name": "_owner", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {"name": "amount", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "canCall",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesRoleHaveCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesUserHaveRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBufferedEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPooledEthByShares",
            "inputs": [
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRate",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRolesWithCapability",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSharesByPooledEth",
            "inputs": [
                {
                    "name": "_ethAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTargetCustomAuthority",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalPooledEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalShares",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserRoles",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCapabilityPublic",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCompetitionMode",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isUnrestricted",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxMintAmount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setAuthority",
            "inputs": [
                {
                    "name": "newAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setMaxMintAmount",
            "inputs": [
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPublicCapability",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRate",
            "inputs": [
                {"name": "_rate_", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRoleCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setTargetCustomAuthority",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "customAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUnrestrictedMintStatus",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "_status", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sharesOf",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "submit",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transfer",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "newOwner",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferShares",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferSharesFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "spender",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AuthorityUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAuthority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PublicCapabilityUpdated",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RoleCapabilityUpdated",
            "inputs": [
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TargetCustomAuthorityUpdated",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "authority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TransferShares",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "sharesValue",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserRoleUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "error",
            "name": "ERC20InsufficientAllowance",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "allowance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InsufficientBalance",
            "inputs": [
                {
                    "name": "sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "balance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidApprover",
            "inputs": [
                {
                    "name": "approver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidReceiver",
            "inputs": [
                {
                    "name": "receiver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSender",
            "inputs": [
                {"name": "sender", "type": "address", "internalType": "address"}
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSpender",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
    ],
)


class MockLidoERC20InsufficientAllowanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientAllowance."""

    # Error name
    name: str = "ERC20InsufficientAllowance"
    # 4 byte error selector
    selector: str = "0xfb8f41b2"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientAllowance(address,uint256,uint256)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoERC20InsufficientBalanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientBalance."""

    # Error name
    name: str = "ERC20InsufficientBalance"
    # 4 byte error selector
    selector: str = "0xe450d38c"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientBalance(address,uint256,uint256)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoERC20InvalidApproverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidApprover."""

    # Error name
    name: str = "ERC20InvalidApprover"
    # 4 byte error selector
    selector: str = "0xe602df05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidApprover(address)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoERC20InvalidReceiverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidReceiver."""

    # Error name
    name: str = "ERC20InvalidReceiver"
    # 4 byte error selector
    selector: str = "0xec442f05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidReceiver(address)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoERC20InvalidSenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSender."""

    # Error name
    name: str = "ERC20InvalidSender"
    # 4 byte error selector
    selector: str = "0x96c6fd1e"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSender(address)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoERC20InvalidSpenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSpender."""

    # Error name
    name: str = "ERC20InvalidSpender"
    # 4 byte error selector
    selector: str = "0x94280d62"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSpender(address)"
    # Error input types
    abi: ABI = mocklido_abi


class MockLidoContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the MockLido contract."""

    ERC20InsufficientAllowance: MockLidoERC20InsufficientAllowanceContractError

    ERC20InsufficientBalance: MockLidoERC20InsufficientBalanceContractError

    ERC20InvalidApprover: MockLidoERC20InvalidApproverContractError

    ERC20InvalidReceiver: MockLidoERC20InvalidReceiverContractError

    ERC20InvalidSender: MockLidoERC20InvalidSenderContractError

    ERC20InvalidSpender: MockLidoERC20InvalidSpenderContractError

    def __init__(
        self,
    ) -> None:
        self.ERC20InsufficientAllowance = (
            MockLidoERC20InsufficientAllowanceContractError()
        )
        self.ERC20InsufficientBalance = (
            MockLidoERC20InsufficientBalanceContractError()
        )
        self.ERC20InvalidApprover = MockLidoERC20InvalidApproverContractError()
        self.ERC20InvalidReceiver = MockLidoERC20InvalidReceiverContractError()
        self.ERC20InvalidSender = MockLidoERC20InvalidSenderContractError()
        self.ERC20InvalidSpender = MockLidoERC20InvalidSpenderContractError()

        self._all = [
            self.ERC20InsufficientAllowance,
            self.ERC20InsufficientBalance,
            self.ERC20InvalidApprover,
            self.ERC20InvalidReceiver,
            self.ERC20InvalidSender,
            self.ERC20InvalidSpender,
        ]


class MockLidoAllowanceContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowance(str,str) method."""

    _function_name = "allowance"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoAllowanceContractFunction(PypechainContractFunction):
    """ContractFunction for the allowance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str) -> MockLidoAllowanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoAllowanceContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoAllowanceContractFunction0._type_signature: MockLidoAllowanceContractFunction0.factory(
                "MockLidoAllowanceContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoApproveContractFunction0(PypechainContractFunction):
    """ContractFunction for the approve(str,int) method."""

    _function_name = "approve"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoApproveContractFunction(PypechainContractFunction):
    """ContractFunction for the approve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "approve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, spender: str, value: int) -> MockLidoApproveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoApproveContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoApproveContractFunction0._type_signature: MockLidoApproveContractFunction0.factory(
                "MockLidoApproveContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the authority() method."""

    _function_name = "authority"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the authority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "authority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoAuthorityContractFunction0._type_signature: MockLidoAuthorityContractFunction0.factory(
                "MockLidoAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoBalanceOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the balanceOf(str) method."""

    _function_name = "balanceOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoBalanceOfContractFunction(PypechainContractFunction):
    """ContractFunction for the balanceOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "balanceOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _owner: str) -> MockLidoBalanceOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoBalanceOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoBalanceOfContractFunction0._type_signature: MockLidoBalanceOfContractFunction0.factory(
                "MockLidoBalanceOfContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoBurnContractFunction0(PypechainContractFunction):
    """ContractFunction for the burn(int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoBurnContractFunction1(PypechainContractFunction):
    """ContractFunction for the burn(str,int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoBurnContractFunction(PypechainContractFunction):
    """ContractFunction for the burn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "burn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, amount: int) -> MockLidoBurnContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _target: str, _amount: int) -> MockLidoBurnContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoBurnContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoBurnContractFunction0._type_signature: MockLidoBurnContractFunction0.factory(
                "MockLidoBurnContractFunction0", **kwargs
            ),
            MockLidoBurnContractFunction1._type_signature: MockLidoBurnContractFunction1.factory(
                "MockLidoBurnContractFunction1", **kwargs
            ),
        }
        return out


class MockLidoCanCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the canCall(str,str,bytes) method."""

    _function_name = "canCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoCanCallContractFunction(PypechainContractFunction):
    """ContractFunction for the canCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "canCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, target: str, functionSig: bytes) -> MockLidoCanCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoCanCallContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoCanCallContractFunction0._type_signature: MockLidoCanCallContractFunction0.factory(
                "MockLidoCanCallContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoDecimalsContractFunction0(PypechainContractFunction):
    """ContractFunction for the decimals() method."""

    _function_name = "decimals"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoDecimalsContractFunction(PypechainContractFunction):
    """ContractFunction for the decimals method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "decimals"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoDecimalsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoDecimalsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoDecimalsContractFunction0._type_signature: MockLidoDecimalsContractFunction0.factory(
                "MockLidoDecimalsContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoDoesRoleHaveCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability(int,bytes) method."""

    _function_name = "doesRoleHaveCapability"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoDoesRoleHaveCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the doesRoleHaveCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesRoleHaveCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes) -> MockLidoDoesRoleHaveCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoDoesRoleHaveCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoDoesRoleHaveCapabilityContractFunction0._type_signature: MockLidoDoesRoleHaveCapabilityContractFunction0.factory(
                "MockLidoDoesRoleHaveCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoDoesUserHaveRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole(str,int) method."""

    _function_name = "doesUserHaveRole"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoDoesUserHaveRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesUserHaveRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int) -> MockLidoDoesUserHaveRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoDoesUserHaveRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoDoesUserHaveRoleContractFunction0._type_signature: MockLidoDoesUserHaveRoleContractFunction0.factory(
                "MockLidoDoesUserHaveRoleContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetBufferedEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBufferedEther() method."""

    _function_name = "getBufferedEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetBufferedEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the getBufferedEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBufferedEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoGetBufferedEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetBufferedEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetBufferedEtherContractFunction0._type_signature: MockLidoGetBufferedEtherContractFunction0.factory(
                "MockLidoGetBufferedEtherContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetPooledEthBySharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPooledEthByShares(int) method."""

    _function_name = "getPooledEthByShares"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetPooledEthBySharesContractFunction(PypechainContractFunction):
    """ContractFunction for the getPooledEthByShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPooledEthByShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sharesAmount: int) -> MockLidoGetPooledEthBySharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetPooledEthBySharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetPooledEthBySharesContractFunction0._type_signature: MockLidoGetPooledEthBySharesContractFunction0.factory(
                "MockLidoGetPooledEthBySharesContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRate() method."""

    _function_name = "getRate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the getRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoGetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetRateContractFunction0._type_signature: MockLidoGetRateContractFunction0.factory(
                "MockLidoGetRateContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetRolesWithCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability(bytes) method."""

    _function_name = "getRolesWithCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetRolesWithCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the getRolesWithCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRolesWithCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> MockLidoGetRolesWithCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetRolesWithCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetRolesWithCapabilityContractFunction0._type_signature: MockLidoGetRolesWithCapabilityContractFunction0.factory(
                "MockLidoGetRolesWithCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetSharesByPooledEthContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSharesByPooledEth(int) method."""

    _function_name = "getSharesByPooledEth"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetSharesByPooledEthContractFunction(PypechainContractFunction):
    """ContractFunction for the getSharesByPooledEth method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSharesByPooledEth"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _ethAmount: int) -> MockLidoGetSharesByPooledEthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetSharesByPooledEthContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetSharesByPooledEthContractFunction0._type_signature: MockLidoGetSharesByPooledEthContractFunction0.factory(
                "MockLidoGetSharesByPooledEthContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority(str) method."""

    _function_name = "getTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockLidoGetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetTargetCustomAuthorityContractFunction0._type_signature: MockLidoGetTargetCustomAuthorityContractFunction0.factory(
                "MockLidoGetTargetCustomAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetTotalPooledEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalPooledEther() method."""

    _function_name = "getTotalPooledEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetTotalPooledEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the getTotalPooledEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalPooledEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoGetTotalPooledEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetTotalPooledEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetTotalPooledEtherContractFunction0._type_signature: MockLidoGetTotalPooledEtherContractFunction0.factory(
                "MockLidoGetTotalPooledEtherContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetTotalSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalShares() method."""

    _function_name = "getTotalShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetTotalSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the getTotalShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoGetTotalSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetTotalSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetTotalSharesContractFunction0._type_signature: MockLidoGetTotalSharesContractFunction0.factory(
                "MockLidoGetTotalSharesContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoGetUserRolesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserRoles(str) method."""

    _function_name = "getUserRoles"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoGetUserRolesContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserRoles method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserRoles"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockLidoGetUserRolesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoGetUserRolesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoGetUserRolesContractFunction0._type_signature: MockLidoGetUserRolesContractFunction0.factory(
                "MockLidoGetUserRolesContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoIsCapabilityPublicContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCapabilityPublic(bytes) method."""

    _function_name = "isCapabilityPublic"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoIsCapabilityPublicContractFunction(PypechainContractFunction):
    """ContractFunction for the isCapabilityPublic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCapabilityPublic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> MockLidoIsCapabilityPublicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoIsCapabilityPublicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoIsCapabilityPublicContractFunction0._type_signature: MockLidoIsCapabilityPublicContractFunction0.factory(
                "MockLidoIsCapabilityPublicContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoIsCompetitionModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode() method."""

    _function_name = "isCompetitionMode"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoIsCompetitionModeContractFunction(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCompetitionMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoIsCompetitionModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoIsCompetitionModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoIsCompetitionModeContractFunction0._type_signature: MockLidoIsCompetitionModeContractFunction0.factory(
                "MockLidoIsCompetitionModeContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoIsUnrestrictedContractFunction0(PypechainContractFunction):
    """ContractFunction for the isUnrestricted(str) method."""

    _function_name = "isUnrestricted"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoIsUnrestrictedContractFunction(PypechainContractFunction):
    """ContractFunction for the isUnrestricted method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isUnrestricted"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockLidoIsUnrestrictedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoIsUnrestrictedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoIsUnrestrictedContractFunction0._type_signature: MockLidoIsUnrestrictedContractFunction0.factory(
                "MockLidoIsUnrestrictedContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxMintAmount() method."""

    _function_name = "maxMintAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the maxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoMaxMintAmountContractFunction0._type_signature: MockLidoMaxMintAmountContractFunction0.factory(
                "MockLidoMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the mint(str,int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoMintContractFunction1(PypechainContractFunction):
    """ContractFunction for the mint(int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoMintContractFunction(PypechainContractFunction):
    """ContractFunction for the mint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> MockLidoMintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _amount: int) -> MockLidoMintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoMintContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoMintContractFunction0._type_signature: MockLidoMintContractFunction0.factory(
                "MockLidoMintContractFunction0", **kwargs
            ),
            MockLidoMintContractFunction1._type_signature: MockLidoMintContractFunction1.factory(
                "MockLidoMintContractFunction1", **kwargs
            ),
        }
        return out


class MockLidoNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoNameContractFunction(PypechainContractFunction):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoNameContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoNameContractFunction0._type_signature: MockLidoNameContractFunction0.factory(
                "MockLidoNameContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoOwnerContractFunction0(PypechainContractFunction):
    """ContractFunction for the owner() method."""

    _function_name = "owner"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoOwnerContractFunction(PypechainContractFunction):
    """ContractFunction for the owner method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "owner"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoOwnerContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoOwnerContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoOwnerContractFunction0._type_signature: MockLidoOwnerContractFunction0.factory(
                "MockLidoOwnerContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setAuthority(str) method."""

    _function_name = "setAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the setAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newAuthority: str) -> MockLidoSetAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetAuthorityContractFunction0._type_signature: MockLidoSetAuthorityContractFunction0.factory(
                "MockLidoSetAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount(int) method."""

    _function_name = "setMaxMintAmount"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setMaxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _maxMintAmount: int) -> MockLidoSetMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetMaxMintAmountContractFunction0._type_signature: MockLidoSetMaxMintAmountContractFunction0.factory(
                "MockLidoSetMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetPublicCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPublicCapability(bytes,bool) method."""

    _function_name = "setPublicCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bool"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetPublicCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the setPublicCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPublicCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, functionSig: bytes, enabled: bool) -> MockLidoSetPublicCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetPublicCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetPublicCapabilityContractFunction0._type_signature: MockLidoSetPublicCapabilityContractFunction0.factory(
                "MockLidoSetPublicCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRate(int) method."""

    _function_name = "setRate"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the setRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _rate_: int) -> MockLidoSetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetRateContractFunction0._type_signature: MockLidoSetRateContractFunction0.factory(
                "MockLidoSetRateContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetRoleCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRoleCapability(int,bytes,bool) method."""

    _function_name = "setRoleCapability"
    _type_signature = expand_struct_type_str(
        tuple(["int", "bytes", "bool"]), structs
    )
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetRoleCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the setRoleCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRoleCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes, enabled: bool) -> MockLidoSetRoleCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetRoleCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetRoleCapabilityContractFunction0._type_signature: MockLidoSetRoleCapabilityContractFunction0.factory(
                "MockLidoSetRoleCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority(str,str) method."""

    _function_name = "setTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, customAuthority: str) -> MockLidoSetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetTargetCustomAuthorityContractFunction0._type_signature: MockLidoSetTargetCustomAuthorityContractFunction0.factory(
                "MockLidoSetTargetCustomAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetUnrestrictedMintStatusContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus(str,bool) method."""

    _function_name = "setUnrestrictedMintStatus"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetUnrestrictedMintStatusContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUnrestrictedMintStatus"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _target: str, _status: bool) -> MockLidoSetUnrestrictedMintStatusContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetUnrestrictedMintStatusContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetUnrestrictedMintStatusContractFunction0._type_signature: MockLidoSetUnrestrictedMintStatusContractFunction0.factory(
                "MockLidoSetUnrestrictedMintStatusContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSetUserRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserRole(str,int,bool) method."""

    _function_name = "setUserRole"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoSetUserRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the setUserRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int, enabled: bool) -> MockLidoSetUserRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSetUserRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSetUserRoleContractFunction0._type_signature: MockLidoSetUserRoleContractFunction0.factory(
                "MockLidoSetUserRoleContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSharesOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the sharesOf(str) method."""

    _function_name = "sharesOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoSharesOfContractFunction(PypechainContractFunction):
    """ContractFunction for the sharesOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sharesOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockLidoSharesOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSharesOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSharesOfContractFunction0._type_signature: MockLidoSharesOfContractFunction0.factory(
                "MockLidoSharesOfContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSubmitContractFunction0(PypechainContractFunction):
    """ContractFunction for the submit(str) method."""

    _function_name = "submit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoSubmitContractFunction(PypechainContractFunction):
    """ContractFunction for the submit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "submit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockLidoSubmitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSubmitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSubmitContractFunction0._type_signature: MockLidoSubmitContractFunction0.factory(
                "MockLidoSubmitContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoSymbolContractFunction0(PypechainContractFunction):
    """ContractFunction for the symbol() method."""

    _function_name = "symbol"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoSymbolContractFunction(PypechainContractFunction):
    """ContractFunction for the symbol method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "symbol"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoSymbolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoSymbolContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoSymbolContractFunction0._type_signature: MockLidoSymbolContractFunction0.factory(
                "MockLidoSymbolContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTotalSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalSupply() method."""

    _function_name = "totalSupply"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoTotalSupplyContractFunction(PypechainContractFunction):
    """ContractFunction for the totalSupply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalSupply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockLidoTotalSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTotalSupplyContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTotalSupplyContractFunction0._type_signature: MockLidoTotalSupplyContractFunction0.factory(
                "MockLidoTotalSupplyContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the transfer(str,int) method."""

    _function_name = "transfer"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoTransferContractFunction(PypechainContractFunction):
    """ContractFunction for the transfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> MockLidoTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTransferContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTransferContractFunction0._type_signature: MockLidoTransferContractFunction0.factory(
                "MockLidoTransferContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferFrom(str,str,int) method."""

    _function_name = "transferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoTransferFromContractFunction(PypechainContractFunction):
    """ContractFunction for the transferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _amount: int) -> MockLidoTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTransferFromContractFunction0._type_signature: MockLidoTransferFromContractFunction0.factory(
                "MockLidoTransferFromContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTransferOwnershipContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferOwnership(str) method."""

    _function_name = "transferOwnership"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockLidoTransferOwnershipContractFunction(PypechainContractFunction):
    """ContractFunction for the transferOwnership method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferOwnership"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newOwner: str) -> MockLidoTransferOwnershipContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTransferOwnershipContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTransferOwnershipContractFunction0._type_signature: MockLidoTransferOwnershipContractFunction0.factory(
                "MockLidoTransferOwnershipContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTransferSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferShares(str,int) method."""

    _function_name = "transferShares"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoTransferSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the transferShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _sharesAmount: int) -> MockLidoTransferSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTransferSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTransferSharesContractFunction0._type_signature: MockLidoTransferSharesContractFunction0.factory(
                "MockLidoTransferSharesContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoTransferSharesFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferSharesFrom(str,str,int) method."""

    _function_name = "transferSharesFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = MockLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockLidoTransferSharesFromContractFunction(PypechainContractFunction):
    """ContractFunction for the transferSharesFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferSharesFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _sharesAmount: int) -> MockLidoTransferSharesFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockLidoTransferSharesFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockLidoTransferSharesFromContractFunction0._type_signature: MockLidoTransferSharesFromContractFunction0.factory(
                "MockLidoTransferSharesFromContractFunction0", **kwargs
            ),
        }
        return out


class MockLidoContractFunctions(ContractFunctions):
    """ContractFunctions for the MockLido contract."""

    allowance: MockLidoAllowanceContractFunction

    approve: MockLidoApproveContractFunction

    authority: MockLidoAuthorityContractFunction

    balanceOf: MockLidoBalanceOfContractFunction

    burn: MockLidoBurnContractFunction

    canCall: MockLidoCanCallContractFunction

    decimals: MockLidoDecimalsContractFunction

    doesRoleHaveCapability: MockLidoDoesRoleHaveCapabilityContractFunction

    doesUserHaveRole: MockLidoDoesUserHaveRoleContractFunction

    getBufferedEther: MockLidoGetBufferedEtherContractFunction

    getPooledEthByShares: MockLidoGetPooledEthBySharesContractFunction

    getRate: MockLidoGetRateContractFunction

    getRolesWithCapability: MockLidoGetRolesWithCapabilityContractFunction

    getSharesByPooledEth: MockLidoGetSharesByPooledEthContractFunction

    getTargetCustomAuthority: MockLidoGetTargetCustomAuthorityContractFunction

    getTotalPooledEther: MockLidoGetTotalPooledEtherContractFunction

    getTotalShares: MockLidoGetTotalSharesContractFunction

    getUserRoles: MockLidoGetUserRolesContractFunction

    isCapabilityPublic: MockLidoIsCapabilityPublicContractFunction

    isCompetitionMode: MockLidoIsCompetitionModeContractFunction

    isUnrestricted: MockLidoIsUnrestrictedContractFunction

    maxMintAmount: MockLidoMaxMintAmountContractFunction

    mint: MockLidoMintContractFunction

    name: MockLidoNameContractFunction

    owner: MockLidoOwnerContractFunction

    setAuthority: MockLidoSetAuthorityContractFunction

    setMaxMintAmount: MockLidoSetMaxMintAmountContractFunction

    setPublicCapability: MockLidoSetPublicCapabilityContractFunction

    setRate: MockLidoSetRateContractFunction

    setRoleCapability: MockLidoSetRoleCapabilityContractFunction

    setTargetCustomAuthority: MockLidoSetTargetCustomAuthorityContractFunction

    setUnrestrictedMintStatus: MockLidoSetUnrestrictedMintStatusContractFunction

    setUserRole: MockLidoSetUserRoleContractFunction

    sharesOf: MockLidoSharesOfContractFunction

    submit: MockLidoSubmitContractFunction

    symbol: MockLidoSymbolContractFunction

    totalSupply: MockLidoTotalSupplyContractFunction

    transfer: MockLidoTransferContractFunction

    transferFrom: MockLidoTransferFromContractFunction

    transferOwnership: MockLidoTransferOwnershipContractFunction

    transferShares: MockLidoTransferSharesContractFunction

    transferSharesFrom: MockLidoTransferSharesFromContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.allowance = MockLidoAllowanceContractFunction.factory(
            "allowance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowance",
        )
        self.approve = MockLidoApproveContractFunction.factory(
            "approve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="approve",
        )
        self.authority = MockLidoAuthorityContractFunction.factory(
            "authority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="authority",
        )
        self.balanceOf = MockLidoBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="balanceOf",
        )
        self.burn = MockLidoBurnContractFunction.factory(
            "burn",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="burn",
        )
        self.canCall = MockLidoCanCallContractFunction.factory(
            "canCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="canCall",
        )
        self.decimals = MockLidoDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="decimals",
        )
        self.doesRoleHaveCapability = (
            MockLidoDoesRoleHaveCapabilityContractFunction.factory(
                "doesRoleHaveCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesRoleHaveCapability",
            )
        )
        self.doesUserHaveRole = (
            MockLidoDoesUserHaveRoleContractFunction.factory(
                "doesUserHaveRole",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesUserHaveRole",
            )
        )
        self.getBufferedEther = (
            MockLidoGetBufferedEtherContractFunction.factory(
                "getBufferedEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getBufferedEther",
            )
        )
        self.getPooledEthByShares = (
            MockLidoGetPooledEthBySharesContractFunction.factory(
                "getPooledEthByShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPooledEthByShares",
            )
        )
        self.getRate = MockLidoGetRateContractFunction.factory(
            "getRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRate",
        )
        self.getRolesWithCapability = (
            MockLidoGetRolesWithCapabilityContractFunction.factory(
                "getRolesWithCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getRolesWithCapability",
            )
        )
        self.getSharesByPooledEth = (
            MockLidoGetSharesByPooledEthContractFunction.factory(
                "getSharesByPooledEth",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getSharesByPooledEth",
            )
        )
        self.getTargetCustomAuthority = (
            MockLidoGetTargetCustomAuthorityContractFunction.factory(
                "getTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTargetCustomAuthority",
            )
        )
        self.getTotalPooledEther = (
            MockLidoGetTotalPooledEtherContractFunction.factory(
                "getTotalPooledEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTotalPooledEther",
            )
        )
        self.getTotalShares = MockLidoGetTotalSharesContractFunction.factory(
            "getTotalShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getTotalShares",
        )
        self.getUserRoles = MockLidoGetUserRolesContractFunction.factory(
            "getUserRoles",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserRoles",
        )
        self.isCapabilityPublic = (
            MockLidoIsCapabilityPublicContractFunction.factory(
                "isCapabilityPublic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCapabilityPublic",
            )
        )
        self.isCompetitionMode = (
            MockLidoIsCompetitionModeContractFunction.factory(
                "isCompetitionMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCompetitionMode",
            )
        )
        self.isUnrestricted = MockLidoIsUnrestrictedContractFunction.factory(
            "isUnrestricted",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isUnrestricted",
        )
        self.maxMintAmount = MockLidoMaxMintAmountContractFunction.factory(
            "maxMintAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxMintAmount",
        )
        self.mint = MockLidoMintContractFunction.factory(
            "mint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mint",
        )
        self.name = MockLidoNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.owner = MockLidoOwnerContractFunction.factory(
            "owner",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="owner",
        )
        self.setAuthority = MockLidoSetAuthorityContractFunction.factory(
            "setAuthority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setAuthority",
        )
        self.setMaxMintAmount = (
            MockLidoSetMaxMintAmountContractFunction.factory(
                "setMaxMintAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setMaxMintAmount",
            )
        )
        self.setPublicCapability = (
            MockLidoSetPublicCapabilityContractFunction.factory(
                "setPublicCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPublicCapability",
            )
        )
        self.setRate = MockLidoSetRateContractFunction.factory(
            "setRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setRate",
        )
        self.setRoleCapability = (
            MockLidoSetRoleCapabilityContractFunction.factory(
                "setRoleCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setRoleCapability",
            )
        )
        self.setTargetCustomAuthority = (
            MockLidoSetTargetCustomAuthorityContractFunction.factory(
                "setTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setTargetCustomAuthority",
            )
        )
        self.setUnrestrictedMintStatus = (
            MockLidoSetUnrestrictedMintStatusContractFunction.factory(
                "setUnrestrictedMintStatus",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUnrestrictedMintStatus",
            )
        )
        self.setUserRole = MockLidoSetUserRoleContractFunction.factory(
            "setUserRole",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserRole",
        )
        self.sharesOf = MockLidoSharesOfContractFunction.factory(
            "sharesOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sharesOf",
        )
        self.submit = MockLidoSubmitContractFunction.factory(
            "submit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="submit",
        )
        self.symbol = MockLidoSymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="symbol",
        )
        self.totalSupply = MockLidoTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalSupply",
        )
        self.transfer = MockLidoTransferContractFunction.factory(
            "transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transfer",
        )
        self.transferFrom = MockLidoTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferFrom",
        )
        self.transferOwnership = (
            MockLidoTransferOwnershipContractFunction.factory(
                "transferOwnership",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferOwnership",
            )
        )
        self.transferShares = MockLidoTransferSharesContractFunction.factory(
            "transferShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferShares",
        )
        self.transferSharesFrom = (
            MockLidoTransferSharesFromContractFunction.factory(
                "transferSharesFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferSharesFrom",
            )
        )


class MockLidoApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ApprovalEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ApprovalEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for AuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoOwnershipTransferredContractEvent(ContractEvent):
    """ContractEvent for OwnershipTransferred."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoPublicCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for PublicCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoRoleCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for RoleCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoTargetCustomAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for TargetCustomAuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoTransferContractEvent(ContractEvent):
    """ContractEvent for Transfer."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoTransferSharesContractEvent(ContractEvent):
    """ContractEvent for TransferShares."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoUserRoleUpdatedContractEvent(ContractEvent):
    """ContractEvent for UserRoleUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockLidoContractEvents(ContractEvents):
    """ContractEvents for the MockLido contract."""

    Approval: Type[MockLidoApprovalContractEvent]

    AuthorityUpdated: Type[MockLidoAuthorityUpdatedContractEvent]

    OwnershipTransferred: Type[MockLidoOwnershipTransferredContractEvent]

    PublicCapabilityUpdated: Type[MockLidoPublicCapabilityUpdatedContractEvent]

    RoleCapabilityUpdated: Type[MockLidoRoleCapabilityUpdatedContractEvent]

    TargetCustomAuthorityUpdated: Type[
        MockLidoTargetCustomAuthorityUpdatedContractEvent
    ]

    Transfer: Type[MockLidoTransferContractEvent]

    TransferShares: Type[MockLidoTransferSharesContractEvent]

    UserRoleUpdated: Type[MockLidoUserRoleUpdatedContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.Approval = cast(
            Type[MockLidoApprovalContractEvent],
            MockLidoApprovalContractEvent.factory(
                "Approval",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Approval",
            ),
        )
        self.AuthorityUpdated = cast(
            Type[MockLidoAuthorityUpdatedContractEvent],
            MockLidoAuthorityUpdatedContractEvent.factory(
                "AuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AuthorityUpdated",
            ),
        )
        self.OwnershipTransferred = cast(
            Type[MockLidoOwnershipTransferredContractEvent],
            MockLidoOwnershipTransferredContractEvent.factory(
                "OwnershipTransferred",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OwnershipTransferred",
            ),
        )
        self.PublicCapabilityUpdated = cast(
            Type[MockLidoPublicCapabilityUpdatedContractEvent],
            MockLidoPublicCapabilityUpdatedContractEvent.factory(
                "PublicCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PublicCapabilityUpdated",
            ),
        )
        self.RoleCapabilityUpdated = cast(
            Type[MockLidoRoleCapabilityUpdatedContractEvent],
            MockLidoRoleCapabilityUpdatedContractEvent.factory(
                "RoleCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RoleCapabilityUpdated",
            ),
        )
        self.TargetCustomAuthorityUpdated = cast(
            Type[MockLidoTargetCustomAuthorityUpdatedContractEvent],
            MockLidoTargetCustomAuthorityUpdatedContractEvent.factory(
                "TargetCustomAuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TargetCustomAuthorityUpdated",
            ),
        )
        self.Transfer = cast(
            Type[MockLidoTransferContractEvent],
            MockLidoTransferContractEvent.factory(
                "Transfer",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Transfer",
            ),
        )
        self.TransferShares = cast(
            Type[MockLidoTransferSharesContractEvent],
            MockLidoTransferSharesContractEvent.factory(
                "TransferShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TransferShares",
            ),
        )
        self.UserRoleUpdated = cast(
            Type[MockLidoUserRoleUpdatedContractEvent],
            MockLidoUserRoleUpdatedContractEvent.factory(
                "UserRoleUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="UserRoleUpdated",
            ),
        )


class MockLidoContract(Contract):
    """A web3.py Contract class for the MockLido contract."""

    abi: ABI = mocklido_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x60a06040523480156200001157600080fd5b50604051620021fc380380620021fc83398101604081905262000034916200015c565b604080518082018252601781527f4c6971756964207374616b656420457468657220322e300000000000000000006020808301919091528251808401845260058152640e6e88aa8960db1b91810191909152600080546001600160a01b03199081166001600160a01b038916908117835560018054309316831790559451939492938893919284928492909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350505050816009908162000131919062000261565b50600a62000140828262000261565b505050600d9390935542600e55151560805250600b556200032d565b600080600080608085870312156200017357600080fd5b845160208601519094506001600160a01b03811681146200019357600080fd5b60408601519093508015158114620001aa57600080fd5b6060959095015193969295505050565b634e487b7160e01b600052604160045260246000fd5b600181811c90821680620001e557607f821691505b6020821081036200020657634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200025c576000816000526020600020601f850160051c81016020861015620002375750805b601f850160051c820191505b81811015620002585782815560010162000243565b5050505b505050565b81516001600160401b038111156200027d576200027d620001ba565b62000295816200028e8454620001d0565b846200020c565b602080601f831160018114620002cd5760008415620002b45750858301515b600019600386901b1c1916600185901b17855562000258565b600085815260208120601f198616915b82811015620002fe57888601518255948401946001909101908401620002dd565b50858210156200031d5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b608051611e826200037a60003960008181610587015281816108ad015281816109cb01528181610bc401528181610c4501528181610cab0152818161114c01526111ae0152611e826000f3fe6080604052600436106102675760003560e01c8063728b952b11610144578063aed30777116100b6578063dd62ed3e1161007a578063dd62ed3e14610764578063e688747b146107aa578063ea7ca276146107ed578063ed0d0efb14610831578063f2fde38b1461085e578063f5eb42dc1461087e57600080fd5b8063aed30777146106a9578063b7009613146106d9578063bf7e214f146106f9578063c53a398514610719578063d5002f2e1461074f57600080fd5b80638fcb4e5b116101085780638fcb4e5b1461060157806395d89b41146106215780639dc29fac14610636578063a0712d6814610656578063a1903eab14610676578063a9059cbb1461068957600080fd5b8063728b952b146105355780637a28fb88146105555780637a8c63b5146105755780637a9e5e4b146105a95780638da5cb5b146105c957600080fd5b8063313ce567116101dd57806347b714e0116101a157806347b714e01461048c5780634b5159da146104a0578063679aefce146104c057806367aff484146104d55780636d780459146104f557806370a082311461051557600080fd5b8063313ce567146103fb57806334fcf4371461041757806337cfdaca1461043757806340c10f191461044c57806342966c681461046c57600080fd5b80630bade8a41161022f5780630bade8a4146103405780630ea9b75b1461037057806318160ddd1461039057806319208451146103a5578063239c70ae146103c557806323b872dd146103db57600080fd5b806305f05a941461026c57806306a36aee1461028e57806306fdde03146102ce578063088a4ed0146102f0578063095ea7b314610310575b600080fd5b34801561027857600080fd5b5061028c610287366004611a16565b6108ab565b005b34801561029a57600080fd5b506102bb6102a9366004611a4f565b60036020526000908152604090205481565b6040519081526020015b60405180910390f35b3480156102da57600080fd5b506102e3610937565b6040516102c59190611a6c565b3480156102fc57600080fd5b5061028c61030b366004611abb565b6109c9565b34801561031c57600080fd5b5061033061032b366004611ad4565b610a26565b60405190151581526020016102c5565b34801561034c57600080fd5b5061033061035b366004611b1d565b60046020526000908152604090205460ff1681565b34801561037c57600080fd5b5061028c61038b366004611b49565b610a40565b34801561039c57600080fd5b506008546102bb565b3480156103b157600080fd5b506102bb6103c0366004611abb565b610b18565b3480156103d157600080fd5b506102bb600b5481565b3480156103e757600080fd5b506103306103f6366004611b90565b610b36565b34801561040757600080fd5b50604051601281526020016102c5565b34801561042357600080fd5b5061028c610432366004611abb565b610bc2565b34801561044357600080fd5b506102bb610c27565b34801561045857600080fd5b5061028c610467366004611ad4565b610c43565b34801561047857600080fd5b5061028c610487366004611abb565b610ca9565b34801561049857600080fd5b5060006102bb565b3480156104ac57600080fd5b5061028c6104bb366004611bd1565b610d0e565b3480156104cc57600080fd5b50600d546102bb565b3480156104e157600080fd5b5061028c6104f0366004611bed565b610da0565b34801561050157600080fd5b506102bb610510366004611b90565b610e68565b34801561052157600080fd5b506102bb610530366004611a4f565b610eff565b34801561054157600080fd5b5061028c610550366004611c1b565b610f21565b34801561056157600080fd5b506102bb610570366004611abb565b610faa565b34801561058157600080fd5b506103307f000000000000000000000000000000000000000000000000000000000000000081565b3480156105b557600080fd5b5061028c6105c4366004611a4f565b610fbf565b3480156105d557600080fd5b506000546105e9906001600160a01b031681565b6040516001600160a01b0390911681526020016102c5565b34801561060d57600080fd5b506102bb61061c366004611ad4565b6110a9565b34801561062d57600080fd5b506102e361113b565b34801561064257600080fd5b5061028c610651366004611ad4565b61114a565b34801561066257600080fd5b5061028c610671366004611abb565b6111ac565b6102bb610684366004611a4f565b61120e565b34801561069557600080fd5b506103306106a4366004611ad4565b6112d3565b3480156106b557600080fd5b506103306106c4366004611a4f565b600c6020526000908152604090205460ff1681565b3480156106e557600080fd5b506103306106f4366004611c49565b61135b565b34801561070557600080fd5b506001546105e9906001600160a01b031681565b34801561072557600080fd5b506105e9610734366004611a4f565b6002602052600090815260409020546001600160a01b031681565b34801561075b57600080fd5b506010546102bb565b34801561077057600080fd5b506102bb61077f366004611c1b565b6001600160a01b03918216600090815260076020908152604080832093909416825291909152205490565b3480156107b657600080fd5b506103306107c5366004611c90565b6001600160e01b03191660009081526005602052604090205460ff919091161c600116151590565b3480156107f957600080fd5b50610330610808366004611cc3565b6001600160a01b0391909116600090815260036020526040902054600160ff9092161c16151590565b34801561083d57600080fd5b506102bb61084c366004611b1d565b60056020526000908152604090205481565b34801561086a57600080fd5b5061028c610879366004611a4f565b611459565b34801561088a57600080fd5b506102bb610899366004611a4f565b60116020526000908152604090205481565b7f00000000000000000000000000000000000000000000000000000000000000001561090c576108e7336000356001600160e01b0319166114d6565b61090c5760405162461bcd60e51b815260040161090390611cef565b60405180910390fd5b6001600160a01b03919091166000908152600c60205260409020805460ff1916911515919091179055565b60606009805461094690611d26565b80601f016020809104026020016040519081016040528092919081815260200182805461097290611d26565b80156109bf5780601f10610994576101008083540402835291602001916109bf565b820191906000526020600020905b8154815290600101906020018083116109a257829003601f168201915b5050505050905090565b7f000000000000000000000000000000000000000000000000000000000000000015610a2157610a05336000356001600160e01b0319166114d6565b610a215760405162461bcd60e51b815260040161090390611cef565b600b55565b600033610a34818585611580565b60019150505b92915050565b610a56336000356001600160e01b0319166114d6565b610a725760405162461bcd60e51b815260040161090390611d60565b8015610aa2576001600160e01b0319821660009081526005602052604090208054600160ff86161b179055610ac9565b6001600160e01b0319821660009081526005602052604090208054600160ff86161b191690555b816001600160e01b0319168360ff167fbfe16b2c35ce23dfd1ab0e7b5d086a10060c9b52d1574e1680c881b3b3a2b15183604051610b0b911515815260200190565b60405180910390a3505050565b6000610a3a610b2660105490565b610b2e610c27565b849190611592565b6000610b406115b0565b6000610b4b83610b18565b9050610b588585836115e1565b506040518381526001600160a01b038516903390600080516020611e2d8339815191529060200160405180910390a36040518181526001600160a01b038516903390600080516020611e0d8339815191529060200160405180910390a360019150505b9392505050565b7f000000000000000000000000000000000000000000000000000000000000000015610c1a57610bfe336000356001600160e01b0319166114d6565b610c1a5760405162461bcd60e51b815260040161090390611cef565b610c226115b0565b600d55565b6000610c3161165d565b600f54610c3e9190611d9c565b905090565b7f000000000000000000000000000000000000000000000000000000000000000015610c9b57610c7f336000356001600160e01b0319166114d6565b610c9b5760405162461bcd60e51b815260040161090390611cef565b610ca582826116c2565b5050565b7f000000000000000000000000000000000000000000000000000000000000000015610d0157610ce5336000356001600160e01b0319166114d6565b610d015760405162461bcd60e51b815260040161090390611cef565b610d0b33826117b4565b50565b610d24336000356001600160e01b0319166114d6565b610d405760405162461bcd60e51b815260040161090390611d60565b6001600160e01b03198216600081815260046020908152604091829020805460ff191685151590811790915591519182527f36d28126bef21a4f3765d7fcb7c45cead463ae4c41094ef3b771ede598544103910160405180910390a25050565b610db6336000356001600160e01b0319166114d6565b610dd25760405162461bcd60e51b815260040161090390611d60565b8015610e01576001600160a01b03831660009081526003602052604090208054600160ff85161b179055610e27565b6001600160a01b03831660009081526003602052604090208054600160ff85161b191690555b8160ff16836001600160a01b03167f4c9bdd0c8e073eb5eda2250b18d8e5121ff27b62064fbeeeed4869bb99bc5bf283604051610b0b911515815260200190565b6000610e726115b0565b6000610e7f8585856115e1565b9050836001600160a01b0316856001600160a01b0316600080516020611e2d83398151915283604051610eb491815260200190565b60405180910390a3836001600160a01b0316856001600160a01b0316600080516020611e0d83398151915285604051610eef91815260200190565b60405180910390a3949350505050565b6001600160a01b038116600090815260116020526040812054610a3a90610faa565b610f37336000356001600160e01b0319166114d6565b610f535760405162461bcd60e51b815260040161090390611d60565b6001600160a01b0382811660008181526002602052604080822080546001600160a01b0319169486169485179055517fa4908e11a5f895b13d51526c331ac93cdd30e59772361c5d07874eb36bff20659190a35050565b6000610a3a610fb7610c27565b601054610b2e565b6000546001600160a01b0316331480611054575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061101390339030906001600160e01b03196000351690600401611daf565b602060405180830381865afa158015611030573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110549190611ddc565b61105d57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b60006110b36115b0565b60006110bf848461181e565b9050836001600160a01b0316336001600160a01b0316600080516020611e2d833981519152836040516110f491815260200190565b60405180910390a36040518381526001600160a01b038516903390600080516020611e0d8339815191529060200160405180910390a361113383610faa565b949350505050565b6060600a805461094690611d26565b7f0000000000000000000000000000000000000000000000000000000000000000156111a257611186336000356001600160e01b0319166114d6565b6111a25760405162461bcd60e51b815260040161090390611cef565b610ca582826117b4565b7f000000000000000000000000000000000000000000000000000000000000000015611204576111e8336000356001600160e01b0319166114d6565b6112045760405162461bcd60e51b815260040161090390611cef565b610d0b33826116c2565b60006112186115b0565b60105460000361125857346010819055600f819055336000908152601160205260408120805490919061124c908490611d9c565b90915550349392505050565b600061127661126660105490565b61126e610c27565b349190611592565b905034600f600082825461128a9190611d9c565b9250508190555080601060008282546112a39190611d9c565b909155505033600090815260116020526040812080548392906112c7908490611d9c565b90915550909392505050565b60006112dd6115b0565b60006112e883610b18565b90506112f4848261181e565b506040518381526001600160a01b038516903390600080516020611e2d8339815191529060200160405180910390a36040518181526001600160a01b038516903390600080516020611e0d8339815191529060200160405180910390a35060019392505050565b6001600160a01b0380831660009081526002602052604081205490911680156113f75760405163b700961360e01b81526001600160a01b0382169063b7009613906113ae90889088908890600401611daf565b602060405180830381865afa1580156113cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113ef9190611ddc565b915050610bbb565b6001600160e01b0319831660009081526004602052604090205460ff168061145057506001600160e01b031983166000908152600560209081526040808320546001600160a01b03891684526003909252909120541615155b95945050505050565b61146f336000356001600160e01b0319166114d6565b61148b5760405162461bcd60e51b815260040161090390611d60565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b6001546000906001600160a01b03168015801590611560575060405163b700961360e01b81526001600160a01b0382169063b70096139061151f90879030908890600401611daf565b602060405180830381865afa15801561153c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115609190611ddc565b8061113357506000546001600160a01b0385811691161491505092915050565b61158d838383600161187b565b505050565b60008260001904841183021582026115a957600080fd5b5091020490565b60006115ba61165d565b905080156115da5780600f60008282546115d49190611d9c565b90915550505b5042600e55565b6000806115ed83610faa565b90506115fa853383611951565b6001600160a01b03851660009081526011602052604081208054859290611622908490611df9565b90915550506001600160a01b0384166000908152601160205260408120805485929061164f908490611d9c565b909155509095945050505050565b6000600d5460000361166f5750600090565b600e5442101561167f5750600090565b600061169d6301e13380600e54426116979190611df9565b906119c9565b90506000610bbb6116b983600d546119de90919063ffffffff16565b600f54906119de565b336000908152600c602052604090205460ff1661172b57600b5481111561172b5760405162461bcd60e51b815260206004820152601d60248201527f4d6f636b4c69646f3a20496e76616c6964206d696e7420616d6f756e740000006044820152606401610903565b600061173660105490565b600003611744575080611750565b61174d82610b18565b90505b6001600160a01b03831660009081526011602052604081208054839290611778908490611d9c565b9250508190555081600f60008282546117919190611d9c565b9250508190555080601060008282546117aa9190611d9c565b9091555050505050565b60006117bf82610b18565b6001600160a01b0384166000908152601160205260408120805492935083929091906117ec908490611df9565b9250508190555081600f60008282546118059190611df9565b9250508190555080601060008282546117aa9190611df9565b3360009081526011602052604081208054839190839061183f908490611df9565b90915550506001600160a01b0383166000908152601160205260408120805484929061186c908490611d9c565b90915550610bbb905082610faa565b6001600160a01b0384166118a55760405163e602df0560e01b815260006004820152602401610903565b6001600160a01b0383166118cf57604051634a1406b160e11b815260006004820152602401610903565b6001600160a01b038085166000908152600760209081526040808320938716835292905220829055801561194b57826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9258460405161194291815260200190565b60405180910390a35b50505050565b6001600160a01b03838116600090815260076020908152604080832093861683529290522054600019811461194b57818110156119ba57604051637dc7a0d960e11b81526001600160a01b03841660048201526024810182905260448101839052606401610903565b61194b8484848403600061187b565b6000610bbb83670de0b6b3a764000084611592565b6000610bbb8383670de0b6b3a7640000611592565b6001600160a01b0381168114610d0b57600080fd5b8015158114610d0b57600080fd5b60008060408385031215611a2957600080fd5b8235611a34816119f3565b91506020830135611a4481611a08565b809150509250929050565b600060208284031215611a6157600080fd5b8135610bbb816119f3565b60006020808352835180602085015260005b81811015611a9a57858101830151858201604001528201611a7e565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215611acd57600080fd5b5035919050565b60008060408385031215611ae757600080fd5b8235611af2816119f3565b946020939093013593505050565b80356001600160e01b031981168114611b1857600080fd5b919050565b600060208284031215611b2f57600080fd5b610bbb82611b00565b803560ff81168114611b1857600080fd5b600080600060608486031215611b5e57600080fd5b611b6784611b38565b9250611b7560208501611b00565b91506040840135611b8581611a08565b809150509250925092565b600080600060608486031215611ba557600080fd5b8335611bb0816119f3565b92506020840135611bc0816119f3565b929592945050506040919091013590565b60008060408385031215611be457600080fd5b611a3483611b00565b600080600060608486031215611c0257600080fd5b8335611c0d816119f3565b9250611b7560208501611b38565b60008060408385031215611c2e57600080fd5b8235611c39816119f3565b91506020830135611a44816119f3565b600080600060608486031215611c5e57600080fd5b8335611c69816119f3565b92506020840135611c79816119f3565b9150611c8760408501611b00565b90509250925092565b60008060408385031215611ca357600080fd5b611cac83611b38565b9150611cba60208401611b00565b90509250929050565b60008060408385031215611cd657600080fd5b8235611ce1816119f3565b9150611cba60208401611b38565b60208082526018908201527f4d6f636b4c69646f3a206e6f7420617574686f72697a65640000000000000000604082015260600190565b600181811c90821680611d3a57607f821691505b602082108103611d5a57634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a3a57610a3a611d86565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b600060208284031215611dee57600080fd5b8151610bbb81611a08565b81810381811115610a3a57610a3a611d8656fe9d9c909296d9c674451c0c24f02cb64981eb3b727f99865939192f880a755dcbddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220919cf287adb37ae09e1a870966ac504ef429f806ce2d6ebb583e5167206ca8a764736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = MockLidoContractFunctions(mocklido_abi, self.w3, address)  # type: ignore
        self.events = MockLidoContractEvents(mocklido_abi, self.w3, address)  # type: ignore
        self.errors = MockLidoContractErrors()

    events: MockLidoContractEvents

    errors: MockLidoContractErrors = MockLidoContractErrors()

    functions: MockLidoContractFunctions

    class ConstructorArgs(NamedTuple):
        """Arguments to pass the contract's constructor function."""

        initialRate: int

        admin: str

        isCompetitionMode: bool

        maxMintAmount: int

    @classmethod
    def constructor(cls, initialRate: int, admin: str, isCompetitionMode: bool, maxMintAmount: int) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor(
            dataclass_to_tuple(initialRate),
            dataclass_to_tuple(admin),
            dataclass_to_tuple(isCompetitionMode),
            dataclass_to_tuple(maxMintAmount),
        )

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        constructor_args: ConstructorArgs,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(
            *constructor_args,
        )

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = MockLidoContractFunctions(mocklido_abi, w3, None)
        contract.errors = MockLidoContractErrors()

        return contract
