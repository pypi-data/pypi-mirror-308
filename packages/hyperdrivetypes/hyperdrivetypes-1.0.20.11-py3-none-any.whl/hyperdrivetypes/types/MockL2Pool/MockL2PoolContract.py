"""A web3.py Contract class for the MockL2Pool contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..BorrowLogic import BorrowLogicContract
from ..BridgeLogic import BridgeLogicContract
from ..DataTypes import DataTypesTypes as DataTypes
from ..EModeLogic import EModeLogicContract
from ..FlashLoanLogic import FlashLoanLogicContract
from ..LiquidationLogic import LiquidationLogicContract
from ..PoolLogic import PoolLogicContract
from ..SupplyLogic import SupplyLogicContract
from .MockL2PoolTypes import (
    BackUnbackedEvent,
    BorrowEvent,
    FlashLoanEvent,
    IsolationModeTotalDebtUpdatedEvent,
    LiquidationCallEvent,
    MintedToTreasuryEvent,
    MintUnbackedEvent,
    RebalanceStableBorrowRateEvent,
    RepayEvent,
    ReserveDataUpdatedEvent,
    ReserveUsedAsCollateralDisabledEvent,
    ReserveUsedAsCollateralEnabledEvent,
    SupplyEvent,
    SwapBorrowRateModeEvent,
    UserEModeSetEvent,
    WithdrawEvent,
)

structs = {
    "DataTypes.EModeCategory": DataTypes.EModeCategory,
    "DataTypes.ReserveConfigurationMap": DataTypes.ReserveConfigurationMap,
    "DataTypes.ReserveDataLegacy": DataTypes.ReserveDataLegacy,
    "DataTypes.ReserveData": DataTypes.ReserveData,
    "DataTypes.UserConfigurationMap": DataTypes.UserConfigurationMap,
}

mockl2pool_abi: ABI = cast(
    ABI,
    [
        {
            "type": "constructor",
            "inputs": [
                {
                    "name": "addressesProvider",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BRIDGE_PROTOCOL_FEE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TOTAL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_NUMBER_RESERVES",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint16", "internalType": "uint16"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "backUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "fee", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "configureEModeCategory",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "category",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deposit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "dropReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "finalizeTransfer",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceFromBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceToBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoan",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "amounts",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "interestRateModes",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoanSimple",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getBorrowLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getBridgeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeCategoryData",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getFlashLoanLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint40", "internalType": "uint40"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getLiquidationLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPoolLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getReserveAddressById",
            "inputs": [
                {"name": "id", "type": "uint16", "internalType": "uint16"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveData",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveDataLegacy",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveDataExtended",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveData",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationGracePeriodUntil",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "virtualUnderlyingBalance",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedIncome",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedVariableDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesCount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesList",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSupplyLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getUserAccountData",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "totalCollateralBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalDebtBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "availableBorrowsBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "currentLiquidationThreshold",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "ltv", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "healthFactor",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserConfiguration",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.UserConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserEMode",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getVirtualUnderlyingBalance",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "aTokenAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "stableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "variableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "interestRateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "initialize",
            "inputs": [
                {
                    "name": "provider",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {"name": "args1", "type": "bytes32", "internalType": "bytes32"},
                {"name": "args2", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintToTreasury",
            "inputs": [
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rescueTokens",
            "inputs": [
                {"name": "token", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "resetIsolationModeTotalDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "configuration",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "until", "type": "uint40", "internalType": "uint40"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setReserveInterestRateStrategyAddress",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "rateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserEMode",
            "inputs": [
                {"name": "categoryId", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "useAsCollateral",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapToVariable",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncIndexesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncRatesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateBridgeProtocolFee",
            "inputs": [
                {
                    "name": "protocolFee",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateFlashloanPremiums",
            "inputs": [
                {
                    "name": "flashLoanPremiumTotal",
                    "type": "uint128",
                    "internalType": "uint128",
                },
                {
                    "name": "flashLoanPremiumToProtocol",
                    "type": "uint128",
                    "internalType": "uint128",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "BackUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "backer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "fee",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Borrow",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "borrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FlashLoan",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "initiator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "premium",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "IsolationModeTotalDebtUpdated",
            "inputs": [
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "totalDebt",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LiquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidatedCollateralAmount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintedToTreasury",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amountMinted",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RebalanceStableBorrowRate",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Repay",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "repayer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "useATokens",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralDisabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralEnabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Supply",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SwapBorrowRateMode",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserEModeSet",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "categoryId",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "uint8",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Withdraw",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
    ],
)


class MockL2PoolContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the MockL2Pool contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class MockL2PoolADDRESSES_PROVIDERContractFunction0(PypechainContractFunction):
    """ContractFunction for the ADDRESSES_PROVIDER() method."""

    _function_name = "ADDRESSES_PROVIDER"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolADDRESSES_PROVIDERContractFunction(PypechainContractFunction):
    """ContractFunction for the ADDRESSES_PROVIDER method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ADDRESSES_PROVIDER"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolADDRESSES_PROVIDERContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolADDRESSES_PROVIDERContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolADDRESSES_PROVIDERContractFunction0._type_signature: MockL2PoolADDRESSES_PROVIDERContractFunction0.factory(
                "MockL2PoolADDRESSES_PROVIDERContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction0(PypechainContractFunction):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE() method."""

    _function_name = "BRIDGE_PROTOCOL_FEE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction(PypechainContractFunction):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BRIDGE_PROTOCOL_FEE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction0._type_signature: MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction0.factory(
                "MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0._type_signature: MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0.factory(
                "MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0._type_signature: MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0.factory(
                "MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolMAX_NUMBER_RESERVESContractFunction0(PypechainContractFunction):
    """ContractFunction for the MAX_NUMBER_RESERVES() method."""

    _function_name = "MAX_NUMBER_RESERVES"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolMAX_NUMBER_RESERVESContractFunction(PypechainContractFunction):
    """ContractFunction for the MAX_NUMBER_RESERVES method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_NUMBER_RESERVES"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolMAX_NUMBER_RESERVESContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolMAX_NUMBER_RESERVESContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolMAX_NUMBER_RESERVESContractFunction0._type_signature: MockL2PoolMAX_NUMBER_RESERVESContractFunction0.factory(
                "MockL2PoolMAX_NUMBER_RESERVESContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT() method."""

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0._type_signature: MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0.factory(
                "MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolBackUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the backUnbacked(str,int,int) method."""

    _function_name = "backUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolBackUnbackedContractFunction(PypechainContractFunction):
    """ContractFunction for the backUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "backUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, fee: int) -> MockL2PoolBackUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolBackUnbackedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolBackUnbackedContractFunction0._type_signature: MockL2PoolBackUnbackedContractFunction0.factory(
                "MockL2PoolBackUnbackedContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolBorrowContractFunction0(PypechainContractFunction):
    """ContractFunction for the borrow(str,int,int,int,str) method."""

    _function_name = "borrow"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "int", "str"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolBorrowContractFunction1(PypechainContractFunction):
    """ContractFunction for the borrow(bytes) method."""

    _function_name = "borrow"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolBorrowContractFunction(PypechainContractFunction):
    """ContractFunction for the borrow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "borrow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, referralCode: int, onBehalfOf: str) -> MockL2PoolBorrowContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> MockL2PoolBorrowContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolBorrowContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolBorrowContractFunction0._type_signature: MockL2PoolBorrowContractFunction0.factory(
                "MockL2PoolBorrowContractFunction0", **kwargs
            ),
            MockL2PoolBorrowContractFunction1._type_signature: MockL2PoolBorrowContractFunction1.factory(
                "MockL2PoolBorrowContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolConfigureEModeCategoryContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the configureEModeCategory(int,DataTypes.EModeCategory) method."""

    _function_name = "configureEModeCategory"
    _type_signature = expand_struct_type_str(
        tuple(["int", "DataTypes.EModeCategory"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolConfigureEModeCategoryContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the configureEModeCategory method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "configureEModeCategory"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int, category: DataTypes.EModeCategory) -> MockL2PoolConfigureEModeCategoryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolConfigureEModeCategoryContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolConfigureEModeCategoryContractFunction0._type_signature: MockL2PoolConfigureEModeCategoryContractFunction0.factory(
                "MockL2PoolConfigureEModeCategoryContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the deposit(str,int,str,int) method."""

    _function_name = "deposit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolDepositContractFunction(PypechainContractFunction):
    """ContractFunction for the deposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> MockL2PoolDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolDepositContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolDepositContractFunction0._type_signature: MockL2PoolDepositContractFunction0.factory(
                "MockL2PoolDepositContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolDropReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the dropReserve(str) method."""

    _function_name = "dropReserve"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolDropReserveContractFunction(PypechainContractFunction):
    """ContractFunction for the dropReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "dropReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolDropReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolDropReserveContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolDropReserveContractFunction0._type_signature: MockL2PoolDropReserveContractFunction0.factory(
                "MockL2PoolDropReserveContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolFinalizeTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the finalizeTransfer(str,str,str,int,int,int) method."""

    _function_name = "finalizeTransfer"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "int", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolFinalizeTransferContractFunction(PypechainContractFunction):
    """ContractFunction for the finalizeTransfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "finalizeTransfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, _from: str, to: str, amount: int, balanceFromBefore: int, balanceToBefore: int) -> MockL2PoolFinalizeTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolFinalizeTransferContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolFinalizeTransferContractFunction0._type_signature: MockL2PoolFinalizeTransferContractFunction0.factory(
                "MockL2PoolFinalizeTransferContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolFlashLoanContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoan(str,list[str],list[int],list[int],str,bytes,int) method."""

    _function_name = "flashLoan"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "list[str]",
                "list[int]",
                "list[int]",
                "str",
                "bytes",
                "int",
            ]
        ),
        structs,
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolFlashLoanContractFunction(PypechainContractFunction):
    """ContractFunction for the flashLoan method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoan"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, assets: list[str], amounts: list[int], interestRateModes: list[int], onBehalfOf: str, params: bytes, referralCode: int) -> MockL2PoolFlashLoanContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolFlashLoanContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolFlashLoanContractFunction0._type_signature: MockL2PoolFlashLoanContractFunction0.factory(
                "MockL2PoolFlashLoanContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolFlashLoanSimpleContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoanSimple(str,str,int,bytes,int) method."""

    _function_name = "flashLoanSimple"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "bytes", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolFlashLoanSimpleContractFunction(PypechainContractFunction):
    """ContractFunction for the flashLoanSimple method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoanSimple"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, asset: str, amount: int, params: bytes, referralCode: int) -> MockL2PoolFlashLoanSimpleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolFlashLoanSimpleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolFlashLoanSimpleContractFunction0._type_signature: MockL2PoolFlashLoanSimpleContractFunction0.factory(
                "MockL2PoolFlashLoanSimpleContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetBorrowLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBorrowLogic() method."""

    _function_name = "getBorrowLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetBorrowLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getBorrowLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBorrowLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetBorrowLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetBorrowLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetBorrowLogicContractFunction0._type_signature: MockL2PoolGetBorrowLogicContractFunction0.factory(
                "MockL2PoolGetBorrowLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetBridgeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBridgeLogic() method."""

    _function_name = "getBridgeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetBridgeLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getBridgeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBridgeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetBridgeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetBridgeLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetBridgeLogicContractFunction0._type_signature: MockL2PoolGetBridgeLogicContractFunction0.factory(
                "MockL2PoolGetBridgeLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the getConfiguration(str) method."""

    _function_name = "getConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveConfigurationMap:
        """returns DataTypes.ReserveConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class MockL2PoolGetConfigurationContractFunction(PypechainContractFunction):
    """ContractFunction for the getConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetConfigurationContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetConfigurationContractFunction0._type_signature: MockL2PoolGetConfigurationContractFunction0.factory(
                "MockL2PoolGetConfigurationContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetEModeCategoryDataContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getEModeCategoryData(int) method."""

    _function_name = "getEModeCategoryData"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.EModeCategory:
        """returns DataTypes.EModeCategory."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.EModeCategory

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.EModeCategory,
            rename_returned_types(structs, return_types, raw_values),
        )


class MockL2PoolGetEModeCategoryDataContractFunction(PypechainContractFunction):
    """ContractFunction for the getEModeCategoryData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeCategoryData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> MockL2PoolGetEModeCategoryDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetEModeCategoryDataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetEModeCategoryDataContractFunction0._type_signature: MockL2PoolGetEModeCategoryDataContractFunction0.factory(
                "MockL2PoolGetEModeCategoryDataContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetEModeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getEModeLogic() method."""

    _function_name = "getEModeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetEModeLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getEModeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetEModeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetEModeLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetEModeLogicContractFunction0._type_signature: MockL2PoolGetEModeLogicContractFunction0.factory(
                "MockL2PoolGetEModeLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetFlashLoanLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getFlashLoanLogic() method."""

    _function_name = "getFlashLoanLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetFlashLoanLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getFlashLoanLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFlashLoanLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetFlashLoanLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetFlashLoanLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetFlashLoanLogicContractFunction0._type_signature: MockL2PoolGetFlashLoanLogicContractFunction0.factory(
                "MockL2PoolGetFlashLoanLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getLiquidationGracePeriod(str) method."""

    _function_name = "getLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetLiquidationGracePeriodContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetLiquidationGracePeriodContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetLiquidationGracePeriodContractFunction0._type_signature: MockL2PoolGetLiquidationGracePeriodContractFunction0.factory(
                "MockL2PoolGetLiquidationGracePeriodContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetLiquidationLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getLiquidationLogic() method."""

    _function_name = "getLiquidationLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetLiquidationLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getLiquidationLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetLiquidationLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetLiquidationLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetLiquidationLogicContractFunction0._type_signature: MockL2PoolGetLiquidationLogicContractFunction0.factory(
                "MockL2PoolGetLiquidationLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetPoolLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPoolLogic() method."""

    _function_name = "getPoolLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetPoolLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getPoolLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPoolLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetPoolLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetPoolLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetPoolLogicContractFunction0._type_signature: MockL2PoolGetPoolLogicContractFunction0.factory(
                "MockL2PoolGetPoolLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetReserveAddressByIdContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveAddressById(int) method."""

    _function_name = "getReserveAddressById"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetReserveAddressByIdContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getReserveAddressById method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveAddressById"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> MockL2PoolGetReserveAddressByIdContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReserveAddressByIdContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReserveAddressByIdContractFunction0._type_signature: MockL2PoolGetReserveAddressByIdContractFunction0.factory(
                "MockL2PoolGetReserveAddressByIdContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetReserveDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveData(str) method."""

    _function_name = "getReserveData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveDataLegacy:
        """returns DataTypes.ReserveDataLegacy."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveDataLegacy

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveDataLegacy,
            rename_returned_types(structs, return_types, raw_values),
        )


class MockL2PoolGetReserveDataContractFunction(PypechainContractFunction):
    """ContractFunction for the getReserveData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetReserveDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReserveDataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReserveDataContractFunction0._type_signature: MockL2PoolGetReserveDataContractFunction0.factory(
                "MockL2PoolGetReserveDataContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetReserveDataExtendedContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveDataExtended(str) method."""

    _function_name = "getReserveDataExtended"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveData:
        """returns DataTypes.ReserveData."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveData

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveData,
            rename_returned_types(structs, return_types, raw_values),
        )


class MockL2PoolGetReserveDataExtendedContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getReserveDataExtended method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveDataExtended"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetReserveDataExtendedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReserveDataExtendedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReserveDataExtendedContractFunction0._type_signature: MockL2PoolGetReserveDataExtendedContractFunction0.factory(
                "MockL2PoolGetReserveDataExtendedContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetReserveNormalizedIncomeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedIncome(str) method."""

    _function_name = "getReserveNormalizedIncome"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetReserveNormalizedIncomeContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedIncome method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedIncome"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetReserveNormalizedIncomeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReserveNormalizedIncomeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReserveNormalizedIncomeContractFunction0._type_signature: MockL2PoolGetReserveNormalizedIncomeContractFunction0.factory(
                "MockL2PoolGetReserveNormalizedIncomeContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolGetReserveNormalizedVariableDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedVariableDebt(str) method."""

    _function_name = "getReserveNormalizedVariableDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetReserveNormalizedVariableDebtContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedVariableDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedVariableDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetReserveNormalizedVariableDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReserveNormalizedVariableDebtContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReserveNormalizedVariableDebtContractFunction0._type_signature: MockL2PoolGetReserveNormalizedVariableDebtContractFunction0.factory(
                "MockL2PoolGetReserveNormalizedVariableDebtContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolGetReservesCountContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesCount() method."""

    _function_name = "getReservesCount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetReservesCountContractFunction(PypechainContractFunction):
    """ContractFunction for the getReservesCount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesCount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetReservesCountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReservesCountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReservesCountContractFunction0._type_signature: MockL2PoolGetReservesCountContractFunction0.factory(
                "MockL2PoolGetReservesCountContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetReservesListContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesList() method."""

    _function_name = "getReservesList"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetReservesListContractFunction(PypechainContractFunction):
    """ContractFunction for the getReservesList method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesList"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetReservesListContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetReservesListContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetReservesListContractFunction0._type_signature: MockL2PoolGetReservesListContractFunction0.factory(
                "MockL2PoolGetReservesListContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetSupplyLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSupplyLogic() method."""

    _function_name = "getSupplyLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetSupplyLogicContractFunction(PypechainContractFunction):
    """ContractFunction for the getSupplyLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSupplyLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockL2PoolGetSupplyLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetSupplyLogicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetSupplyLogicContractFunction0._type_signature: MockL2PoolGetSupplyLogicContractFunction0.factory(
                "MockL2PoolGetSupplyLogicContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetUserAccountDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserAccountData(str) method."""

    _function_name = "getUserAccountData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for GetUserAccountData."""

        totalCollateralBase: int
        totalDebtBase: int
        availableBorrowsBase: int
        currentLiquidationThreshold: int
        ltv: int
        healthFactor: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int, int, int, int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetUserAccountDataContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserAccountData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserAccountData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> MockL2PoolGetUserAccountDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetUserAccountDataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetUserAccountDataContractFunction0._type_signature: MockL2PoolGetUserAccountDataContractFunction0.factory(
                "MockL2PoolGetUserAccountDataContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetUserConfigurationContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getUserConfiguration(str) method."""

    _function_name = "getUserConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.UserConfigurationMap:
        """returns DataTypes.UserConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.UserConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.UserConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class MockL2PoolGetUserConfigurationContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> MockL2PoolGetUserConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetUserConfigurationContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetUserConfigurationContractFunction0._type_signature: MockL2PoolGetUserConfigurationContractFunction0.factory(
                "MockL2PoolGetUserConfigurationContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserEMode(str) method."""

    _function_name = "getUserEMode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetUserEModeContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> MockL2PoolGetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetUserEModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetUserEModeContractFunction0._type_signature: MockL2PoolGetUserEModeContractFunction0.factory(
                "MockL2PoolGetUserEModeContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolGetVirtualUnderlyingBalanceContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getVirtualUnderlyingBalance(str) method."""

    _function_name = "getVirtualUnderlyingBalance"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolGetVirtualUnderlyingBalanceContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getVirtualUnderlyingBalance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getVirtualUnderlyingBalance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolGetVirtualUnderlyingBalanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolGetVirtualUnderlyingBalanceContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolGetVirtualUnderlyingBalanceContractFunction0._type_signature: MockL2PoolGetVirtualUnderlyingBalanceContractFunction0.factory(
                "MockL2PoolGetVirtualUnderlyingBalanceContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolInitReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the initReserve(str,str,str,str,str) method."""

    _function_name = "initReserve"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "str", "str"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolInitReserveContractFunction(PypechainContractFunction):
    """ContractFunction for the initReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, aTokenAddress: str, stableDebtAddress: str, variableDebtAddress: str, interestRateStrategyAddress: str) -> MockL2PoolInitReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolInitReserveContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolInitReserveContractFunction0._type_signature: MockL2PoolInitReserveContractFunction0.factory(
                "MockL2PoolInitReserveContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolInitializeContractFunction0(PypechainContractFunction):
    """ContractFunction for the initialize(str) method."""

    _function_name = "initialize"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolInitializeContractFunction(PypechainContractFunction):
    """ContractFunction for the initialize method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initialize"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, provider: str) -> MockL2PoolInitializeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolInitializeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolInitializeContractFunction0._type_signature: MockL2PoolInitializeContractFunction0.factory(
                "MockL2PoolInitializeContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolLiquidationCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the liquidationCall(str,str,str,int,bool) method."""

    _function_name = "liquidationCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "bool"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolLiquidationCallContractFunction1(PypechainContractFunction):
    """ContractFunction for the liquidationCall(bytes,bytes) method."""

    _function_name = "liquidationCall"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolLiquidationCallContractFunction(PypechainContractFunction):
    """ContractFunction for the liquidationCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "liquidationCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, collateralAsset: str, debtAsset: str, user: str, debtToCover: int, receiveAToken: bool) -> MockL2PoolLiquidationCallContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args1: bytes, args2: bytes) -> MockL2PoolLiquidationCallContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolLiquidationCallContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolLiquidationCallContractFunction0._type_signature: MockL2PoolLiquidationCallContractFunction0.factory(
                "MockL2PoolLiquidationCallContractFunction0", **kwargs
            ),
            MockL2PoolLiquidationCallContractFunction1._type_signature: MockL2PoolLiquidationCallContractFunction1.factory(
                "MockL2PoolLiquidationCallContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolMintToTreasuryContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintToTreasury(list[str]) method."""

    _function_name = "mintToTreasury"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolMintToTreasuryContractFunction(PypechainContractFunction):
    """ContractFunction for the mintToTreasury method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintToTreasury"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: list[str]) -> MockL2PoolMintToTreasuryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolMintToTreasuryContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolMintToTreasuryContractFunction0._type_signature: MockL2PoolMintToTreasuryContractFunction0.factory(
                "MockL2PoolMintToTreasuryContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolMintUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintUnbacked(str,int,str,int) method."""

    _function_name = "mintUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolMintUnbackedContractFunction(PypechainContractFunction):
    """ContractFunction for the mintUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> MockL2PoolMintUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolMintUnbackedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolMintUnbackedContractFunction0._type_signature: MockL2PoolMintUnbackedContractFunction0.factory(
                "MockL2PoolMintUnbackedContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolRebalanceStableBorrowRateContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate(bytes) method."""

    _function_name = "rebalanceStableBorrowRate"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolRebalanceStableBorrowRateContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate(str,str) method."""

    _function_name = "rebalanceStableBorrowRate"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolRebalanceStableBorrowRateContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rebalanceStableBorrowRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> MockL2PoolRebalanceStableBorrowRateContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, user: str) -> MockL2PoolRebalanceStableBorrowRateContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolRebalanceStableBorrowRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolRebalanceStableBorrowRateContractFunction0._type_signature: MockL2PoolRebalanceStableBorrowRateContractFunction0.factory(
                "MockL2PoolRebalanceStableBorrowRateContractFunction0", **kwargs
            ),
            MockL2PoolRebalanceStableBorrowRateContractFunction1._type_signature: MockL2PoolRebalanceStableBorrowRateContractFunction1.factory(
                "MockL2PoolRebalanceStableBorrowRateContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolRepayContractFunction0(PypechainContractFunction):
    """ContractFunction for the repay(bytes) method."""

    _function_name = "repay"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayContractFunction1(PypechainContractFunction):
    """ContractFunction for the repay(str,int,int,str) method."""

    _function_name = "repay"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayContractFunction(PypechainContractFunction):
    """ContractFunction for the repay method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repay"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> MockL2PoolRepayContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str) -> MockL2PoolRepayContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolRepayContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolRepayContractFunction0._type_signature: MockL2PoolRepayContractFunction0.factory(
                "MockL2PoolRepayContractFunction0", **kwargs
            ),
            MockL2PoolRepayContractFunction1._type_signature: MockL2PoolRepayContractFunction1.factory(
                "MockL2PoolRepayContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolRepayWithATokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithATokens(str,int,int) method."""

    _function_name = "repayWithATokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayWithATokensContractFunction1(PypechainContractFunction):
    """ContractFunction for the repayWithATokens(bytes) method."""

    _function_name = "repayWithATokens"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayWithATokensContractFunction(PypechainContractFunction):
    """ContractFunction for the repayWithATokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithATokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int) -> MockL2PoolRepayWithATokensContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> MockL2PoolRepayWithATokensContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolRepayWithATokensContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolRepayWithATokensContractFunction0._type_signature: MockL2PoolRepayWithATokensContractFunction0.factory(
                "MockL2PoolRepayWithATokensContractFunction0", **kwargs
            ),
            MockL2PoolRepayWithATokensContractFunction1._type_signature: MockL2PoolRepayWithATokensContractFunction1.factory(
                "MockL2PoolRepayWithATokensContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolRepayWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithPermit(bytes,bytes,bytes) method."""

    _function_name = "repayWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "bytes"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayWithPermitContractFunction1(PypechainContractFunction):
    """ContractFunction for the repayWithPermit(str,int,int,str,int,int,bytes,bytes) method."""

    _function_name = "repayWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolRepayWithPermitContractFunction(PypechainContractFunction):
    """ContractFunction for the repayWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes, r: bytes, s: bytes) -> MockL2PoolRepayWithPermitContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> MockL2PoolRepayWithPermitContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolRepayWithPermitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolRepayWithPermitContractFunction0._type_signature: MockL2PoolRepayWithPermitContractFunction0.factory(
                "MockL2PoolRepayWithPermitContractFunction0", **kwargs
            ),
            MockL2PoolRepayWithPermitContractFunction1._type_signature: MockL2PoolRepayWithPermitContractFunction1.factory(
                "MockL2PoolRepayWithPermitContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolRescueTokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the rescueTokens(str,str,int) method."""

    _function_name = "rescueTokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolRescueTokensContractFunction(PypechainContractFunction):
    """ContractFunction for the rescueTokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rescueTokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, token: str, to: str, amount: int) -> MockL2PoolRescueTokensContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolRescueTokensContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolRescueTokensContractFunction0._type_signature: MockL2PoolRescueTokensContractFunction0.factory(
                "MockL2PoolRescueTokensContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolResetIsolationModeTotalDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the resetIsolationModeTotalDebt(str) method."""

    _function_name = "resetIsolationModeTotalDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolResetIsolationModeTotalDebtContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the resetIsolationModeTotalDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resetIsolationModeTotalDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolResetIsolationModeTotalDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolResetIsolationModeTotalDebtContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolResetIsolationModeTotalDebtContractFunction0._type_signature: MockL2PoolResetIsolationModeTotalDebtContractFunction0.factory(
                "MockL2PoolResetIsolationModeTotalDebtContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolSetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the setConfiguration(str,DataTypes.ReserveConfigurationMap) method."""

    _function_name = "setConfiguration"
    _type_signature = expand_struct_type_str(
        tuple(["str", "DataTypes.ReserveConfigurationMap"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetConfigurationContractFunction(PypechainContractFunction):
    """ContractFunction for the setConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, configuration: DataTypes.ReserveConfigurationMap) -> MockL2PoolSetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSetConfigurationContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSetConfigurationContractFunction0._type_signature: MockL2PoolSetConfigurationContractFunction0.factory(
                "MockL2PoolSetConfigurationContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolSetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setLiquidationGracePeriod(str,int) method."""

    _function_name = "setLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetLiquidationGracePeriodContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, until: int) -> MockL2PoolSetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSetLiquidationGracePeriodContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSetLiquidationGracePeriodContractFunction0._type_signature: MockL2PoolSetLiquidationGracePeriodContractFunction0.factory(
                "MockL2PoolSetLiquidationGracePeriodContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolSetReserveInterestRateStrategyAddressContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setReserveInterestRateStrategyAddress(str,str) method."""

    _function_name = "setReserveInterestRateStrategyAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetReserveInterestRateStrategyAddressContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setReserveInterestRateStrategyAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setReserveInterestRateStrategyAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, rateStrategyAddress: str) -> MockL2PoolSetReserveInterestRateStrategyAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSetReserveInterestRateStrategyAddressContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSetReserveInterestRateStrategyAddressContractFunction0._type_signature: MockL2PoolSetReserveInterestRateStrategyAddressContractFunction0.factory(
                "MockL2PoolSetReserveInterestRateStrategyAddressContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockL2PoolSetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserEMode(int) method."""

    _function_name = "setUserEMode"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetUserEModeContractFunction(PypechainContractFunction):
    """ContractFunction for the setUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, categoryId: int) -> MockL2PoolSetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSetUserEModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSetUserEModeContractFunction0._type_signature: MockL2PoolSetUserEModeContractFunction0.factory(
                "MockL2PoolSetUserEModeContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolSetUserUseReserveAsCollateralContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral(bytes) method."""

    _function_name = "setUserUseReserveAsCollateral"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetUserUseReserveAsCollateralContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral(str,bool) method."""

    _function_name = "setUserUseReserveAsCollateral"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSetUserUseReserveAsCollateralContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserUseReserveAsCollateral"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> MockL2PoolSetUserUseReserveAsCollateralContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, useAsCollateral: bool) -> MockL2PoolSetUserUseReserveAsCollateralContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSetUserUseReserveAsCollateralContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSetUserUseReserveAsCollateralContractFunction0._type_signature: MockL2PoolSetUserUseReserveAsCollateralContractFunction0.factory(
                "MockL2PoolSetUserUseReserveAsCollateralContractFunction0",
                **kwargs,
            ),
            MockL2PoolSetUserUseReserveAsCollateralContractFunction1._type_signature: MockL2PoolSetUserUseReserveAsCollateralContractFunction1.factory(
                "MockL2PoolSetUserUseReserveAsCollateralContractFunction1",
                **kwargs,
            ),
        }
        return out


class MockL2PoolSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the supply(str,int,str,int) method."""

    _function_name = "supply"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSupplyContractFunction1(PypechainContractFunction):
    """ContractFunction for the supply(bytes) method."""

    _function_name = "supply"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSupplyContractFunction(PypechainContractFunction):
    """ContractFunction for the supply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> MockL2PoolSupplyContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> MockL2PoolSupplyContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSupplyContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSupplyContractFunction0._type_signature: MockL2PoolSupplyContractFunction0.factory(
                "MockL2PoolSupplyContractFunction0", **kwargs
            ),
            MockL2PoolSupplyContractFunction1._type_signature: MockL2PoolSupplyContractFunction1.factory(
                "MockL2PoolSupplyContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolSupplyWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit(str,int,str,int,int,int,bytes,bytes) method."""

    _function_name = "supplyWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSupplyWithPermitContractFunction1(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit(bytes,bytes,bytes) method."""

    _function_name = "supplyWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "bytes"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSupplyWithPermitContractFunction(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supplyWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> MockL2PoolSupplyWithPermitContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes, r: bytes, s: bytes) -> MockL2PoolSupplyWithPermitContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSupplyWithPermitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSupplyWithPermitContractFunction0._type_signature: MockL2PoolSupplyWithPermitContractFunction0.factory(
                "MockL2PoolSupplyWithPermitContractFunction0", **kwargs
            ),
            MockL2PoolSupplyWithPermitContractFunction1._type_signature: MockL2PoolSupplyWithPermitContractFunction1.factory(
                "MockL2PoolSupplyWithPermitContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolSwapBorrowRateModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode(bytes) method."""

    _function_name = "swapBorrowRateMode"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSwapBorrowRateModeContractFunction1(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode(str,int) method."""

    _function_name = "swapBorrowRateMode"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSwapBorrowRateModeContractFunction(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapBorrowRateMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> MockL2PoolSwapBorrowRateModeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, interestRateMode: int) -> MockL2PoolSwapBorrowRateModeContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSwapBorrowRateModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSwapBorrowRateModeContractFunction0._type_signature: MockL2PoolSwapBorrowRateModeContractFunction0.factory(
                "MockL2PoolSwapBorrowRateModeContractFunction0", **kwargs
            ),
            MockL2PoolSwapBorrowRateModeContractFunction1._type_signature: MockL2PoolSwapBorrowRateModeContractFunction1.factory(
                "MockL2PoolSwapBorrowRateModeContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolSwapToVariableContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapToVariable(str,str) method."""

    _function_name = "swapToVariable"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSwapToVariableContractFunction(PypechainContractFunction):
    """ContractFunction for the swapToVariable method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapToVariable"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, user: str) -> MockL2PoolSwapToVariableContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSwapToVariableContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSwapToVariableContractFunction0._type_signature: MockL2PoolSwapToVariableContractFunction0.factory(
                "MockL2PoolSwapToVariableContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolSyncIndexesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncIndexesState(str) method."""

    _function_name = "syncIndexesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSyncIndexesStateContractFunction(PypechainContractFunction):
    """ContractFunction for the syncIndexesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncIndexesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolSyncIndexesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSyncIndexesStateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSyncIndexesStateContractFunction0._type_signature: MockL2PoolSyncIndexesStateContractFunction0.factory(
                "MockL2PoolSyncIndexesStateContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolSyncRatesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncRatesState(str) method."""

    _function_name = "syncRatesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolSyncRatesStateContractFunction(PypechainContractFunction):
    """ContractFunction for the syncRatesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncRatesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> MockL2PoolSyncRatesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolSyncRatesStateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolSyncRatesStateContractFunction0._type_signature: MockL2PoolSyncRatesStateContractFunction0.factory(
                "MockL2PoolSyncRatesStateContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolUpdateBridgeProtocolFeeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the updateBridgeProtocolFee(int) method."""

    _function_name = "updateBridgeProtocolFee"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolUpdateBridgeProtocolFeeContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the updateBridgeProtocolFee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateBridgeProtocolFee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, protocolFee: int) -> MockL2PoolUpdateBridgeProtocolFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolUpdateBridgeProtocolFeeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolUpdateBridgeProtocolFeeContractFunction0._type_signature: MockL2PoolUpdateBridgeProtocolFeeContractFunction0.factory(
                "MockL2PoolUpdateBridgeProtocolFeeContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolUpdateFlashloanPremiumsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the updateFlashloanPremiums(int,int) method."""

    _function_name = "updateFlashloanPremiums"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockL2PoolUpdateFlashloanPremiumsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the updateFlashloanPremiums method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateFlashloanPremiums"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, flashLoanPremiumTotal: int, flashLoanPremiumToProtocol: int) -> MockL2PoolUpdateFlashloanPremiumsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolUpdateFlashloanPremiumsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolUpdateFlashloanPremiumsContractFunction0._type_signature: MockL2PoolUpdateFlashloanPremiumsContractFunction0.factory(
                "MockL2PoolUpdateFlashloanPremiumsContractFunction0", **kwargs
            ),
        }
        return out


class MockL2PoolWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the withdraw(str,int,str) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str"]), structs
    )
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolWithdrawContractFunction1(PypechainContractFunction):
    """ContractFunction for the withdraw(bytes) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockL2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockL2PoolWithdrawContractFunction(PypechainContractFunction):
    """ContractFunction for the withdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "withdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, to: str) -> MockL2PoolWithdrawContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> MockL2PoolWithdrawContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockL2PoolWithdrawContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockL2PoolWithdrawContractFunction0._type_signature: MockL2PoolWithdrawContractFunction0.factory(
                "MockL2PoolWithdrawContractFunction0", **kwargs
            ),
            MockL2PoolWithdrawContractFunction1._type_signature: MockL2PoolWithdrawContractFunction1.factory(
                "MockL2PoolWithdrawContractFunction1", **kwargs
            ),
        }
        return out


class MockL2PoolContractFunctions(ContractFunctions):
    """ContractFunctions for the MockL2Pool contract."""

    ADDRESSES_PROVIDER: MockL2PoolADDRESSES_PROVIDERContractFunction

    BRIDGE_PROTOCOL_FEE: MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction

    FLASHLOAN_PREMIUM_TOTAL: MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction

    FLASHLOAN_PREMIUM_TO_PROTOCOL: (
        MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction
    )

    MAX_NUMBER_RESERVES: MockL2PoolMAX_NUMBER_RESERVESContractFunction

    MAX_STABLE_RATE_BORROW_SIZE_PERCENT: (
        MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction
    )

    backUnbacked: MockL2PoolBackUnbackedContractFunction

    borrow: MockL2PoolBorrowContractFunction

    configureEModeCategory: MockL2PoolConfigureEModeCategoryContractFunction

    deposit: MockL2PoolDepositContractFunction

    dropReserve: MockL2PoolDropReserveContractFunction

    finalizeTransfer: MockL2PoolFinalizeTransferContractFunction

    flashLoan: MockL2PoolFlashLoanContractFunction

    flashLoanSimple: MockL2PoolFlashLoanSimpleContractFunction

    getBorrowLogic: MockL2PoolGetBorrowLogicContractFunction

    getBridgeLogic: MockL2PoolGetBridgeLogicContractFunction

    getConfiguration: MockL2PoolGetConfigurationContractFunction

    getEModeCategoryData: MockL2PoolGetEModeCategoryDataContractFunction

    getEModeLogic: MockL2PoolGetEModeLogicContractFunction

    getFlashLoanLogic: MockL2PoolGetFlashLoanLogicContractFunction

    getLiquidationGracePeriod: (
        MockL2PoolGetLiquidationGracePeriodContractFunction
    )

    getLiquidationLogic: MockL2PoolGetLiquidationLogicContractFunction

    getPoolLogic: MockL2PoolGetPoolLogicContractFunction

    getReserveAddressById: MockL2PoolGetReserveAddressByIdContractFunction

    getReserveData: MockL2PoolGetReserveDataContractFunction

    getReserveDataExtended: MockL2PoolGetReserveDataExtendedContractFunction

    getReserveNormalizedIncome: (
        MockL2PoolGetReserveNormalizedIncomeContractFunction
    )

    getReserveNormalizedVariableDebt: (
        MockL2PoolGetReserveNormalizedVariableDebtContractFunction
    )

    getReservesCount: MockL2PoolGetReservesCountContractFunction

    getReservesList: MockL2PoolGetReservesListContractFunction

    getSupplyLogic: MockL2PoolGetSupplyLogicContractFunction

    getUserAccountData: MockL2PoolGetUserAccountDataContractFunction

    getUserConfiguration: MockL2PoolGetUserConfigurationContractFunction

    getUserEMode: MockL2PoolGetUserEModeContractFunction

    getVirtualUnderlyingBalance: (
        MockL2PoolGetVirtualUnderlyingBalanceContractFunction
    )

    initReserve: MockL2PoolInitReserveContractFunction

    initialize: MockL2PoolInitializeContractFunction

    liquidationCall: MockL2PoolLiquidationCallContractFunction

    mintToTreasury: MockL2PoolMintToTreasuryContractFunction

    mintUnbacked: MockL2PoolMintUnbackedContractFunction

    rebalanceStableBorrowRate: (
        MockL2PoolRebalanceStableBorrowRateContractFunction
    )

    repay: MockL2PoolRepayContractFunction

    repayWithATokens: MockL2PoolRepayWithATokensContractFunction

    repayWithPermit: MockL2PoolRepayWithPermitContractFunction

    rescueTokens: MockL2PoolRescueTokensContractFunction

    resetIsolationModeTotalDebt: (
        MockL2PoolResetIsolationModeTotalDebtContractFunction
    )

    setConfiguration: MockL2PoolSetConfigurationContractFunction

    setLiquidationGracePeriod: (
        MockL2PoolSetLiquidationGracePeriodContractFunction
    )

    setReserveInterestRateStrategyAddress: (
        MockL2PoolSetReserveInterestRateStrategyAddressContractFunction
    )

    setUserEMode: MockL2PoolSetUserEModeContractFunction

    setUserUseReserveAsCollateral: (
        MockL2PoolSetUserUseReserveAsCollateralContractFunction
    )

    supply: MockL2PoolSupplyContractFunction

    supplyWithPermit: MockL2PoolSupplyWithPermitContractFunction

    swapBorrowRateMode: MockL2PoolSwapBorrowRateModeContractFunction

    swapToVariable: MockL2PoolSwapToVariableContractFunction

    syncIndexesState: MockL2PoolSyncIndexesStateContractFunction

    syncRatesState: MockL2PoolSyncRatesStateContractFunction

    updateBridgeProtocolFee: MockL2PoolUpdateBridgeProtocolFeeContractFunction

    updateFlashloanPremiums: MockL2PoolUpdateFlashloanPremiumsContractFunction

    withdraw: MockL2PoolWithdrawContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.ADDRESSES_PROVIDER = (
            MockL2PoolADDRESSES_PROVIDERContractFunction.factory(
                "ADDRESSES_PROVIDER",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER",
            )
        )
        self.BRIDGE_PROTOCOL_FEE = (
            MockL2PoolBRIDGE_PROTOCOL_FEEContractFunction.factory(
                "BRIDGE_PROTOCOL_FEE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BRIDGE_PROTOCOL_FEE",
            )
        )
        self.FLASHLOAN_PREMIUM_TOTAL = (
            MockL2PoolFLASHLOAN_PREMIUM_TOTALContractFunction.factory(
                "FLASHLOAN_PREMIUM_TOTAL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TOTAL",
            )
        )
        self.FLASHLOAN_PREMIUM_TO_PROTOCOL = (
            MockL2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction.factory(
                "FLASHLOAN_PREMIUM_TO_PROTOCOL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TO_PROTOCOL",
            )
        )
        self.MAX_NUMBER_RESERVES = (
            MockL2PoolMAX_NUMBER_RESERVESContractFunction.factory(
                "MAX_NUMBER_RESERVES",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_NUMBER_RESERVES",
            )
        )
        self.MAX_STABLE_RATE_BORROW_SIZE_PERCENT = MockL2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction.factory(
            "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
        )
        self.backUnbacked = MockL2PoolBackUnbackedContractFunction.factory(
            "backUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="backUnbacked",
        )
        self.borrow = MockL2PoolBorrowContractFunction.factory(
            "borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="borrow",
        )
        self.configureEModeCategory = (
            MockL2PoolConfigureEModeCategoryContractFunction.factory(
                "configureEModeCategory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="configureEModeCategory",
            )
        )
        self.deposit = MockL2PoolDepositContractFunction.factory(
            "deposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deposit",
        )
        self.dropReserve = MockL2PoolDropReserveContractFunction.factory(
            "dropReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="dropReserve",
        )
        self.finalizeTransfer = (
            MockL2PoolFinalizeTransferContractFunction.factory(
                "finalizeTransfer",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="finalizeTransfer",
            )
        )
        self.flashLoan = MockL2PoolFlashLoanContractFunction.factory(
            "flashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoan",
        )
        self.flashLoanSimple = (
            MockL2PoolFlashLoanSimpleContractFunction.factory(
                "flashLoanSimple",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="flashLoanSimple",
            )
        )
        self.getBorrowLogic = MockL2PoolGetBorrowLogicContractFunction.factory(
            "getBorrowLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBorrowLogic",
        )
        self.getBridgeLogic = MockL2PoolGetBridgeLogicContractFunction.factory(
            "getBridgeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBridgeLogic",
        )
        self.getConfiguration = (
            MockL2PoolGetConfigurationContractFunction.factory(
                "getConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getConfiguration",
            )
        )
        self.getEModeCategoryData = (
            MockL2PoolGetEModeCategoryDataContractFunction.factory(
                "getEModeCategoryData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getEModeCategoryData",
            )
        )
        self.getEModeLogic = MockL2PoolGetEModeLogicContractFunction.factory(
            "getEModeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getEModeLogic",
        )
        self.getFlashLoanLogic = (
            MockL2PoolGetFlashLoanLogicContractFunction.factory(
                "getFlashLoanLogic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFlashLoanLogic",
            )
        )
        self.getLiquidationGracePeriod = (
            MockL2PoolGetLiquidationGracePeriodContractFunction.factory(
                "getLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationGracePeriod",
            )
        )
        self.getLiquidationLogic = (
            MockL2PoolGetLiquidationLogicContractFunction.factory(
                "getLiquidationLogic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationLogic",
            )
        )
        self.getPoolLogic = MockL2PoolGetPoolLogicContractFunction.factory(
            "getPoolLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getPoolLogic",
        )
        self.getReserveAddressById = (
            MockL2PoolGetReserveAddressByIdContractFunction.factory(
                "getReserveAddressById",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveAddressById",
            )
        )
        self.getReserveData = MockL2PoolGetReserveDataContractFunction.factory(
            "getReserveData",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReserveData",
        )
        self.getReserveDataExtended = (
            MockL2PoolGetReserveDataExtendedContractFunction.factory(
                "getReserveDataExtended",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveDataExtended",
            )
        )
        self.getReserveNormalizedIncome = (
            MockL2PoolGetReserveNormalizedIncomeContractFunction.factory(
                "getReserveNormalizedIncome",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedIncome",
            )
        )
        self.getReserveNormalizedVariableDebt = (
            MockL2PoolGetReserveNormalizedVariableDebtContractFunction.factory(
                "getReserveNormalizedVariableDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedVariableDebt",
            )
        )
        self.getReservesCount = (
            MockL2PoolGetReservesCountContractFunction.factory(
                "getReservesCount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReservesCount",
            )
        )
        self.getReservesList = (
            MockL2PoolGetReservesListContractFunction.factory(
                "getReservesList",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReservesList",
            )
        )
        self.getSupplyLogic = MockL2PoolGetSupplyLogicContractFunction.factory(
            "getSupplyLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getSupplyLogic",
        )
        self.getUserAccountData = (
            MockL2PoolGetUserAccountDataContractFunction.factory(
                "getUserAccountData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserAccountData",
            )
        )
        self.getUserConfiguration = (
            MockL2PoolGetUserConfigurationContractFunction.factory(
                "getUserConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserConfiguration",
            )
        )
        self.getUserEMode = MockL2PoolGetUserEModeContractFunction.factory(
            "getUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserEMode",
        )
        self.getVirtualUnderlyingBalance = (
            MockL2PoolGetVirtualUnderlyingBalanceContractFunction.factory(
                "getVirtualUnderlyingBalance",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getVirtualUnderlyingBalance",
            )
        )
        self.initReserve = MockL2PoolInitReserveContractFunction.factory(
            "initReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initReserve",
        )
        self.initialize = MockL2PoolInitializeContractFunction.factory(
            "initialize",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initialize",
        )
        self.liquidationCall = (
            MockL2PoolLiquidationCallContractFunction.factory(
                "liquidationCall",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="liquidationCall",
            )
        )
        self.mintToTreasury = MockL2PoolMintToTreasuryContractFunction.factory(
            "mintToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintToTreasury",
        )
        self.mintUnbacked = MockL2PoolMintUnbackedContractFunction.factory(
            "mintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintUnbacked",
        )
        self.rebalanceStableBorrowRate = (
            MockL2PoolRebalanceStableBorrowRateContractFunction.factory(
                "rebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="rebalanceStableBorrowRate",
            )
        )
        self.repay = MockL2PoolRepayContractFunction.factory(
            "repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repay",
        )
        self.repayWithATokens = (
            MockL2PoolRepayWithATokensContractFunction.factory(
                "repayWithATokens",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="repayWithATokens",
            )
        )
        self.repayWithPermit = (
            MockL2PoolRepayWithPermitContractFunction.factory(
                "repayWithPermit",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="repayWithPermit",
            )
        )
        self.rescueTokens = MockL2PoolRescueTokensContractFunction.factory(
            "rescueTokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rescueTokens",
        )
        self.resetIsolationModeTotalDebt = (
            MockL2PoolResetIsolationModeTotalDebtContractFunction.factory(
                "resetIsolationModeTotalDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="resetIsolationModeTotalDebt",
            )
        )
        self.setConfiguration = (
            MockL2PoolSetConfigurationContractFunction.factory(
                "setConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setConfiguration",
            )
        )
        self.setLiquidationGracePeriod = (
            MockL2PoolSetLiquidationGracePeriodContractFunction.factory(
                "setLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setLiquidationGracePeriod",
            )
        )
        self.setReserveInterestRateStrategyAddress = MockL2PoolSetReserveInterestRateStrategyAddressContractFunction.factory(
            "setReserveInterestRateStrategyAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setReserveInterestRateStrategyAddress",
        )
        self.setUserEMode = MockL2PoolSetUserEModeContractFunction.factory(
            "setUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserEMode",
        )
        self.setUserUseReserveAsCollateral = (
            MockL2PoolSetUserUseReserveAsCollateralContractFunction.factory(
                "setUserUseReserveAsCollateral",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUserUseReserveAsCollateral",
            )
        )
        self.supply = MockL2PoolSupplyContractFunction.factory(
            "supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supply",
        )
        self.supplyWithPermit = (
            MockL2PoolSupplyWithPermitContractFunction.factory(
                "supplyWithPermit",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="supplyWithPermit",
            )
        )
        self.swapBorrowRateMode = (
            MockL2PoolSwapBorrowRateModeContractFunction.factory(
                "swapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="swapBorrowRateMode",
            )
        )
        self.swapToVariable = MockL2PoolSwapToVariableContractFunction.factory(
            "swapToVariable",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="swapToVariable",
        )
        self.syncIndexesState = (
            MockL2PoolSyncIndexesStateContractFunction.factory(
                "syncIndexesState",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="syncIndexesState",
            )
        )
        self.syncRatesState = MockL2PoolSyncRatesStateContractFunction.factory(
            "syncRatesState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="syncRatesState",
        )
        self.updateBridgeProtocolFee = (
            MockL2PoolUpdateBridgeProtocolFeeContractFunction.factory(
                "updateBridgeProtocolFee",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateBridgeProtocolFee",
            )
        )
        self.updateFlashloanPremiums = (
            MockL2PoolUpdateFlashloanPremiumsContractFunction.factory(
                "updateFlashloanPremiums",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateFlashloanPremiums",
            )
        )
        self.withdraw = MockL2PoolWithdrawContractFunction.factory(
            "withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="withdraw",
        )


class MockL2PoolBackUnbackedContractEvent(ContractEvent):
    """ContractEvent for BackUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolBorrowContractEvent(ContractEvent):
    """ContractEvent for Borrow."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BorrowEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BorrowEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolFlashLoanContractEvent(ContractEvent):
    """ContractEvent for FlashLoan."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolIsolationModeTotalDebtUpdatedContractEvent(ContractEvent):
    """ContractEvent for IsolationModeTotalDebtUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolLiquidationCallContractEvent(ContractEvent):
    """ContractEvent for LiquidationCall."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolMintUnbackedContractEvent(ContractEvent):
    """ContractEvent for MintUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolMintedToTreasuryContractEvent(ContractEvent):
    """ContractEvent for MintedToTreasury."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolRebalanceStableBorrowRateContractEvent(ContractEvent):
    """ContractEvent for RebalanceStableBorrowRate."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolRepayContractEvent(ContractEvent):
    """ContractEvent for Repay."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RepayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RepayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolReserveDataUpdatedContractEvent(ContractEvent):
    """ContractEvent for ReserveDataUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolReserveUsedAsCollateralDisabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralDisabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolReserveUsedAsCollateralEnabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralEnabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolSupplyContractEvent(ContractEvent):
    """ContractEvent for Supply."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SupplyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SupplyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolSwapBorrowRateModeContractEvent(ContractEvent):
    """ContractEvent for SwapBorrowRateMode."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolUserEModeSetContractEvent(ContractEvent):
    """ContractEvent for UserEModeSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolWithdrawContractEvent(ContractEvent):
    """ContractEvent for Withdraw."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[WithdrawEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[WithdrawEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockL2PoolContractEvents(ContractEvents):
    """ContractEvents for the MockL2Pool contract."""

    BackUnbacked: Type[MockL2PoolBackUnbackedContractEvent]

    Borrow: Type[MockL2PoolBorrowContractEvent]

    FlashLoan: Type[MockL2PoolFlashLoanContractEvent]

    IsolationModeTotalDebtUpdated: Type[
        MockL2PoolIsolationModeTotalDebtUpdatedContractEvent
    ]

    LiquidationCall: Type[MockL2PoolLiquidationCallContractEvent]

    MintUnbacked: Type[MockL2PoolMintUnbackedContractEvent]

    MintedToTreasury: Type[MockL2PoolMintedToTreasuryContractEvent]

    RebalanceStableBorrowRate: Type[
        MockL2PoolRebalanceStableBorrowRateContractEvent
    ]

    Repay: Type[MockL2PoolRepayContractEvent]

    ReserveDataUpdated: Type[MockL2PoolReserveDataUpdatedContractEvent]

    ReserveUsedAsCollateralDisabled: Type[
        MockL2PoolReserveUsedAsCollateralDisabledContractEvent
    ]

    ReserveUsedAsCollateralEnabled: Type[
        MockL2PoolReserveUsedAsCollateralEnabledContractEvent
    ]

    Supply: Type[MockL2PoolSupplyContractEvent]

    SwapBorrowRateMode: Type[MockL2PoolSwapBorrowRateModeContractEvent]

    UserEModeSet: Type[MockL2PoolUserEModeSetContractEvent]

    Withdraw: Type[MockL2PoolWithdrawContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.BackUnbacked = cast(
            Type[MockL2PoolBackUnbackedContractEvent],
            MockL2PoolBackUnbackedContractEvent.factory(
                "BackUnbacked",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="BackUnbacked",
            ),
        )
        self.Borrow = cast(
            Type[MockL2PoolBorrowContractEvent],
            MockL2PoolBorrowContractEvent.factory(
                "Borrow",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Borrow",
            ),
        )
        self.FlashLoan = cast(
            Type[MockL2PoolFlashLoanContractEvent],
            MockL2PoolFlashLoanContractEvent.factory(
                "FlashLoan",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="FlashLoan",
            ),
        )
        self.IsolationModeTotalDebtUpdated = cast(
            Type[MockL2PoolIsolationModeTotalDebtUpdatedContractEvent],
            MockL2PoolIsolationModeTotalDebtUpdatedContractEvent.factory(
                "IsolationModeTotalDebtUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="IsolationModeTotalDebtUpdated",
            ),
        )
        self.LiquidationCall = cast(
            Type[MockL2PoolLiquidationCallContractEvent],
            MockL2PoolLiquidationCallContractEvent.factory(
                "LiquidationCall",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="LiquidationCall",
            ),
        )
        self.MintUnbacked = cast(
            Type[MockL2PoolMintUnbackedContractEvent],
            MockL2PoolMintUnbackedContractEvent.factory(
                "MintUnbacked",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MintUnbacked",
            ),
        )
        self.MintedToTreasury = cast(
            Type[MockL2PoolMintedToTreasuryContractEvent],
            MockL2PoolMintedToTreasuryContractEvent.factory(
                "MintedToTreasury",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MintedToTreasury",
            ),
        )
        self.RebalanceStableBorrowRate = cast(
            Type[MockL2PoolRebalanceStableBorrowRateContractEvent],
            MockL2PoolRebalanceStableBorrowRateContractEvent.factory(
                "RebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RebalanceStableBorrowRate",
            ),
        )
        self.Repay = cast(
            Type[MockL2PoolRepayContractEvent],
            MockL2PoolRepayContractEvent.factory(
                "Repay",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Repay",
            ),
        )
        self.ReserveDataUpdated = cast(
            Type[MockL2PoolReserveDataUpdatedContractEvent],
            MockL2PoolReserveDataUpdatedContractEvent.factory(
                "ReserveDataUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveDataUpdated",
            ),
        )
        self.ReserveUsedAsCollateralDisabled = cast(
            Type[MockL2PoolReserveUsedAsCollateralDisabledContractEvent],
            MockL2PoolReserveUsedAsCollateralDisabledContractEvent.factory(
                "ReserveUsedAsCollateralDisabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralDisabled",
            ),
        )
        self.ReserveUsedAsCollateralEnabled = cast(
            Type[MockL2PoolReserveUsedAsCollateralEnabledContractEvent],
            MockL2PoolReserveUsedAsCollateralEnabledContractEvent.factory(
                "ReserveUsedAsCollateralEnabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralEnabled",
            ),
        )
        self.Supply = cast(
            Type[MockL2PoolSupplyContractEvent],
            MockL2PoolSupplyContractEvent.factory(
                "Supply",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Supply",
            ),
        )
        self.SwapBorrowRateMode = cast(
            Type[MockL2PoolSwapBorrowRateModeContractEvent],
            MockL2PoolSwapBorrowRateModeContractEvent.factory(
                "SwapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="SwapBorrowRateMode",
            ),
        )
        self.UserEModeSet = cast(
            Type[MockL2PoolUserEModeSetContractEvent],
            MockL2PoolUserEModeSetContractEvent.factory(
                "UserEModeSet",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="UserEModeSet",
            ),
        )
        self.Withdraw = cast(
            Type[MockL2PoolWithdrawContractEvent],
            MockL2PoolWithdrawContractEvent.factory(
                "Withdraw",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Withdraw",
            ),
        )


class MockL2PoolContract(Contract):
    """A web3.py Contract class for the MockL2Pool contract."""

    abi: ABI = mockl2pool_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x60a0604052600080553480156200001557600080fd5b5060405162005e0d38038062005e0d83398101604081905262000038916200004a565b6001600160a01b03166080526200007c565b6000602082840312156200005d57600080fd5b81516001600160a01b03811681146200007557600080fd5b9392505050565b608051615d1a620000f36000396000818161044e01528181610d4901528181610e080152818161123f015281816119c201528181611c87015281816122fb015281816123a6015281816125df0152818161293a01528181612e5a015281816133780152818161356a0152613c690152615d1a6000f3fe608060405234801561001057600080fd5b506004361061041c5760003560e01c8063870e77441161022b578063d1946dbc11610130578063e82fec2f116100b8578063f32b9a7311610087578063f32b9a7314610c62578063f51e435b14610c7c578063f7a7384014610c8f578063f8119d5114610ca2578063fd21ecff14610cb157600080fd5b8063e82fec2f14610c12578063e8eda9df146106dd578063eddf1b7914610c23578063ee3e210b14610c4f57600080fd5b8063d5eed868116100ff578063d5eed86814610bac578063d65dc7a114610bbf578063dc7c0bff14610bd2578063df374c3614610be5578063e43e88a114610bff57600080fd5b8063d1946dbc14610b57578063d335015514610b6c578063d579ea7d14610b86578063d5ed393314610b9957600080fd5b8063ab9c4b5d116101b3578063c44b11f711610182578063c44b11f714610acb578063c4d66de814610b0d578063cd11238214610b1e578063cea9d26f14610b31578063d15e005314610b4457600080fd5b8063ab9c4b5d14610a52578063b1a99e2614610a65578063bcb6e52214610a78578063bf92857c14610a8b57600080fd5b806394ba89a2116101fa57806394ba89a2146109f357806398c7da4e14610a065780639cd1999614610a19578063a415bcad14610a2c578063ab2b51f614610a3f57600080fd5b8063870e7744146109995780638e19899e146109b3578063911a3413146109c657806394b576de146109e057600080fd5b80634417a58311610331578063680dd47c116102b95780636c6f6ae1116102885780636c6f6ae1146107545780636fb07f961461077457806372218d04146107b05780637a708e92146107c35780638381995f146107d657600080fd5b8063680dd47c1461070357806369328dec1461071657806369a933a5146107295780636a99c0361461073c57600080fd5b8063573ade8111610300578063573ade81146106675780635a3b74b91461067a5780635c9a8b181461068d578063617ba037146106dd57806363c9b860146106f057600080fd5b80634417a583146105c35780634d013f03146106145780635275179714610627578063563dd6131461065457600080fd5b806328530a47116103b4578063348fde0f11610383578063348fde0f1461055057806335ea6a751461056a578063386497fd1461058a578063427da1771461059d57806342b0b77c146105b057600080fd5b806328530a47146104fd5780632be29fa7146105105780632dad97d41461052a5780633036b4391461053d57600080fd5b80631d2118f9116103f05780631d2118f9146104b25780631fe3c6f3146104c55780632520d5ee146104d8578063272d9072146104eb57600080fd5b8062a718a91461042157806302c205f0146104365780630542975c14610449578063074b2e431461048d575b600080fd5b61043461042f3660046144df565b610cc4565b005b61043461044436600461456a565b610ed8565b6104707f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b603a546001600160801b03165b6040516001600160801b039091168152602001610484565b6104346104c03660046145e9565b610ff1565b6104346104d3366004614622565b611117565b6104346104e63660046145e9565b611138565b6039545b604051908152602001610484565b61043461050b36600461463b565b6111d1565b73__$5f76d850ac254f0697945c46b13dedf9fb$__610470565b6104ef610538366004614656565b61136f565b61043461054b366004614622565b611474565b73__$8adee7547342d537bcdcaeb7c748cfa5c0$__610470565b61057d61057836600461468b565b611481565b60405161048491906146a8565b6104ef61059836600461468b565b61168e565b6104346105ab366004614622565b6116b5565b6104346105be366004614828565b6116e5565b6106056105d136600461468b565b60408051602080820183526000918290526001600160a01b0393909316815260358352819020815192830190915254815290565b60405190518152602001610484565b610434610622366004614622565b611809565b6104706106353660046148a9565b61ffff166000908152603660205260409020546001600160a01b031690565b6104ef610662366004614622565b611838565b6104ef6106753660046148c4565b611864565b61043461068836600461490e565b611968565b6106c761069b36600461468b565b6001600160a01b0316600090815260346020526040902060030154600160b81b900464ffffffffff1690565b60405164ffffffffff9091168152602001610484565b6104346106eb36600461493c565b611ac1565b6104346106fe36600461468b565b611b72565b61043461071136600461498d565b611bc8565b6104ef6107243660046149b9565b611bf5565b61043461073736600461493c565b611dae565b603a54600160801b90046001600160801b031661049a565b61076761076236600461463b565b611e35565b6040516104849190614a41565b61049a61078236600461468b565b6001600160a01b0316600090815260346020526040902060090154600160801b90046001600160801b031690565b603b54600160401b900461ffff166104ef565b6104346107d1366004614a96565b611f62565b61098c6107e436600461468b565b604080516102408101825260006102208201818152825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c081018290526101e08101829052610200810191909152506001600160a01b0390811660009081526034602090815260409182902082516102408101845281546102208201908152815260018201546001600160801b0380821694830194909452600160801b908190048416948201949094526002820154808416606083015284900483166080820152600382015480841660a083015264ffffffffff858204811660c084015261ffff600160a81b83041660e0840152600160b81b90910416610100820152600482015485166101208201526005820154851661014082015260068201548516610160820152600782015490941661018085015260088101548083166101a086015283900482166101c0850152600901548082166101e0850152919091041661020082015290565b6040516104849190614af9565b73__$283efb0a967bb30ce182c750a4aff98297$__610470565b6104ef6109c1366004614622565b6120a8565b73__$589bdd19231b917beb0692fb1391cc382d$__610470565b6104ef6109ee36600461498d565b6120cf565b610434610a01366004614c53565b61210a565b610434610a1436600461468b565b612183565b610434610a27366004614cc3565b6121bd565b610434610a3a366004614d04565b6121f9565b610434610a4d36600461468b565b61243f565b610434610a60366004614d43565b612475565b610434610a73366004614e4f565b61278d565b610434610a86366004614e94565b61288c565b610a9e610a9936600461468b565b6128ad565b604080519687526020870195909552938501929092526060840152608083015260a082015260c001610484565b610605610ad936600461468b565b60408051602080820183526000918290526001600160a01b0393909316815260348352819020815192830190915254815290565b610434610b1b36600461468b565b50565b610434610b2c3660046145e9565b612a8c565b610434610b3f366004614ec7565b612aef565b6104ef610b5236600461468b565b612b76565b610b5f612b97565b6040516104849190614f08565b73__$eb5517a650f544fa14961d696410147857$__610470565b610434610b94366004614fc3565b612c8f565b610434610ba73660046150dc565b612d74565b610434610bba366004614622565b612f60565b6104ef610bcd366004614656565b612fc1565b6104ef610be0366004614622565b61303b565b73__$3176f8b4007c03a59557e1c69343378539$__610470565b610434610c0d36600461468b565b61305d565b603b546001600160401b03166104ef565b6104ef610c3136600461468b565b6001600160a01b031660009081526038602052604090205460ff1690565b6104ef610c5d366004615141565b6130ac565b73__$65f2e84d14e08abb971fea4350599006ac$__610470565b610434610c8a366004615187565b61320e565b610434610c9d366004614622565b61331f565b60405160808152602001610484565b610434610cbf3660046151c8565b613341565b73__$589bdd19231b917beb0692fb1391cc382d$__6383c1087d6034603660356037604051806101200160405280603b60089054906101000a900461ffff1661ffff1681526020018981526020018c6001600160a01b031681526020018b6001600160a01b031681526020018a6001600160a01b0316815260200188151581526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610da5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc991906151ea565b6001600160a01b0390811682528b81166000908152603860209081526040918290205460ff16818501528151635eb88d3d60e01b8152825192909401937f000000000000000000000000000000000000000000000000000000000000000090931692635eb88d3d92600480830193928290030181865afa158015610e51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e7591906151ea565b6001600160a01b03168152506040518663ffffffff1660e01b8152600401610ea1959493929190615207565b60006040518083038186803b158015610eb957600080fd5b505af4158015610ecd573d6000803e3d6000fd5b505050505050505050565b60405163d505accf60e01b81526001600160a01b0389169063d505accf90610f1090339030908c908a908a908a908a906004016152c0565b600060405180830381600087803b158015610f2a57600080fd5b505af1925050508015610f3b575060015b506001600160a01b038087166000818152603560209081526040918290208251608081018452948d1685529084018b90528382019290925261ffff8816606084015251631913f16160e01b815273__$283efb0a967bb30ce182c750a4aff98297$__92631913f16192610fb79260349260369291600401615301565b60006040518083038186803b158015610fcf57600080fd5b505af4158015610fe3573d6000803e3d6000fd5b505050505050505050505050565b610ff961336c565b604080518082019091526002815261373760f01b60208201526001600160a01b0383166110425760405162461bcd60e51b81526004016110399190615352565b60405180910390fd5b506001600160a01b038216600090815260346020526040902060030154600160a81b900461ffff161515806110ac57506000805260366020527f4cb2b152c1b54ce671907a93c300fd5aa72383a9d4ec19a81e3333632ae92e00546001600160a01b038381169116145b604051806040016040528060028152602001611c1960f11b815250906110e55760405162461bcd60e51b81526004016110399190615352565b506001600160a01b03918216600090815260346020526040902060070180546001600160a01b03191691909216179055565b60008061112560368461343b565b91509150611133828261210a565b505050565b6001600160a01b03808316600090815260346020908152604080832093851683526035909152908190209051631210e32760e11b815273__$5f76d850ac254f0697945c46b13dedf9fb$__92632421c64e9261119d928790879060019060040161539d565b60006040518083038186803b1580156111b557600080fd5b505af41580156111c9573d6000803e3d6000fd5b505050505050565b73__$65f2e84d14e08abb971fea4350599006ac$__635d5dc313603460366037603860356000336001600160a01b03166001600160a01b031681526020019081526020016000206040518060600160405280603b60089054906101000a900461ffff1661ffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa15801561129b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bf91906151ea565b6001600160a01b031681526020018960ff168152506040518763ffffffff1660e01b815260040161133c9695949392919095865260208087019590955260408087019490945260608601929092526080850152805160a0850152918201516001600160a01b031660c0840152015160ff1660e08201526101000190565b60006040518083038186803b15801561135457600080fd5b505af4158015611368573d6000803e3d6000fd5b5050505050565b600073__$5f76d850ac254f0697945c46b13dedf9fb$__6340e95de66034603660356000336001600160a01b03166001600160a01b031681526020019081526020016000206040518060a001604052808a6001600160a01b031681526020018981526020018860028111156113e6576113e6615365565b60028111156113f7576113f7615365565b81523360208201526001604091820152516001600160e01b031960e087901b16815261142994939291906004016153d9565b602060405180830381865af4158015611446573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061146a919061543f565b90505b9392505050565b61147c61336c565b603955565b61148961437c565b6001600160a01b0380831660009081526034602090815260409182902082516102408101845281546102208201908152815260018201546001600160801b0380821694830194909452600160801b908190048416948201949094526002820154808416606083015284900483166080820152600382015480841660a083015264ffffffffff858204811660c084015261ffff600160a81b83041660e0840152600160b81b90910416610100820152600482015485166101208201526005820154851661014082015260068201548516610160820152600782015490941661018085015260088101548083166101a086015283900482166101c0850152600901548082166101e085015291909104166102008201526115a561437c565b815181526020808301516001600160801b039081169183019190915260408084015182169083015260608084015182169083015260808084015182169083015260a08084015182169083015260c08084015164ffffffffff169083015260e08084015161ffff1690830152610120808401516001600160a01b03908116610100850152610140808601518216928501929092526101608086015182169285019290925261018080860151909116918401919091526101a0808501518316918401919091526101c0808501518316918401919091526101e090930151169181019190915292915050565b6001600160a01b03811660009081526034602052604081206116af90613468565b92915050565b61ffff81166000908152603660205260409020546001600160a01b0390811690601083901c166111338282612a8c565b60006040518060e00160405280886001600160a01b03168152602001876001600160a01b0316815260200186815260200185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093855250505061ffff8516602080840191909152603a546001600160801b03600160801b8204811660408087019190915291166060909401939093526001600160a01b038a16825260349052819020905163a1fe0e8d60e01b815291925073__$8adee7547342d537bcdcaeb7c748cfa5c0$__9163a1fe0e8d916117d0918590600401615458565b60006040518083038186803b1580156117e857600080fd5b505af41580156117fc573d6000803e3d6000fd5b5050505050505050505050565b61ffff81166000908152603660205260409020546001600160a01b0316601082901c6001166111338282611968565b6000806000806118496036866134cb565b92509250925061185b83838333611864565b95945050505050565b600073__$5f76d850ac254f0697945c46b13dedf9fb$__6340e95de66034603660356000876001600160a01b03166001600160a01b031681526020019081526020016000206040518060a001604052808b6001600160a01b031681526020018a81526020018960028111156118db576118db615365565b60028111156118ec576118ec615365565b81526001600160a01b03891660208201526000604091820152516001600160e01b031960e087901b16815261192794939291906004016153d9565b602060405180830381865af4158015611944573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061185b919061543f565b73__$283efb0a967bb30ce182c750a4aff98297$__63bf697a2660346036603760356000336001600160a01b03166001600160a01b031681526020019081526020016000208787603b60089054906101000a900461ffff167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a1e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4291906151ea565b336000908152603860205260409081902054905160e08b901b6001600160e01b031916815260048101999099526024890197909752604488019590955260648701939093526001600160a01b039182166084870152151560a486015261ffff90911660c48501521660e483015260ff166101048201526101240161119d565b6001600160a01b03808316600081815260356020908152604091829020825160808101845294891685529084018790528382019290925261ffff8416606084015251631913f16160e01b815273__$283efb0a967bb30ce182c750a4aff98297$__92631913f16192611b3c9260349260369291600401615301565b60006040518083038186803b158015611b5457600080fd5b505af4158015611b68573d6000803e3d6000fd5b5050505050505050565b611b7a61336c565b604051639cf5702360e01b815260346004820152603660248201526001600160a01b038216604482015273__$eb5517a650f544fa14961d696410147857$__90639cf570239060640161133c565b6000806000806000611bdb60368961352a565b94509450945094509450611b688585338686868d8d610ed8565b600073__$283efb0a967bb30ce182c750a4aff98297$__63186dea4460346036603760356000336001600160a01b03166001600160a01b031681526020019081526020016000206040518060c001604052808b6001600160a01b031681526020018a8152602001896001600160a01b03168152602001603b60089054906101000a900461ffff1661ffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ce3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d0791906151ea565b6001600160a01b039081168252336000908152603860209081526040918290205460ff90811694820194909452815160e08b901b6001600160e01b031916815260048101999099526024890197909752604488019590955260648701939093528151831660848701529381015160a486015291820151811660c4850152606082015160e485015260808201511661010484015260a001511661012482015261014401611429565b611db6613568565b6001600160a01b03828116600081815260356020526040908190209051630413c86f60e01b81526034600482015260366024820152604481019190915291861660648301526084820185905260a482015261ffff821660c482015273__$3176f8b4007c03a59557e1c69343378539$__90630413c86f9060e401611b3c565b6040805160a081018252600080825260208201819052918101829052606080820192909252608081019190915260ff8216600090815260376020908152604091829020825160a081018452815461ffff808216835262010000820481169483019490945264010000000081049093169381019390935266010000000000009091046001600160a01b03166060830152600181018054608084019190611ed9906154d5565b80601f0160208091040260200160405190810160405280929190818152602001828054611f05906154d5565b8015611f525780601f10611f2757610100808354040283529160200191611f52565b820191906000526020600020905b815481529060010190602001808311611f3557829003601f168201915b5050505050815250509050919050565b611f6a61336c565b73__$eb5517a650f544fa14961d696410147857$__6369fc1bdf603460366040518060e001604052808a6001600160a01b03168152602001896001600160a01b03168152602001886001600160a01b03168152602001876001600160a01b03168152602001866001600160a01b03168152602001603b60089054906101000a900461ffff1661ffff168152602001612000608090565b61ffff168152506040518463ffffffff1660e01b815260040161202593929190615509565b602060405180830381865af4158015612042573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612066919061558b565b1561136857603b8054600160401b900461ffff16906008612086836155be565b91906101000a81548161ffff021916908361ffff160217905550505050505050565b60008060006120b860368561368c565b915091506120c7828233611bf5565b949350505050565b6000806000806000806120e360368a6136de565b945094509450945094506120fd8585853386868e8e6130ac565b9998505050505050505050565b6001600160a01b0382166000908152603460209081526040808320338085526035909352922073__$5f76d850ac254f0697945c46b13dedf9fb$__92632421c64e92909190869086600281111561216357612163615365565b6040518663ffffffff1660e01b815260040161119d95949392919061539d565b61218b61336c565b6001600160a01b0381166000908152603460205260408120906121ad8261371e565b90506111338282856000806138ee565b604051631230b2a360e21b815273__$eb5517a650f544fa14961d696410147857$__906348c2ca8c9061119d90603490869086906004016155df565b73__$5f76d850ac254f0697945c46b13dedf9fb$__631e6473f960346036603760356000876001600160a01b03166001600160a01b031681526020019081526020016000206040518061018001604052808c6001600160a01b03168152602001336001600160a01b03168152602001886001600160a01b031681526020018b81526020018a600281111561228f5761228f615365565b60028111156122a0576122a0615365565b815261ffff808b166020808401919091526001604080850191909152603b546001600160401b0381166060860152600160401b900490921660808401528151631f94a27560e31b8152915160a0909301926001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169263fca513a89260048083019391928290030181865afa158015612343573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061236791906151ea565b6001600160a01b0390811682528981166000908152603860209081526040918290205460ff16818501528151635eb88d3d60e01b8152825192909401937f000000000000000000000000000000000000000000000000000000000000000090931692635eb88d3d92600480830193928290030181865afa1580156123ef573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061241391906151ea565b6001600160a01b03168152506040518663ffffffff1660e01b8152600401610ea1959493929190615637565b61244761336c565b6001600160a01b0381166000908152603460205260408120906124698261371e565b90506111338282613c0f565b6000604051806101e001604052808d6001600160a01b031681526020018c8c808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152505050908252506040805160208c810282810182019093528c82529283019290918d918d9182918501908490808284376000920191909152505050908252506040805160208a810282810182019093528a82529283019290918b918b9182918501908490808284376000920191909152505050908252506001600160a01b03871660208083019190915260408051601f88018390048302810183018252878152920191908790879081908401838280828437600092018290525093855250505061ffff808616602080850191909152603a546001600160801b03600160801b8204811660408088019190915291166060860152603b546001600160401b0381166080870152600160401b900490921660a08501526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660c086018190523060e0870152908b16845260388252928290205460ff16610100850152815163383e6b8b60e11b815291516101209094019363707cd7169260048082019392918290030181865afa158015612660573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061268491906151ea565b60405163fa50f29760e01b81523360048201526001600160a01b03919091169063fa50f29790602401602060405180830381865afa1580156126ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126ee919061558b565b151590526001600160a01b03861660009081526035602052604090819020905163173931f560e11b815291925073__$8adee7547342d537bcdcaeb7c748cfa5c0$__91632e7263ea9161274f916034916036916037919088906004016157a1565b60006040518083038186803b15801561276757600080fd5b505af415801561277b573d6000803e3d6000fd5b50505050505050505050505050505050565b61279561336c565b6001600160a01b038216600090815260346020526040902060030154600160a81b900461ffff161515806127fe57506000805260366020527f4cb2b152c1b54ce671907a93c300fd5aa72383a9d4ec19a81e3333632ae92e00546001600160a01b038381169116145b604051806040016040528060028152602001611c1960f11b815250906128375760405162461bcd60e51b81526004016110399190615352565b50604051636ae4381360e01b8152603460048201526001600160a01b038316602482015264ffffffffff8216604482015273__$eb5517a650f544fa14961d696410147857$__90636ae438139060640161119d565b61289461336c565b6001600160801b03908116600160801b02911617603a55565b604080516001600160a01b0383811660008181526035602090815285822060c0860187525460a086019081528552603b54600160401b900461ffff1681860152848601929092528451631f94a27560e31b8152945190948594859485948594859473__$eb5517a650f544fa14961d696410147857$__946326ec273f9460349460369460379460608501937f0000000000000000000000000000000000000000000000000000000000000000169263fca513a8926004808401938290030181865afa158015612980573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129a491906151ea565b6001600160a01b0390811682528e81166000908152603860209081526040918290205460ff90811694820194909452815160e08a901b6001600160e01b0319168152600481019890985260248801969096526044870194909452825151606487015293820151608486015291810151831660a4850152606081015190921660c48401526080909101511660e48201526101040160c060405180830381865af4158015612a54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a78919061591a565b949c939b5091995097509550909350915050565b6001600160a01b03828116600081815260346020526040908190209051631a5cfdd160e21b815260048101919091526024810191909152908216604482015273__$5f76d850ac254f0697945c46b13dedf9fb$__90636973f7449060640161119d565b612af7613c67565b6040516343d9915960e11b81526001600160a01b038085166004830152831660248201526044810182905273__$eb5517a650f544fa14961d696410147857$__906387b322b29060640160006040518083038186803b158015612b5957600080fd5b505af4158015612b6d573d6000803e3d6000fd5b50505050505050565b6001600160a01b03811660009081526034602052604081206116af90613d8b565b603b54606090600160401b900461ffff16600080826001600160401b03811115612bc357612bc3614f55565b604051908082528060200260200182016040528015612bec578160200160208202803683370190505b50905060005b83811015612c85576000818152603660205260409020546001600160a01b031615612c6f576000818152603660205260409020546001600160a01b031682612c3a8584615964565b81518110612c4a57612c4a615977565b60200260200101906001600160a01b031690816001600160a01b031681525050612c7d565b82612c798161598d565b9350505b600101612bf2565b5091038152919050565b612c9761336c565b604080518082019091526002815261189b60f11b602082015260ff8316612cd15760405162461bcd60e51b81526004016110399190615352565b5060ff821660009081526037602090815260409182902083518154928501519385015160608601516001600160a01b03166601000000000000026601000000000000600160d01b031961ffff9283166401000000000216640100000000600160d01b0319968316620100000263ffffffff1990961692909316919091179390931793909316929092171781556080820151829190600182019061136890826159ee565b6001600160a01b038681166000908152603460209081526040918290206004015482518084019093526002835261313160f01b918301919091529091163314612dd05760405162461bcd60e51b81526004016110399190615352565b5073__$283efb0a967bb30ce182c750a4aff98297$__638a5dadd160346036603760356040518061012001604052808d6001600160a01b031681526020018c6001600160a01b031681526020018b6001600160a01b031681526020018a8152602001898152602001888152602001603b60089054906101000a900461ffff1661ffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015612eb6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612eda91906151ea565b6001600160a01b0390811682528d166000908152603860209081526040918290205460ff16920191909152516001600160e01b031960e088901b168152612f28959493929190600401615aad565b60006040518083038186803b158015612f4057600080fd5b505af4158015612f54573d6000803e3d6000fd5b50505050505050505050565b600080600080612fac60368661ffff81811660009081526020939093526040909220546001600160a01b0316926001600160801b03601083901c169260ff609084901c169260981c1690565b935093509350935061136884848484336121f9565b6000612fcb613568565b6001600160a01b0384166000818152603460205260409081902060395491516311ce864960e31b8152600481019190915260248101929092526044820185905260648201849052608482015273__$3176f8b4007c03a59557e1c69343378539$__90638e7432489060a401611429565b60008060008061304c6036866134cb565b92509250925061185b83838361136f565b61306561336c565b604051631e3b414560e01b8152603460048201526001600160a01b038216602482015273__$eb5517a650f544fa14961d696410147857$__90631e3b41459060440161133c565b60405163d505accf60e01b81526000906001600160a01b038a169063d505accf906130e790339030908d908b908b908b908b906004016152c0565b600060405180830381600087803b15801561310157600080fd5b505af1925050508015613112575060015b5060006040518060a001604052808b6001600160a01b031681526020018a815260200189600281111561314757613147615365565b600281111561315857613158615365565b81526001600160a01b038916602080830182905260006040938401819052918252603590528190209051632074aef360e11b815291925073__$5f76d850ac254f0697945c46b13dedf9fb$__916340e95de6916131bf9160349160369187906004016153d9565b602060405180830381865af41580156131dc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613200919061543f565b9a9950505050505050505050565b61321661336c565b604080518082019091526002815261373760f01b60208201526001600160a01b0383166132565760405162461bcd60e51b81526004016110399190615352565b506001600160a01b038216600090815260346020526040902060030154600160a81b900461ffff161515806132c057506000805260366020527f4cb2b152c1b54ce671907a93c300fd5aa72383a9d4ec19a81e3333632ae92e00546001600160a01b038381169116145b604051806040016040528060028152602001611c1960f11b815250906132f95760405162461bcd60e51b81526004016110399190615352565b506001600160a01b03821660009081526034602052604090208135815581905b50505050565b600080600061332f603685613de2565b92509250925061331983833384611ac1565b600080600080600061335560368888613e1d565b94509450945094509450612b6d8585858585610cc4565b336001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663631adfca6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133f891906151ea565b6001600160a01b03161460405180604001604052806002815260200161031360f41b81525090610b1b5760405162461bcd60e51b81526004016110399190615352565b61ffff81166000908152602083905260409020546001600160a01b0316601082901c60ff165b9250929050565b6003810154600090600160801b900464ffffffffff16428103613497575050600201546001600160801b031690565b600283015461146d906001600160801b03808216916134bf91600160801b9091041684613ea5565b90613eb2565b50919050565b6000808061ffff8416601085901c6001600160801b0316609086901c60ff166002600160801b031982016134ff5760001991505b61ffff9092166000908152602088905260409020546001600160a01b03169450925090509250925092565b60008080808060a086901c63ffffffff1660c087901c60ff168280806135508c8c613de2565b919e909d50909b509499509297509295505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663707cd7166040518163ffffffff1660e01b8152600401602060405180830381865afa1580156135c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135ea91906151ea565b604051633933006760e11b81523360048201526001600160a01b03919091169063726600ce90602401602060405180830381865afa158015613630573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613654919061558b565b604051806040016040528060018152602001601b60f91b81525090610b1b5760405162461bcd60e51b81526004016110399190615352565b60008061ffff8316601084901c6001600160801b03166002600160801b031981016136b657506000195b61ffff9190911660009081526020959095526040909420546001600160a01b03169492505050565b6000806000806000806000806000806136f78c8c6134cb565b919e909d50909b609881901c63ffffffff169b5060b81c60ff169950975050505050505050565b6137266143ff565b61372e6143ff565b60408051602081018252845481526101c0830181905251901c61ffff166101a082015260018301546001600160801b03808216610100840181905260e084015260028501548082166101408501819052610120850152600160801b928390048216610160850152829004166101808301526004808501546001600160a01b039081166101e085015260058601548116610200850152600686015416610220840181905260038601549290920464ffffffffff166102408401526040805163b1bf962d60e01b8152905163b1bf962d928281019260209291908290030181865afa15801561381f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613843919061543f565b81602001818152508160000181815250508061020001516001600160a01b031663797743386040518163ffffffff1660e01b8152600401608060405180830381865afa158015613897573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138bb9190615b54565b64ffffffffff166102608501526060840181905260808401829052604084019290925260c083015260a082015292915050565b6139196040518060800160405280600081526020016000815260200160008152602001600081525090565b610140850151602086015161392d91613eb2565b60608281019182526007880154604080516101408101825260088b01546001600160801b03600160801b918290048116835260208084018b90528385018a905260c08d810151978501979097529651608084015260a0808d0151908401526101a08c0151958301959095526001600160a01b038a811660e0840152835196870184528c5496879052600160fc1b909616151561010083015260098c01540490931661012084015251637b424dcf60e11b815292169163f6849b9e916139f491600401615b8a565b606060405180830381865afa158015613a11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a359190615c0d565b60408401526020830152808252613a4b90613ef6565b6001870180546001600160801b03928316600160801b0292169190911790556020810151613a7890613ef6565b6003870180546001600160801b0319166001600160801b03929092169190911790556040810151613aa890613ef6565b6002870180546001600160801b03928316600160801b029216919091179055604080516020810190915286548152613ae69051600160fc1b16151590565b15613b9b578215613b4357613afa83613ef6565b600987018054601090613b1e908490600160801b90046001600160801b0316615c3b565b92506101000a8154816001600160801b0302191690836001600160801b031602179055505b8115613b9b57613b5282613ef6565b600987018054601090613b76908490600160801b90046001600160801b0316615c62565b92506101000a8154816001600160801b0302191690836001600160801b031602179055505b80516020808301516040808501516101008a01516101408b015183519687529486019390935290840152606083015260808201526001600160a01b038516907f804c9b842b2748a22bb64b345453a3de7ca54a6ca45ce00d415894979e22897a9060a00160405180910390a2505050505050565b600382015464ffffffffff428116600160801b9092041603613c2f575050565b613c398282613f63565b613c438282614042565b50600301805464ffffffffff60801b1916600160801b4264ffffffffff1602179055565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663707cd7166040518163ffffffff1660e01b8152600401602060405180830381865afa158015613cc5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ce991906151ea565b604051637be53ca160e01b81523360048201526001600160a01b039190911690637be53ca190602401602060405180830381865afa158015613d2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d53919061558b565b604051806040016040528060018152602001603160f81b81525090610b1b5760405162461bcd60e51b81526004016110399190615352565b6003810154600090600160801b900464ffffffffff16428103613dba575050600101546001600160801b031690565b600183015461146d906001600160801b03808216916134bf91600160801b90910416846141ae565b61ffff8181166000908152602084905260409020546001600160a01b031690601083901c6001600160801b031690609084901c169250925092565b60008080808061ffff87811690601089901c16602089901c6001600160a01b03166001600160801b03891660808a901c6001166002600160801b03198201613e655760001991505b61ffff948516600090815260209d909d526040808e2054949095168d5293909b20546001600160a01b039283169c92169a90995097509095509350505050565b600061146d8383426141eb565b600081156b019d971e4fe8401e740000001983900484111517613ed457600080fd5b506b033b2e3c9fd0803ce800000091026b019d971e4fe8401e74000000010490565b60006001600160801b03821115613f5f5760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20316044820152663238206269747360c81b6064820152608401611039565b5090565b61016081015115613fd2576000613f848261016001518361024001516141ae565b9050613f9d8260e0015182613eb290919063ffffffff16565b6101008301819052613fae90613ef6565b6001840180546001600160801b0319166001600160801b0392909216919091179055505b80511561403e576000613fef826101800151836102400151613ea5565b905061400982610120015182613eb290919063ffffffff16565b610140830181905261401a90613ef6565b6002840180546001600160801b0319166001600160801b0392909216919091179055505b5050565b61407b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b816101a0015160000361408d57505050565b610120820151825161409e91613eb2565b602082015261014082015182516140b491613eb2565b604082015260608201516102608301516102408401516140dc92919064ffffffffff166141eb565b6060820181905260408301516140f191613eb2565b80825260208201516080840151604084015161410d9190615c82565b6141179190615964565b6141219190615964565b608082018190526101a08301516141389190614317565b60a0820181905215611133576141686141638361010001518360a0015161433d90919063ffffffff16565b613ef6565b6008840180546000906141859084906001600160801b0316615c3b565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550505050565b6000806141c264ffffffffff841642615964565b6141cc9085615c95565b6301e13380900490506120c7816b033b2e3c9fd0803ce8000000615c82565b6000806141ff64ffffffffff851684615964565b90508060000361421e576b033b2e3c9fd0803ce800000091505061146d565b6000198101600080806002851161423657600061423b565b600285035b925066038882915c400061424f8a80613eb2565b8161425c5761425c615cac565b0491506301e1338061426e838b613eb2565b8161427b5761427b615cac565b04905060008261428b8688615c95565b6142959190615c95565b600290049050600082856142a9888a615c95565b6142b39190615c95565b6142bd9190615c95565b60069004905080826301e133806142d48a8f615c95565b6142de9190615cc2565b6142f4906b033b2e3c9fd0803ce8000000615c82565b6142fe9190615c82565b6143089190615c82565b9b9a5050505050505050505050565b60008115611388198390048411151761432f57600080fd5b506127109102611388010490565b600081156b033b2e3c9fd0803ce80000006002840419048411171561436157600080fd5b506b033b2e3c9fd0803ce80000009190910260028204010490565b604080516102008101825260006101e08201818152825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c081019190915290565b60405180610280016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016144836040518060200160405280600081525090565b815260006020820181905260408201819052606082018190526080820181905260a09091015290565b6001600160a01b0381168114610b1b57600080fd5b80356144cc816144ac565b919050565b8015158114610b1b57600080fd5b600080600080600060a086880312156144f757600080fd5b8535614502816144ac565b94506020860135614512816144ac565b93506040860135614522816144ac565b9250606086013591506080860135614539816144d1565b809150509295509295909350565b803561ffff811681146144cc57600080fd5b803560ff811681146144cc57600080fd5b600080600080600080600080610100898b03121561458757600080fd5b8835614592816144ac565b97506020890135965060408901356145a9816144ac565b95506145b760608a01614547565b9450608089013593506145cc60a08a01614559565b925060c0890135915060e089013590509295985092959890939650565b600080604083850312156145fc57600080fd5b8235614607816144ac565b91506020830135614617816144ac565b809150509250929050565b60006020828403121561463457600080fd5b5035919050565b60006020828403121561464d57600080fd5b61146d82614559565b60008060006060848603121561466b57600080fd5b8335614676816144ac565b95602085013595506040909401359392505050565b60006020828403121561469d57600080fd5b813561146d816144ac565b81515181526101e0810160208301516146cc60208401826001600160801b03169052565b5060408301516146e760408401826001600160801b03169052565b50606083015161470260608401826001600160801b03169052565b50608083015161471d60808401826001600160801b03169052565b5060a083015161473860a08401826001600160801b03169052565b5060c083015161475160c084018264ffffffffff169052565b5060e083015161476760e084018261ffff169052565b50610100838101516001600160a01b039081169184019190915261012080850151821690840152610140808501518216908401526101608085015190911690830152610180808401516001600160801b03908116918401919091526101a0808501518216908401526101c08085015191821681850152905b505092915050565b60008083601f8401126147f957600080fd5b5081356001600160401b0381111561481057600080fd5b60208301915083602082850101111561346157600080fd5b60008060008060008060a0878903121561484157600080fd5b863561484c816144ac565b9550602087013561485c816144ac565b94506040870135935060608701356001600160401b0381111561487e57600080fd5b61488a89828a016147e7565b909450925061489d905060808801614547565b90509295509295509295565b6000602082840312156148bb57600080fd5b61146d82614547565b600080600080608085870312156148da57600080fd5b84356148e5816144ac565b935060208501359250604085013591506060850135614903816144ac565b939692955090935050565b6000806040838503121561492157600080fd5b823561492c816144ac565b91506020830135614617816144d1565b6000806000806080858703121561495257600080fd5b843561495d816144ac565b9350602085013592506040850135614974816144ac565b915061498260608601614547565b905092959194509250565b6000806000606084860312156149a257600080fd5b505081359360208301359350604090920135919050565b6000806000606084860312156149ce57600080fd5b83356149d9816144ac565b92506020840135915060408401356149f0816144ac565b809150509250925092565b6000815180845260005b81811015614a2157602081850181015186830182015201614a05565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061ffff8084511660208401528060208501511660408401528060408501511660608401525060018060a01b036060840151166080830152608083015160a0808401526120c760c08401826149fb565b600080600080600060a08688031215614aae57600080fd5b8535614ab9816144ac565b94506020860135614ac9816144ac565b93506040860135614ad9816144ac565b92506060860135614ae9816144ac565b91506080860135614539816144ac565b815151815261022081016020830151614b1d60208401826001600160801b03169052565b506040830151614b3860408401826001600160801b03169052565b506060830151614b5360608401826001600160801b03169052565b506080830151614b6e60808401826001600160801b03169052565b5060a0830151614b8960a08401826001600160801b03169052565b5060c0830151614ba260c084018264ffffffffff169052565b5060e0830151614bb860e084018261ffff169052565b506101008381015164ffffffffff1690830152610120808401516001600160a01b0390811691840191909152610140808501518216908401526101608085015182169084015261018080850151909116908301526101a0808401516001600160801b03908116918401919091526101c0808501518216908401526101e0808501518216908401526102008085015191821681850152906147df565b60008060408385031215614c6657600080fd5b8235614c71816144ac565b946020939093013593505050565b60008083601f840112614c9157600080fd5b5081356001600160401b03811115614ca857600080fd5b6020830191508360208260051b850101111561346157600080fd5b60008060208385031215614cd657600080fd5b82356001600160401b03811115614cec57600080fd5b614cf885828601614c7f565b90969095509350505050565b600080600080600060a08688031215614d1c57600080fd5b8535614d27816144ac565b94506020860135935060408601359250614ae960608701614547565b600080600080600080600080600080600060e08c8e031215614d6457600080fd5b614d6d8c6144c1565b9a506001600160401b038060208e01351115614d8857600080fd5b614d988e60208f01358f01614c7f565b909b50995060408d0135811015614dae57600080fd5b614dbe8e60408f01358f01614c7f565b909950975060608d0135811015614dd457600080fd5b614de48e60608f01358f01614c7f565b9097509550614df560808e016144c1565b94508060a08e01351115614e0857600080fd5b50614e198d60a08e01358e016147e7565b9093509150614e2a60c08d01614547565b90509295989b509295989b9093969950565b64ffffffffff81168114610b1b57600080fd5b60008060408385031215614e6257600080fd5b8235614e6d816144ac565b9150602083013561461781614e3c565b80356001600160801b03811681146144cc57600080fd5b60008060408385031215614ea757600080fd5b614eb083614e7d565b9150614ebe60208401614e7d565b90509250929050565b600080600060608486031215614edc57600080fd5b8335614ee7816144ac565b92506020840135614ef7816144ac565b929592945050506040919091013590565b6020808252825182820181905260009190848201906040850190845b81811015614f495783516001600160a01b031683529284019291840191600101614f24565b50909695505050505050565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b0381118282101715614f8d57614f8d614f55565b60405290565b604051601f8201601f191681016001600160401b0381118282101715614fbb57614fbb614f55565b604052919050565b60008060408385031215614fd657600080fd5b614fdf83614559565b91506020808401356001600160401b0380821115614ffc57600080fd5b9085019060a0828803121561501057600080fd5b615018614f6b565b61502183614547565b815261502e848401614547565b8482015261503e60408401614547565b60408201526060830135615051816144ac565b606082015260808301358281111561506857600080fd5b80840193505087601f84011261507d57600080fd5b82358281111561508f5761508f614f55565b6150a1601f8201601f19168601614f93565b925080835288858286010111156150b757600080fd5b8085850186850137600085828501015250816080820152809450505050509250929050565b60008060008060008060c087890312156150f557600080fd5b8635615100816144ac565b95506020870135615110816144ac565b94506040870135615120816144ac565b959894975094956060810135955060808101359460a0909101359350915050565b600080600080600080600080610100898b03121561515e57600080fd5b8835615169816144ac565b9750602089013596506040890135955060608901356145b7816144ac565b600080828403604081121561519b57600080fd5b83356151a6816144ac565b92506020601f19820112156151ba57600080fd5b506020830190509250929050565b600080604083850312156151db57600080fd5b50508035926020909101359150565b6000602082840312156151fc57600080fd5b815161146d816144ac565b60006101a08201905086825285602083015284604083015283606083015282516080830152602083015160a0830152604083015160018060a01b0380821660c08501528060608601511660e085015250506080830151610100615274818501836001600160a01b03169052565b60a0850151151561012085015260c08501516001600160a01b0390811661014086015260e086015160ff166101608601529085015190811661018085015290505b509695505050505050565b6001600160a01b0397881681529590961660208601526040850193909352606084019190915260ff16608083015260a082015260c081019190915260e00190565b93845260208085019390935260408085019290925280516001600160a01b039081166060808701919091529382015160808601529181015190911660a0840152015161ffff1660c082015260e00190565b60208152600061146d60208301846149fb565b634e487b7160e01b600052602160045260246000fd5b6003811061539957634e487b7160e01b600052602160045260246000fd5b9052565b858152602081018590526001600160a01b0384811660408301528316606082015260a081016153cf608083018461537b565b9695505050505050565b8481526020808201859052604080830185905283516001600160a01b0390811660608501529184015160808401528301516101008301919061541e60a085018261537b565b5060608401511660c0830152608090920151151560e0909101529392505050565b60006020828403121561545157600080fd5b5051919050565b82815260406020820152600060018060a01b038084511660408401528060208501511660608401525060408301516080830152606083015160e060a08401526154a56101208401826149fb565b905061ffff60808501511660c084015260a084015160e084015260c0840151610100840152809150509392505050565b600181811c908216806154e957607f821691505b6020821081036134c557634e487b7160e01b600052602260045260246000fd5b60006101208201905084825283602083015260018060a01b038084511660408401528060208501511660608401528060408501511660808401528060608501511660a08401528060808501511660c08401525060a083015161557160e084018261ffff169052565b5060c083015161ffff811661010084015250949350505050565b60006020828403121561559d57600080fd5b815161146d816144d1565b634e487b7160e01b600052601160045260246000fd5b600061ffff8083168181036155d5576155d56155a8565b6001019392505050565b83815260406020808301829052908201839052600090849060608401835b8681101561562b578335615610816144ac565b6001600160a01b0316825292820192908201906001016155fd565b50979650505050505050565b85815260208101859052604081018490526060810183905281516001600160a01b03166080820152610200810160208301516001600160a01b03811660a08401525060408301516001600160a01b03811660c084015250606083015160e083015260808301516101006156ac8185018361537b565b60a085015191506101206156c58186018461ffff169052565b60c086015192506101406156dc8187018515159052565b60e08701516101608781019190915292870151610180870152908601516001600160a01b039081166101a08701529086015160ff166101c0860152908501519081166101e085015290506152b5565b60008151808452602080850194506020840160005b838110156157655781516001600160a01b031687529582019590820190600101615740565b509495945050505050565b60008151808452602080850194506020840160005b8381101561576557815187529582019590820190600101615785565b85815284602082015283604082015282606082015260a060808201526157d360a0820183516001600160a01b03169052565b600060208301516101e08060c08501526157f161028085018361572b565b91506040850151609f19808685030160e087015261580f8483615770565b93506060870151915061010081878603018188015261582e8584615770565b94506080880151925061012061584e818901856001600160a01b03169052565b60a089015193506101408389880301818a015261586b87866149fb565b965060c08a015194506101609350615888848a018661ffff169052565b60e08a0151945061018085818b0152838b015195506101a0935085848b0152828b015195506101c0925085838b0152818b0151878b0152848b015196506158db6102008b01886001600160a01b03169052565b8a01516001600160a01b0381166102208b015295506158f79050565b9088015160ff16610240880152870151801515610260880152925061562b915050565b60008060008060008060c0878903121561593357600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b818103818111156116af576116af6155a8565b634e487b7160e01b600052603260045260246000fd5b60006001820161599f5761599f6155a8565b5060010190565b601f821115611133576000816000526020600020601f850160051c810160208610156159cf5750805b601f850160051c820191505b818110156111c9578281556001016159db565b81516001600160401b03811115615a0757615a07614f55565b615a1b81615a1584546154d5565b846159a6565b602080601f831160018114615a505760008415615a385750858301515b600019600386901b1c1916600185901b1785556111c9565b600085815260208120601f198616915b82811015615a7f57888601518255948401946001909101908401615a60565b5085821015615a9d5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b858152602080820186905260408083018690526060830185905283516001600160a01b03908116608085015291840151821660a084015283015190811660c08301526101a082019050606083015160e08301526080830151610100818185015260a085015161012085015260c085015161014085015260e08501519150615b406101608501836001600160a01b03169052565b84015160ff811661018085015290506152b5565b60008060008060808587031215615b6a57600080fd5b845193506020850151925060408501519150606085015161490381614e3c565b600061014082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e0830151615bed60e08401826001600160a01b03169052565b506101008381015180151584830152505061012092830151919092015290565b600080600060608486031215615c2257600080fd5b8351925060208401519150604084015190509250925092565b6001600160801b03818116838216019080821115615c5b57615c5b6155a8565b5092915050565b6001600160801b03828116828216039080821115615c5b57615c5b6155a8565b808201808211156116af576116af6155a8565b80820281158282048414176116af576116af6155a8565b634e487b7160e01b600052601260045260246000fd5b600082615cdf57634e487b7160e01b600052601260045260246000fd5b50049056fea26469706673582212208a570e391347048da335f6c8b6905804ed4bbf4b1237c7899de849f3163911af64736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = MockL2PoolContractFunctions(mockl2pool_abi, self.w3, address)  # type: ignore
        self.events = MockL2PoolContractEvents(mockl2pool_abi, self.w3, address)  # type: ignore

    events: MockL2PoolContractEvents

    functions: MockL2PoolContractFunctions

    class ConstructorArgs(NamedTuple):
        """Arguments to pass the contract's constructor function."""

        addressesProvider: str

    class LinkReferences(NamedTuple):
        """Link references required when deploying."""

        BorrowLogic: BorrowLogicContract

        BridgeLogic: BridgeLogicContract

        EModeLogic: EModeLogicContract

        FlashLoanLogic: FlashLoanLogicContract

        LiquidationLogic: LiquidationLogicContract

        PoolLogic: PoolLogicContract

        SupplyLogic: SupplyLogicContract

    link_references_placeholder_lookup: dict[str, str] = {
        "BorrowLogic": "__$5f76d850ac254f0697945c46b13dedf9fb$__",
        "BridgeLogic": "__$3176f8b4007c03a59557e1c69343378539$__",
        "EModeLogic": "__$65f2e84d14e08abb971fea4350599006ac$__",
        "FlashLoanLogic": "__$8adee7547342d537bcdcaeb7c748cfa5c0$__",
        "LiquidationLogic": "__$589bdd19231b917beb0692fb1391cc382d$__",
        "PoolLogic": "__$eb5517a650f544fa14961d696410147857$__",
        "SupplyLogic": "__$283efb0a967bb30ce182c750a4aff98297$__",
    }

    @classmethod
    def constructor(cls, addressesProvider: str, link_references: LinkReferences) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["BorrowLogic"],
                link_references.BorrowLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["BridgeLogic"],
                link_references.BridgeLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["EModeLogic"],
                link_references.EModeLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["FlashLoanLogic"],
                link_references.FlashLoanLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["LiquidationLogic"],
                link_references.LiquidationLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["PoolLogic"],
                link_references.PoolLogic.address[2:].lower(),
            )

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["SupplyLogic"],
                link_references.SupplyLogic.address[2:].lower(),
            )

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor(dataclass_to_tuple(addressesProvider))

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        constructor_args: ConstructorArgs,
        link_references: LinkReferences,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(
            *constructor_args, link_references
        )

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = MockL2PoolContractFunctions(
            mockl2pool_abi, w3, None
        )

        return contract
