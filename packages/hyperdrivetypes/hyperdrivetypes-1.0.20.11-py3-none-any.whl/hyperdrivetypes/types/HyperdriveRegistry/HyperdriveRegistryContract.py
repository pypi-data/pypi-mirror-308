"""A web3.py Contract class for the HyperdriveRegistry contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..IHyperdriveRegistry import (
    IHyperdriveRegistryTypes as IHyperdriveRegistry,
)
from .HyperdriveRegistryTypes import (
    AdminUpdatedEvent,
    FactoryInfoUpdatedEvent,
    InitializedEvent,
    InstanceInfoUpdatedEvent,
    NameUpdatedEvent,
)

structs = {
    "IHyperdriveRegistry.FactoryInfo": IHyperdriveRegistry.FactoryInfo,
    "IHyperdriveRegistry.FactoryInfoWithMetadata": IHyperdriveRegistry.FactoryInfoWithMetadata,
    "IHyperdriveRegistry.InstanceInfo": IHyperdriveRegistry.InstanceInfo,
    "IHyperdriveRegistry.InstanceInfoWithMetadata": IHyperdriveRegistry.InstanceInfoWithMetadata,
}

hyperdriveregistry_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "admin",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoriesInRange",
            "inputs": [
                {
                    "name": "_startIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_endIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {
                    "name": "factories",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoryAtIndex",
            "inputs": [
                {"name": "_index", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoryInfo",
            "inputs": [
                {
                    "name": "_factory",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveRegistry.FactoryInfo",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoryInfoWithMetadata",
            "inputs": [
                {
                    "name": "_factory",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveRegistry.FactoryInfoWithMetadata",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "kind",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "version",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoryInfos",
            "inputs": [
                {
                    "name": "__factories",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple[]",
                    "internalType": "struct IHyperdriveRegistry.FactoryInfo[]",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getFactoryInfosWithMetadata",
            "inputs": [
                {
                    "name": "__factories",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple[]",
                    "internalType": "struct IHyperdriveRegistry.FactoryInfoWithMetadata[]",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "kind",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "version",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceAtIndex",
            "inputs": [
                {"name": "_index", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceInfo",
            "inputs": [
                {
                    "name": "_instance",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveRegistry.InstanceInfo",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "factory",
                            "type": "address",
                            "internalType": "address",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceInfoWithMetadata",
            "inputs": [
                {
                    "name": "_instance",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveRegistry.InstanceInfoWithMetadata",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "factory",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "kind",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "version",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceInfos",
            "inputs": [
                {
                    "name": "__instances",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple[]",
                    "internalType": "struct IHyperdriveRegistry.InstanceInfo[]",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "factory",
                            "type": "address",
                            "internalType": "address",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceInfosWithMetadata",
            "inputs": [
                {
                    "name": "__instances",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [
                {
                    "name": "info",
                    "type": "tuple[]",
                    "internalType": "struct IHyperdriveRegistry.InstanceInfoWithMetadata[]",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "factory",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "kind",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "version",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstancesInRange",
            "inputs": [
                {
                    "name": "_startIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_endIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {
                    "name": "instances",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNumberOfFactories",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNumberOfInstances",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initialize",
            "inputs": [
                {"name": "_name", "type": "string", "internalType": "string"},
                {
                    "name": "_admin",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isInitialized",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "kind",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setFactoryInfo",
            "inputs": [
                {
                    "name": "__factories",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "_data",
                    "type": "uint128[]",
                    "internalType": "uint128[]",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setInstanceInfo",
            "inputs": [
                {
                    "name": "__instances",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "_data",
                    "type": "uint128[]",
                    "internalType": "uint128[]",
                },
                {
                    "name": "__factories",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateAdmin",
            "inputs": [
                {"name": "_admin", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateName",
            "inputs": [
                {"name": "_name", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "version",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "event",
            "name": "AdminUpdated",
            "inputs": [
                {
                    "name": "admin",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FactoryInfoUpdated",
            "inputs": [
                {
                    "name": "factory",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "data",
                    "type": "uint256",
                    "indexed": True,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Initialized",
            "inputs": [
                {
                    "name": "name",
                    "type": "string",
                    "indexed": True,
                    "internalType": "string",
                },
                {
                    "name": "admin",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "InstanceInfoUpdated",
            "inputs": [
                {
                    "name": "instance",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "data",
                    "type": "uint256",
                    "indexed": True,
                    "internalType": "uint256",
                },
                {
                    "name": "factory",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "NameUpdated",
            "inputs": [
                {
                    "name": "name",
                    "type": "string",
                    "indexed": True,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "EndIndexTooLarge", "inputs": []},
        {"type": "error", "name": "InputLengthMismatch", "inputs": []},
        {"type": "error", "name": "InvalidFactory", "inputs": []},
        {"type": "error", "name": "InvalidIndexes", "inputs": []},
        {"type": "error", "name": "RegistryAlreadyInitialized", "inputs": []},
        {"type": "error", "name": "Unauthorized", "inputs": []},
    ],
)


class HyperdriveRegistryEndIndexTooLargeContractError(PypechainBaseError):
    """ContractError for EndIndexTooLarge."""

    # Error name
    name: str = "EndIndexTooLarge"
    # 4 byte error selector
    selector: str = "0xe0f7becb"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "EndIndexTooLarge()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryInputLengthMismatchContractError(PypechainBaseError):
    """ContractError for InputLengthMismatch."""

    # Error name
    name: str = "InputLengthMismatch"
    # 4 byte error selector
    selector: str = "0xaaad13f7"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InputLengthMismatch()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryInvalidFactoryContractError(PypechainBaseError):
    """ContractError for InvalidFactory."""

    # Error name
    name: str = "InvalidFactory"
    # 4 byte error selector
    selector: str = "0x7a44db95"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidFactory()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryInvalidIndexesContractError(PypechainBaseError):
    """ContractError for InvalidIndexes."""

    # Error name
    name: str = "InvalidIndexes"
    # 4 byte error selector
    selector: str = "0x764e6b56"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidIndexes()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryRegistryAlreadyInitializedContractError(
    PypechainBaseError
):
    """ContractError for RegistryAlreadyInitialized."""

    # Error name
    name: str = "RegistryAlreadyInitialized"
    # 4 byte error selector
    selector: str = "0xe45872b6"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "RegistryAlreadyInitialized()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryUnauthorizedContractError(PypechainBaseError):
    """ContractError for Unauthorized."""

    # Error name
    name: str = "Unauthorized"
    # 4 byte error selector
    selector: str = "0x82b42900"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "Unauthorized()"
    # Error input types
    abi: ABI = hyperdriveregistry_abi


class HyperdriveRegistryContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the HyperdriveRegistry contract."""

    EndIndexTooLarge: HyperdriveRegistryEndIndexTooLargeContractError

    InputLengthMismatch: HyperdriveRegistryInputLengthMismatchContractError

    InvalidFactory: HyperdriveRegistryInvalidFactoryContractError

    InvalidIndexes: HyperdriveRegistryInvalidIndexesContractError

    RegistryAlreadyInitialized: (
        HyperdriveRegistryRegistryAlreadyInitializedContractError
    )

    Unauthorized: HyperdriveRegistryUnauthorizedContractError

    def __init__(
        self,
    ) -> None:
        self.EndIndexTooLarge = (
            HyperdriveRegistryEndIndexTooLargeContractError()
        )
        self.InputLengthMismatch = (
            HyperdriveRegistryInputLengthMismatchContractError()
        )
        self.InvalidFactory = HyperdriveRegistryInvalidFactoryContractError()
        self.InvalidIndexes = HyperdriveRegistryInvalidIndexesContractError()
        self.RegistryAlreadyInitialized = (
            HyperdriveRegistryRegistryAlreadyInitializedContractError()
        )
        self.Unauthorized = HyperdriveRegistryUnauthorizedContractError()

        self._all = [
            self.EndIndexTooLarge,
            self.InputLengthMismatch,
            self.InvalidFactory,
            self.InvalidIndexes,
            self.RegistryAlreadyInitialized,
            self.Unauthorized,
        ]


class HyperdriveRegistryAdminContractFunction0(PypechainContractFunction):
    """ContractFunction for the admin() method."""

    _function_name = "admin"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryAdminContractFunction(PypechainContractFunction):
    """ContractFunction for the admin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "admin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryAdminContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryAdminContractFunction0._type_signature: HyperdriveRegistryAdminContractFunction0.factory(
                "HyperdriveRegistryAdminContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetFactoriesInRangeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoriesInRange(int,int) method."""

    _function_name = "getFactoriesInRange"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetFactoriesInRangeContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoriesInRange method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoriesInRange"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _startIndex: int, _endIndex: int) -> HyperdriveRegistryGetFactoriesInRangeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoriesInRangeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoriesInRangeContractFunction0._type_signature: HyperdriveRegistryGetFactoriesInRangeContractFunction0.factory(
                "HyperdriveRegistryGetFactoriesInRangeContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetFactoryAtIndexContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryAtIndex(int) method."""

    _function_name = "getFactoryAtIndex"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetFactoryAtIndexContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryAtIndex method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoryAtIndex"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _index: int) -> HyperdriveRegistryGetFactoryAtIndexContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoryAtIndexContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoryAtIndexContractFunction0._type_signature: HyperdriveRegistryGetFactoryAtIndexContractFunction0.factory(
                "HyperdriveRegistryGetFactoryAtIndexContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetFactoryInfoContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfo(str) method."""

    _function_name = "getFactoryInfo"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdriveRegistry.FactoryInfo:
        """returns IHyperdriveRegistry.FactoryInfo."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = IHyperdriveRegistry.FactoryInfo

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            IHyperdriveRegistry.FactoryInfo,
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetFactoryInfoContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfo method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoryInfo"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _factory: str) -> HyperdriveRegistryGetFactoryInfoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoryInfoContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoryInfoContractFunction0._type_signature: HyperdriveRegistryGetFactoryInfoContractFunction0.factory(
                "HyperdriveRegistryGetFactoryInfoContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfoWithMetadata(str) method."""

    _function_name = "getFactoryInfoWithMetadata"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdriveRegistry.FactoryInfoWithMetadata:
        """returns IHyperdriveRegistry.FactoryInfoWithMetadata."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = IHyperdriveRegistry.FactoryInfoWithMetadata

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            IHyperdriveRegistry.FactoryInfoWithMetadata,
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfoWithMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoryInfoWithMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _factory: str) -> HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction0._type_signature: HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction0.factory(
                "HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetFactoryInfosContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfos(list[str]) method."""

    _function_name = "getFactoryInfos"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[IHyperdriveRegistry.FactoryInfo]:
        """returns list[IHyperdriveRegistry.FactoryInfo]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[IHyperdriveRegistry.FactoryInfo]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[IHyperdriveRegistry.FactoryInfo],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetFactoryInfosContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfos method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoryInfos"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __factories: list[str]) -> HyperdriveRegistryGetFactoryInfosContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoryInfosContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoryInfosContractFunction0._type_signature: HyperdriveRegistryGetFactoryInfosContractFunction0.factory(
                "HyperdriveRegistryGetFactoryInfosContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfosWithMetadata(list[str]) method."""

    _function_name = "getFactoryInfosWithMetadata"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[IHyperdriveRegistry.FactoryInfoWithMetadata]:
        """returns list[IHyperdriveRegistry.FactoryInfoWithMetadata]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[IHyperdriveRegistry.FactoryInfoWithMetadata]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[IHyperdriveRegistry.FactoryInfoWithMetadata],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getFactoryInfosWithMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFactoryInfosWithMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __factories: list[str]) -> HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction0._type_signature: HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction0.factory(
                "HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetInstanceAtIndexContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceAtIndex(int) method."""

    _function_name = "getInstanceAtIndex"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetInstanceAtIndexContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceAtIndex method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstanceAtIndex"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _index: int) -> HyperdriveRegistryGetInstanceAtIndexContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstanceAtIndexContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstanceAtIndexContractFunction0._type_signature: HyperdriveRegistryGetInstanceAtIndexContractFunction0.factory(
                "HyperdriveRegistryGetInstanceAtIndexContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetInstanceInfoContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfo(str) method."""

    _function_name = "getInstanceInfo"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdriveRegistry.InstanceInfo:
        """returns IHyperdriveRegistry.InstanceInfo."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = IHyperdriveRegistry.InstanceInfo

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            IHyperdriveRegistry.InstanceInfo,
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetInstanceInfoContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfo method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstanceInfo"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _instance: str) -> HyperdriveRegistryGetInstanceInfoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstanceInfoContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstanceInfoContractFunction0._type_signature: HyperdriveRegistryGetInstanceInfoContractFunction0.factory(
                "HyperdriveRegistryGetInstanceInfoContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfoWithMetadata(str) method."""

    _function_name = "getInstanceInfoWithMetadata"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdriveRegistry.InstanceInfoWithMetadata:
        """returns IHyperdriveRegistry.InstanceInfoWithMetadata."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = IHyperdriveRegistry.InstanceInfoWithMetadata

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            IHyperdriveRegistry.InstanceInfoWithMetadata,
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfoWithMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstanceInfoWithMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _instance: str) -> HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction0._type_signature: HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction0.factory(
                "HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetInstanceInfosContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfos(list[str]) method."""

    _function_name = "getInstanceInfos"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[IHyperdriveRegistry.InstanceInfo]:
        """returns list[IHyperdriveRegistry.InstanceInfo]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[IHyperdriveRegistry.InstanceInfo]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[IHyperdriveRegistry.InstanceInfo],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetInstanceInfosContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfos method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstanceInfos"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __instances: list[str]) -> HyperdriveRegistryGetInstanceInfosContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstanceInfosContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstanceInfosContractFunction0._type_signature: HyperdriveRegistryGetInstanceInfosContractFunction0.factory(
                "HyperdriveRegistryGetInstanceInfosContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfosWithMetadata(list[str]) method."""

    _function_name = "getInstanceInfosWithMetadata"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[IHyperdriveRegistry.InstanceInfoWithMetadata]:
        """returns list[IHyperdriveRegistry.InstanceInfoWithMetadata]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[IHyperdriveRegistry.InstanceInfoWithMetadata]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[IHyperdriveRegistry.InstanceInfoWithMetadata],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstanceInfosWithMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstanceInfosWithMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __instances: list[str]) -> HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction0._type_signature: HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction0.factory(
                "HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetInstancesInRangeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getInstancesInRange(int,int) method."""

    _function_name = "getInstancesInRange"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetInstancesInRangeContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getInstancesInRange method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getInstancesInRange"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _startIndex: int, _endIndex: int) -> HyperdriveRegistryGetInstancesInRangeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetInstancesInRangeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetInstancesInRangeContractFunction0._type_signature: HyperdriveRegistryGetInstancesInRangeContractFunction0.factory(
                "HyperdriveRegistryGetInstancesInRangeContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetNumberOfFactoriesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getNumberOfFactories() method."""

    _function_name = "getNumberOfFactories"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetNumberOfFactoriesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getNumberOfFactories method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getNumberOfFactories"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryGetNumberOfFactoriesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetNumberOfFactoriesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetNumberOfFactoriesContractFunction0._type_signature: HyperdriveRegistryGetNumberOfFactoriesContractFunction0.factory(
                "HyperdriveRegistryGetNumberOfFactoriesContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryGetNumberOfInstancesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getNumberOfInstances() method."""

    _function_name = "getNumberOfInstances"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryGetNumberOfInstancesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getNumberOfInstances method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getNumberOfInstances"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryGetNumberOfInstancesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryGetNumberOfInstancesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryGetNumberOfInstancesContractFunction0._type_signature: HyperdriveRegistryGetNumberOfInstancesContractFunction0.factory(
                "HyperdriveRegistryGetNumberOfInstancesContractFunction0",
                **kwargs,
            ),
        }
        return out


class HyperdriveRegistryInitializeContractFunction0(PypechainContractFunction):
    """ContractFunction for the initialize(str,str) method."""

    _function_name = "initialize"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveRegistryInitializeContractFunction(PypechainContractFunction):
    """ContractFunction for the initialize method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initialize"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _name: str, _admin: str) -> HyperdriveRegistryInitializeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryInitializeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryInitializeContractFunction0._type_signature: HyperdriveRegistryInitializeContractFunction0.factory(
                "HyperdriveRegistryInitializeContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryIsInitializedContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the isInitialized() method."""

    _function_name = "isInitialized"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryIsInitializedContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the isInitialized method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isInitialized"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryIsInitializedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryIsInitializedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryIsInitializedContractFunction0._type_signature: HyperdriveRegistryIsInitializedContractFunction0.factory(
                "HyperdriveRegistryIsInitializedContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryKindContractFunction0(PypechainContractFunction):
    """ContractFunction for the kind() method."""

    _function_name = "kind"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryKindContractFunction(PypechainContractFunction):
    """ContractFunction for the kind method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "kind"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryKindContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryKindContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryKindContractFunction0._type_signature: HyperdriveRegistryKindContractFunction0.factory(
                "HyperdriveRegistryKindContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryNameContractFunction(PypechainContractFunction):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryNameContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryNameContractFunction0._type_signature: HyperdriveRegistryNameContractFunction0.factory(
                "HyperdriveRegistryNameContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistrySetFactoryInfoContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setFactoryInfo(list[str],list[int]) method."""

    _function_name = "setFactoryInfo"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[int]"]), structs
    )
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveRegistrySetFactoryInfoContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setFactoryInfo method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setFactoryInfo"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __factories: list[str], _data: list[int]) -> HyperdriveRegistrySetFactoryInfoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistrySetFactoryInfoContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistrySetFactoryInfoContractFunction0._type_signature: HyperdriveRegistrySetFactoryInfoContractFunction0.factory(
                "HyperdriveRegistrySetFactoryInfoContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistrySetInstanceInfoContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setInstanceInfo(list[str],list[int],list[str]) method."""

    _function_name = "setInstanceInfo"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[int]", "list[str]"]), structs
    )
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveRegistrySetInstanceInfoContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setInstanceInfo method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setInstanceInfo"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, __instances: list[str], _data: list[int], __factories: list[str]) -> HyperdriveRegistrySetInstanceInfoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistrySetInstanceInfoContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistrySetInstanceInfoContractFunction0._type_signature: HyperdriveRegistrySetInstanceInfoContractFunction0.factory(
                "HyperdriveRegistrySetInstanceInfoContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryUpdateAdminContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateAdmin(str) method."""

    _function_name = "updateAdmin"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveRegistryUpdateAdminContractFunction(PypechainContractFunction):
    """ContractFunction for the updateAdmin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateAdmin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _admin: str) -> HyperdriveRegistryUpdateAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryUpdateAdminContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryUpdateAdminContractFunction0._type_signature: HyperdriveRegistryUpdateAdminContractFunction0.factory(
                "HyperdriveRegistryUpdateAdminContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryUpdateNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateName(str) method."""

    _function_name = "updateName"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveRegistryUpdateNameContractFunction(PypechainContractFunction):
    """ContractFunction for the updateName method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateName"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _name: str) -> HyperdriveRegistryUpdateNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryUpdateNameContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryUpdateNameContractFunction0._type_signature: HyperdriveRegistryUpdateNameContractFunction0.factory(
                "HyperdriveRegistryUpdateNameContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryVersionContractFunction0(PypechainContractFunction):
    """ContractFunction for the version() method."""

    _function_name = "version"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveRegistryContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveRegistryVersionContractFunction(PypechainContractFunction):
    """ContractFunction for the version method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "version"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveRegistryVersionContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveRegistryVersionContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            HyperdriveRegistryVersionContractFunction0._type_signature: HyperdriveRegistryVersionContractFunction0.factory(
                "HyperdriveRegistryVersionContractFunction0", **kwargs
            ),
        }
        return out


class HyperdriveRegistryContractFunctions(ContractFunctions):
    """ContractFunctions for the HyperdriveRegistry contract."""

    admin: HyperdriveRegistryAdminContractFunction

    getFactoriesInRange: HyperdriveRegistryGetFactoriesInRangeContractFunction

    getFactoryAtIndex: HyperdriveRegistryGetFactoryAtIndexContractFunction

    getFactoryInfo: HyperdriveRegistryGetFactoryInfoContractFunction

    getFactoryInfoWithMetadata: (
        HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction
    )

    getFactoryInfos: HyperdriveRegistryGetFactoryInfosContractFunction

    getFactoryInfosWithMetadata: (
        HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction
    )

    getInstanceAtIndex: HyperdriveRegistryGetInstanceAtIndexContractFunction

    getInstanceInfo: HyperdriveRegistryGetInstanceInfoContractFunction

    getInstanceInfoWithMetadata: (
        HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction
    )

    getInstanceInfos: HyperdriveRegistryGetInstanceInfosContractFunction

    getInstanceInfosWithMetadata: (
        HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction
    )

    getInstancesInRange: HyperdriveRegistryGetInstancesInRangeContractFunction

    getNumberOfFactories: HyperdriveRegistryGetNumberOfFactoriesContractFunction

    getNumberOfInstances: HyperdriveRegistryGetNumberOfInstancesContractFunction

    initialize: HyperdriveRegistryInitializeContractFunction

    isInitialized: HyperdriveRegistryIsInitializedContractFunction

    kind: HyperdriveRegistryKindContractFunction

    name: HyperdriveRegistryNameContractFunction

    setFactoryInfo: HyperdriveRegistrySetFactoryInfoContractFunction

    setInstanceInfo: HyperdriveRegistrySetInstanceInfoContractFunction

    updateAdmin: HyperdriveRegistryUpdateAdminContractFunction

    updateName: HyperdriveRegistryUpdateNameContractFunction

    version: HyperdriveRegistryVersionContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.admin = HyperdriveRegistryAdminContractFunction.factory(
            "admin",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="admin",
        )
        self.getFactoriesInRange = (
            HyperdriveRegistryGetFactoriesInRangeContractFunction.factory(
                "getFactoriesInRange",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFactoriesInRange",
            )
        )
        self.getFactoryAtIndex = (
            HyperdriveRegistryGetFactoryAtIndexContractFunction.factory(
                "getFactoryAtIndex",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFactoryAtIndex",
            )
        )
        self.getFactoryInfo = (
            HyperdriveRegistryGetFactoryInfoContractFunction.factory(
                "getFactoryInfo",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFactoryInfo",
            )
        )
        self.getFactoryInfoWithMetadata = HyperdriveRegistryGetFactoryInfoWithMetadataContractFunction.factory(
            "getFactoryInfoWithMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getFactoryInfoWithMetadata",
        )
        self.getFactoryInfos = (
            HyperdriveRegistryGetFactoryInfosContractFunction.factory(
                "getFactoryInfos",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFactoryInfos",
            )
        )
        self.getFactoryInfosWithMetadata = HyperdriveRegistryGetFactoryInfosWithMetadataContractFunction.factory(
            "getFactoryInfosWithMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getFactoryInfosWithMetadata",
        )
        self.getInstanceAtIndex = (
            HyperdriveRegistryGetInstanceAtIndexContractFunction.factory(
                "getInstanceAtIndex",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstanceAtIndex",
            )
        )
        self.getInstanceInfo = (
            HyperdriveRegistryGetInstanceInfoContractFunction.factory(
                "getInstanceInfo",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstanceInfo",
            )
        )
        self.getInstanceInfoWithMetadata = HyperdriveRegistryGetInstanceInfoWithMetadataContractFunction.factory(
            "getInstanceInfoWithMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getInstanceInfoWithMetadata",
        )
        self.getInstanceInfos = (
            HyperdriveRegistryGetInstanceInfosContractFunction.factory(
                "getInstanceInfos",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstanceInfos",
            )
        )
        self.getInstanceInfosWithMetadata = HyperdriveRegistryGetInstanceInfosWithMetadataContractFunction.factory(
            "getInstanceInfosWithMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getInstanceInfosWithMetadata",
        )
        self.getInstancesInRange = (
            HyperdriveRegistryGetInstancesInRangeContractFunction.factory(
                "getInstancesInRange",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstancesInRange",
            )
        )
        self.getNumberOfFactories = (
            HyperdriveRegistryGetNumberOfFactoriesContractFunction.factory(
                "getNumberOfFactories",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getNumberOfFactories",
            )
        )
        self.getNumberOfInstances = (
            HyperdriveRegistryGetNumberOfInstancesContractFunction.factory(
                "getNumberOfInstances",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getNumberOfInstances",
            )
        )
        self.initialize = HyperdriveRegistryInitializeContractFunction.factory(
            "initialize",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initialize",
        )
        self.isInitialized = (
            HyperdriveRegistryIsInitializedContractFunction.factory(
                "isInitialized",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isInitialized",
            )
        )
        self.kind = HyperdriveRegistryKindContractFunction.factory(
            "kind",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="kind",
        )
        self.name = HyperdriveRegistryNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.setFactoryInfo = (
            HyperdriveRegistrySetFactoryInfoContractFunction.factory(
                "setFactoryInfo",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setFactoryInfo",
            )
        )
        self.setInstanceInfo = (
            HyperdriveRegistrySetInstanceInfoContractFunction.factory(
                "setInstanceInfo",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setInstanceInfo",
            )
        )
        self.updateAdmin = (
            HyperdriveRegistryUpdateAdminContractFunction.factory(
                "updateAdmin",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateAdmin",
            )
        )
        self.updateName = HyperdriveRegistryUpdateNameContractFunction.factory(
            "updateName",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateName",
        )
        self.version = HyperdriveRegistryVersionContractFunction.factory(
            "version",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="version",
        )


class HyperdriveRegistryAdminUpdatedContractEvent(ContractEvent):
    """ContractEvent for AdminUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AdminUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AdminUpdatedEvent.AdminUpdatedEventArgs(
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AdminUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AdminUpdatedEvent.AdminUpdatedEventArgs(
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveRegistryFactoryInfoUpdatedContractEvent(ContractEvent):
    """ContractEvent for FactoryInfoUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FactoryInfoUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FactoryInfoUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FactoryInfoUpdatedEvent.FactoryInfoUpdatedEventArgs(
                    factory=abi_event.args["factory"],
                    data=abi_event.args["data"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FactoryInfoUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FactoryInfoUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FactoryInfoUpdatedEvent.FactoryInfoUpdatedEventArgs(
                    factory=abi_event.args["factory"],
                    data=abi_event.args["data"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveRegistryInitializedContractEvent(ContractEvent):
    """ContractEvent for Initialized."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[InitializedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            InitializedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=InitializedEvent.InitializedEventArgs(
                    name=abi_event.args["name"],
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[InitializedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            InitializedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=InitializedEvent.InitializedEventArgs(
                    name=abi_event.args["name"],
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveRegistryInstanceInfoUpdatedContractEvent(ContractEvent):
    """ContractEvent for InstanceInfoUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[InstanceInfoUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            InstanceInfoUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=InstanceInfoUpdatedEvent.InstanceInfoUpdatedEventArgs(
                    instance=abi_event.args["instance"],
                    data=abi_event.args["data"],
                    factory=abi_event.args["factory"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[InstanceInfoUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            InstanceInfoUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=InstanceInfoUpdatedEvent.InstanceInfoUpdatedEventArgs(
                    instance=abi_event.args["instance"],
                    data=abi_event.args["data"],
                    factory=abi_event.args["factory"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveRegistryNameUpdatedContractEvent(ContractEvent):
    """ContractEvent for NameUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[NameUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            NameUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=NameUpdatedEvent.NameUpdatedEventArgs(
                    name=abi_event.args["name"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[NameUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            NameUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=NameUpdatedEvent.NameUpdatedEventArgs(
                    name=abi_event.args["name"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveRegistryContractEvents(ContractEvents):
    """ContractEvents for the HyperdriveRegistry contract."""

    AdminUpdated: Type[HyperdriveRegistryAdminUpdatedContractEvent]

    FactoryInfoUpdated: Type[HyperdriveRegistryFactoryInfoUpdatedContractEvent]

    Initialized: Type[HyperdriveRegistryInitializedContractEvent]

    InstanceInfoUpdated: Type[
        HyperdriveRegistryInstanceInfoUpdatedContractEvent
    ]

    NameUpdated: Type[HyperdriveRegistryNameUpdatedContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.AdminUpdated = cast(
            Type[HyperdriveRegistryAdminUpdatedContractEvent],
            HyperdriveRegistryAdminUpdatedContractEvent.factory(
                "AdminUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AdminUpdated",
            ),
        )
        self.FactoryInfoUpdated = cast(
            Type[HyperdriveRegistryFactoryInfoUpdatedContractEvent],
            HyperdriveRegistryFactoryInfoUpdatedContractEvent.factory(
                "FactoryInfoUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="FactoryInfoUpdated",
            ),
        )
        self.Initialized = cast(
            Type[HyperdriveRegistryInitializedContractEvent],
            HyperdriveRegistryInitializedContractEvent.factory(
                "Initialized",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Initialized",
            ),
        )
        self.InstanceInfoUpdated = cast(
            Type[HyperdriveRegistryInstanceInfoUpdatedContractEvent],
            HyperdriveRegistryInstanceInfoUpdatedContractEvent.factory(
                "InstanceInfoUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="InstanceInfoUpdated",
            ),
        )
        self.NameUpdated = cast(
            Type[HyperdriveRegistryNameUpdatedContractEvent],
            HyperdriveRegistryNameUpdatedContractEvent.factory(
                "NameUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="NameUpdated",
            ),
        )


class HyperdriveRegistryContract(Contract):
    """A web3.py Contract class for the HyperdriveRegistry contract."""

    abi: ABI = hyperdriveregistry_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x608060405234801561001057600080fd5b50612943806100206000396000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c80639b724ad4116100c3578063e2f273bd1161007c578063e2f273bd146103f8578063e967e3881461040b578063ea3503211461041e578063f32c9e341461043e578063f59d00b91461045e578063f851a4401461046657600080fd5b80639b724ad414610310578063a587bbe114610367578063b73e3fab14610392578063bc30e7a1146103b2578063d2f72d52146103c5578063daac24da146103e557600080fd5b80634db6c0e0116101155780634db6c0e01461027257806354fd4d50146102925780636e95d67c146102b8578063716ba5f6146102ca5780637ab4339d146102ea57806384da92a7146102fd57600080fd5b806304baa00b1461015d57806306fdde03146101a457806318bb3b54146101ac5780631ff30ad2146102205780632ad19de814610235578063392e53cd14610255575b600080fd5b61018e6040518060400160405280601281526020017148797065726472697665526567697374727960701b81525081565b60405161019b9190611fa5565b60405180910390f35b61018e610479565b6102136101ba366004611fdb565b6040805180820190915260008082526020820152506040805180820182526001600160a01b0392831660008181526006602081815294822080546001600160801b03168552929091528352600101549092169082015290565b60405161019b9190611ff6565b61023361022e366004612061565b610507565b005b610248610243366004611fdb565b6108d2565b60405161019b9190612167565b6000546102629060ff1681565b604051901515815260200161019b565b61028561028036600461217a565b610a61565b60405161019b91906121bb565b61018e60405180604001604052806007815260200166076312e302e32360cc1b81525081565b6005545b60405190815260200161019b565b6102dd6102d836600461221b565b610baa565b60405161019b919061223d565b6102336102f836600461228a565b610ca9565b61023361030b366004612377565b610d4c565b61035861031e366004611fdb565b6040805160208082018352600091829052825180820184526001600160a01b039490941682526004905220546001600160801b0316815290565b6040519051815260200161019b565b61037a6103753660046123f6565b610dc4565b6040516001600160a01b03909116815260200161019b565b6103a56103a036600461217a565b610df4565b60405161019b9190612461565b6102dd6103c036600461221b565b611083565b6103d86103d336600461217a565b611182565b60405161019b91906124c5565b61037a6103f33660046123f6565b611443565b610233610406366004611fdb565b611458565b61023361041936600461251c565b6114cc565b61043161042c36600461217a565b611878565b60405161019b9190612587565b61045161044c366004611fdb565b611962565b60405161019b91906125c0565b6003546102bc565b60025461037a906001600160a01b031681565b60018054610486906125d3565b80601f01602080910402602001604051908101604052809291908181526020018280546104b2906125d3565b80156104ff5780601f106104d4576101008083540402835291602001916104ff565b820191906000526020600020905b8154815290600101906020018083116104e257829003601f168201915b505050505081565b6002546001600160a01b03163314610531576040516282b42960e81b815260040160405180910390fd5b84831415806105405750848114155b1561055e5760405163aaad13f760e01b815260040160405180910390fd5b60005b858110156108c9576000600660008989858181106105815761058161260d565b90506020020160208101906105969190611fdb565b6001600160a01b031681526020810191909152604001600020546001600160801b031690508585838181106105cd576105cd61260d565b90506020020160208101906105e29190612623565b6001600160801b03161580156105f757508015155b156106805760008484848181106106105761061061260d565b90506020020160208101906106259190611fdb565b6001600160a01b03161461064c57604051637a44db9560e01b815260040160405180910390fd5b61067b8888848181106106615761066161260d565b90506020020160208101906106769190611fdb565b6119f7565b610803565b8585838181106106925761069261260d565b90506020020160208101906106a79190612623565b6001600160801b0316158015906106bd57508015155b1561073f5761067b8888848181106106d7576106d761260d565b90506020020160208101906106ec9190611fdb565b8787858181106106fe576106fe61260d565b90506020020160208101906107139190612623565b8686868181106107255761072561260d565b905060200201602081019061073a9190611fdb565b611b4d565b8585838181106107515761075161260d565b90506020020160208101906107669190612623565b6001600160801b03161580159061077b575080155b156107fd5761067b8888848181106107955761079561260d565b90506020020160208101906107aa9190611fdb565b8787858181106107bc576107bc61260d565b90506020020160208101906107d19190612623565b8686868181106107e3576107e361260d565b90506020020160208101906107f89190611fdb565b611c94565b506108c1565b8383838181106108155761081561260d565b905060200201602081019061082a9190611fdb565b6001600160a01b03168686848181106108455761084561260d565b905060200201602081019061085a9190612623565b6001600160801b03168989858181106108755761087561260d565b905060200201602081019061088a9190611fdb565b6001600160a01b03167fdcdda2b8267b8fe0ebfeb2cc8f266807b412bec096d16cbbe576d46d122553e060405160405180910390a4505b600101610561565b50505050505050565b6108da611f1d565b6040805160a0810182526001600160a01b0380851660008181526006602081815286832080546001600160801b031687528484529181526001909101549093169284019290925283516306fdde0360e01b8152845187958501936306fdde0392600480820193918290030181865afa15801561095a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610982919081019061264c565b8152602001826001600160a01b03166304baa00b6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156109c5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109ed919081019061264c565b8152602001826001600160a01b03166354fd4d506040518163ffffffff1660e01b8152600401600060405180830381865afa158015610a30573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610a58919081019061264c565b90529392505050565b6060816001600160401b03811115610a7b57610a7b61230a565b604051908082528060200260200182016040528015610ac057816020015b6040805180820190915260008082526020820152815260200190600190039081610a995790505b50905060005b82811015610ba257604051806040016040528060066000878786818110610aef57610aef61260d565b9050602002016020810190610b049190611fdb565b6001600160a01b031681526020808201929092526040016000908120546001600160801b03168352910190600690878786818110610b4457610b4461260d565b9050602002016020810190610b599190611fdb565b6001600160a01b0390811682526020820192909252604001600020600101541690528251839083908110610b8f57610b8f61260d565b6020908102919091010152600101610ac6565b505b92915050565b6060818310610bcc57604051633b2735ab60e11b815260040160405180910390fd5b600354821115610bef5760405163e0f7becb60e01b815260040160405180910390fd5b610bf983836126b9565b6001600160401b03811115610c1057610c1061230a565b604051908082528060200260200182016040528015610c39578160200160208202803683370190505b509050825b82811015610ba25760038181548110610c5957610c5961260d565b6000918252602090912001546001600160a01b031682610c7986846126b9565b81518110610c8957610c8961260d565b6001600160a01b0390921660209283029190910190910152600101610c3e565b60005460ff1615610ccd5760405163722c395b60e11b815260040160405180910390fd5b6000805460ff19166001908117909155610ce883858361272b565b50600280546001600160a01b0319166001600160a01b038316908117909155604051610d1790859085906127ea565b604051908190038120907fe57439d837715589a751e391f73a95929ecc96ae6aa09a16be8ae312d614715790600090a3505050565b6002546001600160a01b03163314610d76576040516282b42960e81b815260040160405180910390fd5b6001610d8282826127fa565b5080604051610d9191906128b9565b604051908190038120907f9f7688a97f1ac51fe03bac18af18d6810f9f11f0db08c59b1938a9ac825ef74490600090a250565b600060038281548110610dd957610dd961260d565b6000918252602090912001546001600160a01b031692915050565b6060816001600160401b03811115610e0e57610e0e61230a565b604051908082528060200260200182016040528015610e6a57816020015b610e576040518060800160405280600081526020016060815260200160608152602001606081525090565b815260200190600190039081610e2c5790505b50905060005b82811015610ba2576000848483818110610e8c57610e8c61260d565b9050602002016020810190610ea19190611fdb565b9050604051806080016040528060046000888887818110610ec457610ec461260d565b9050602002016020810190610ed99190611fdb565b6001600160a01b03166001600160a01b0316815260200190815260200160002060000160009054906101000a90046001600160801b03166001600160801b03168152602001826001600160a01b03166306fdde036040518163ffffffff1660e01b8152600401600060405180830381865afa158015610f5c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610f84919081019061264c565b8152602001826001600160a01b03166304baa00b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610fc7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610fef919081019061264c565b8152602001826001600160a01b03166354fd4d506040518163ffffffff1660e01b8152600401600060405180830381865afa158015611032573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261105a919081019061264c565b81525083838151811061106f5761106f61260d565b602090810291909101015250600101610e70565b60608183106110a557604051633b2735ab60e11b815260040160405180910390fd5b6005548211156110c85760405163e0f7becb60e01b815260040160405180910390fd5b6110d283836126b9565b6001600160401b038111156110e9576110e961230a565b604051908082528060200260200182016040528015611112578160200160208202803683370190505b509050825b82811015610ba257600581815481106111325761113261260d565b6000918252602090912001546001600160a01b03168261115286846126b9565b815181106111625761116261260d565b6001600160a01b0390921660209283029190910190910152600101611117565b6060816001600160401b0381111561119c5761119c61230a565b6040519080825280602002602001820160405280156111d557816020015b6111c2611f1d565b8152602001906001900390816111ba5790505b50905060005b82811015610ba25760008484838181106111f7576111f761260d565b905060200201602081019061120c9190611fdb565b90506040518060a001604052806006600088888781811061122f5761122f61260d565b90506020020160208101906112449190611fdb565b6001600160a01b031681526020808201929092526040016000908120546001600160801b031683529101906006908888878181106112845761128461260d565b90506020020160208101906112999190611fdb565b6001600160a01b03166001600160a01b0316815260200190815260200160002060010160009054906101000a90046001600160a01b03166001600160a01b03168152602001826001600160a01b03166306fdde036040518163ffffffff1660e01b8152600401600060405180830381865afa15801561131c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611344919081019061264c565b8152602001826001600160a01b03166304baa00b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611387573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113af919081019061264c565b8152602001826001600160a01b03166354fd4d506040518163ffffffff1660e01b8152600401600060405180830381865afa1580156113f2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261141a919081019061264c565b81525083838151811061142f5761142f61260d565b6020908102919091010152506001016111db565b600060058281548110610dd957610dd961260d565b6002546001600160a01b03163314611482576040516282b42960e81b815260040160405180910390fd5b600280546001600160a01b0319166001600160a01b0383169081179091556040517f54e4612788f90384e6843298d7854436f3a585b2c3831ab66abf1de63bfa6c2d90600090a250565b6002546001600160a01b031633146114f6576040516282b42960e81b815260040160405180910390fd5b8281146115165760405163aaad13f760e01b815260040160405180910390fd5b60005b83811015611871576000600460008787858181106115395761153961260d565b905060200201602081019061154e9190611fdb565b6001600160a01b031681526020810191909152604001600020546001600160801b031690508383838181106115855761158561260d565b905060200201602081019061159a9190612623565b6001600160801b03161580156115af57508015155b156115e8576115e38686848181106115c9576115c961260d565b90506020020160208101906115de9190611fdb565b611dd9565b6117db565b8383838181106115fa576115fa61260d565b905060200201602081019061160f9190612623565b6001600160801b03161580159061162557508015155b156116b4576115e386868481811061163f5761163f61260d565b90506020020160208101906116549190611fdb565b8585858181106116665761166661260d565b905060200201602081019061167b9190612623565b6001600160a01b0391909116600090815260046020526040902080546001600160801b0319166001600160801b03909216919091179055565b8383838181106116c6576116c661260d565b90506020020160208101906116db9190612623565b6001600160801b0316158015906116f0575080155b156117d5576115e386868481811061170a5761170a61260d565b905060200201602081019061171f9190611fdb565b8585858181106117315761173161260d565b90506020020160208101906117469190612623565b60038054600181019091557fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b810180546001600160a01b039094166001600160a01b0319909416841790556040805180820182526001600160801b03938416815291831660208381019182526000958652600490529320905192518216600160801b0292909116919091179055565b50611869565b8383838181106117ed576117ed61260d565b90506020020160208101906118029190612623565b6001600160801b031686868481811061181d5761181d61260d565b90506020020160208101906118329190611fdb565b6001600160a01b03167fd840ea8cb042bc840d3e55a04618ab268434d3d0a218638360a30fdb80de63f660405160405180910390a3505b600101611519565b5050505050565b6060816001600160401b038111156118925761189261230a565b6040519080825280602002602001820160405280156118d257816020015b6040805160208101909152600081528152602001906001900390816118b05790505b50905060005b82811015610ba2576040518060200160405280600460008787868181106119015761190161260d565b90506020020160208101906119169190611fdb565b6001600160a01b031681526020810191909152604001600020546001600160801b03169052825183908390811061194f5761194f61260d565b60209081029190910101526001016118d8565b61198d6040518060800160405280600081526020016060815260200160608152602001606081525090565b604080516080810182526001600160a01b038416600081815260046020818152858320546001600160801b0316855285516306fdde0360e01b81529551889691860194936306fdde0393838101939192918290030181865afa15801561095a573d6000803e3d6000fd5b6001600160a01b038116600090815260066020526040902054600554600160801b9091046001600160801b031690611a306001826126b9565b826001600160801b031614611ae85760006005611a4e6001846126b9565b81548110611a5e57611a5e61260d565b60009182526020808320909101546001600160a01b03168083526006909152604090912080546001600160801b03808716600160801b810291909216179091556005805492935083929091908110611ab857611ab861260d565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505b6005805480611af957611af96128d5565b60008281526020808220830160001990810180546001600160a01b031990811690915593019093556001600160a01b0395909516855260069091526040842093845560019390930180549093169092555050565b6001600160a01b03808416600090815260066020526040902060010154168015801590611b8c5750816001600160a01b0316816001600160a01b031614155b80611c2457506001600160a01b038116158015611bb157506001600160a01b03821615155b8015611c2457506040516335a2735f60e11b81526001600160a01b038581166004830152831690636b44e6be90602401602060405180830381865afa158015611bfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c2291906128eb565b155b15611c4257604051637a44db9560e01b815260040160405180910390fd5b506001600160a01b03928316600090815260066020526040902080546001600160801b0319166001600160801b0393909316929092178255600190910180546001600160a01b03191691909216179055565b6001600160a01b03811615801590611d1357506040516335a2735f60e11b81526001600160a01b038481166004830152821690636b44e6be90602401602060405180830381865afa158015611ced573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d1191906128eb565b155b15611d3157604051637a44db9560e01b815260040160405180910390fd5b6005805460018082019092557f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0810180546001600160a01b039687166001600160a01b03199182168117909255604080516060810182526001600160801b0397881681529387166020858101918252968916858301908152600094855260069097529220925191518616600160801b0291909516178155915191018054919093169116179055565b6001600160a01b038116600090815260046020526040902054600354600160801b9091046001600160801b031690611e126001826126b9565b826001600160801b031614611eca5760006003611e306001846126b9565b81548110611e4057611e4061260d565b60009182526020808320909101546001600160a01b03168083526004909152604090912080546001600160801b03808716600160801b810291909216179091556003805492935083929091908110611e9a57611e9a61260d565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505b6003805480611edb57611edb6128d5565b60008281526020808220830160001990810180546001600160a01b03191690559092019092556001600160a01b03949094168152600490935250506040812055565b6040518060a001604052806000815260200160006001600160a01b031681526020016060815260200160608152602001606081525090565b60005b83811015611f70578181015183820152602001611f58565b50506000910152565b60008151808452611f91816020860160208601611f55565b601f01601f19169290920160200192915050565b602081526000611fb86020830184611f79565b9392505050565b80356001600160a01b0381168114611fd657600080fd5b919050565b600060208284031215611fed57600080fd5b611fb882611fbf565b815181526020808301516001600160a01b03169082015260408101610ba4565b60008083601f84011261202857600080fd5b5081356001600160401b0381111561203f57600080fd5b6020830191508360208260051b850101111561205a57600080fd5b9250929050565b6000806000806000806060878903121561207a57600080fd5b86356001600160401b038082111561209157600080fd5b61209d8a838b01612016565b909850965060208901359150808211156120b657600080fd5b6120c28a838b01612016565b909650945060408901359150808211156120db57600080fd5b506120e889828a01612016565b979a9699509497509295939492505050565b8051825260018060a01b0360208201511660208301526000604082015160a0604085015261212b60a0850182611f79565b9050606083015184820360608601526121448282611f79565b9150506080830151848203608086015261215e8282611f79565b95945050505050565b602081526000611fb860208301846120fa565b6000806020838503121561218d57600080fd5b82356001600160401b038111156121a357600080fd5b6121af85828601612016565b90969095509350505050565b602080825282518282018190526000919060409081850190868401855b8281101561220e576121fe848351805182526020908101516001600160a01b0316910152565b92840192908501906001016121d8565b5091979650505050505050565b6000806040838503121561222e57600080fd5b50508035926020909101359150565b6020808252825182820181905260009190848201906040850190845b8181101561227e5783516001600160a01b031683529284019291840191600101612259565b50909695505050505050565b60008060006040848603121561229f57600080fd5b83356001600160401b03808211156122b657600080fd5b818601915086601f8301126122ca57600080fd5b8135818111156122d957600080fd5b8760208285010111156122eb57600080fd5b6020928301955093506123019186019050611fbf565b90509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156123485761234861230a565b604052919050565b60006001600160401b038211156123695761236961230a565b50601f01601f191660200190565b60006020828403121561238957600080fd5b81356001600160401b0381111561239f57600080fd5b8201601f810184136123b057600080fd5b80356123c36123be82612350565b612320565b8181528560208385010111156123d857600080fd5b81602084016020830137600091810160200191909152949350505050565b60006020828403121561240857600080fd5b5035919050565b80518252600060208201516080602085015261242e6080850182611f79565b9050604083015184820360408601526124478282611f79565b9150506060830151848203606086015261215e8282611f79565b600060208083016020845280855180835260408601915060408160051b87010192506020870160005b828110156124b857603f198886030184526124a685835161240f565b9450928501929085019060010161248a565b5092979650505050505050565b600060208083016020845280855180835260408601915060408160051b87010192506020870160005b828110156124b857603f1988860301845261250a8583516120fa565b945092850192908501906001016124ee565b6000806000806040858703121561253257600080fd5b84356001600160401b038082111561254957600080fd5b61255588838901612016565b9096509450602087013591508082111561256e57600080fd5b5061257b87828801612016565b95989497509550505050565b6020808252825182820181905260009190848201906040850190845b8181101561227e57835151835292840192918401916001016125a3565b602081526000611fb8602083018461240f565b600181811c908216806125e757607f821691505b60208210810361260757634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561263557600080fd5b81356001600160801b0381168114611fb857600080fd5b60006020828403121561265e57600080fd5b81516001600160401b0381111561267457600080fd5b8201601f8101841361268557600080fd5b80516126936123be82612350565b8181528560208385010111156126a857600080fd5b61215e826020830160208601611f55565b81810381811115610ba457634e487b7160e01b600052601160045260246000fd5b601f821115612726576000816000526020600020601f850160051c810160208610156127035750805b601f850160051c820191505b818110156127225782815560010161270f565b5050505b505050565b6001600160401b038311156127425761274261230a565b6127568361275083546125d3565b836126da565b6000601f84116001811461278a57600085156127725750838201355b600019600387901b1c1916600186901b178355611871565b600083815260209020601f19861690835b828110156127bb578685013582556020948501946001909201910161279b565b50868210156127d85760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b8183823760009101908152919050565b81516001600160401b038111156128135761281361230a565b6128278161282184546125d3565b846126da565b602080601f83116001811461285c57600084156128445750858301515b600019600386901b1c1916600185901b178555612722565b600085815260208120601f198616915b8281101561288b5788860151825594840194600190910190840161286c565b50858210156128a95787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600082516128cb818460208701611f55565b9190910192915050565b634e487b7160e01b600052603160045260246000fd5b6000602082840312156128fd57600080fd5b81518015158114611fb857600080fdfea2646970667358221220c11057a383fa5371752db51a5d5db656ffe1f1b62ccebf2f42271dd36eddbd7664736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = HyperdriveRegistryContractFunctions(hyperdriveregistry_abi, self.w3, address)  # type: ignore
        self.events = HyperdriveRegistryContractEvents(hyperdriveregistry_abi, self.w3, address)  # type: ignore
        self.errors = HyperdriveRegistryContractErrors()

    events: HyperdriveRegistryContractEvents

    errors: HyperdriveRegistryContractErrors = (
        HyperdriveRegistryContractErrors()
    )

    functions: HyperdriveRegistryContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = HyperdriveRegistryContractFunctions(
            hyperdriveregistry_abi, w3, None
        )
        contract.errors = HyperdriveRegistryContractErrors()

        return contract
