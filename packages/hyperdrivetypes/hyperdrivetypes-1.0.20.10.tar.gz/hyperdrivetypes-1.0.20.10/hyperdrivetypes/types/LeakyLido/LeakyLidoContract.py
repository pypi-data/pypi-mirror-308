"""A web3.py Contract class for the LeakyLido contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .LeakyLidoTypes import (
    ApprovalEvent,
    AuthorityUpdatedEvent,
    OwnershipTransferredEvent,
    PublicCapabilityUpdatedEvent,
    RoleCapabilityUpdatedEvent,
    TargetCustomAuthorityUpdatedEvent,
    TransferEvent,
    TransferSharesEvent,
    UserRoleUpdatedEvent,
)

structs = {}

leakylido_abi: ABI = cast(
    ABI,
    [
        {"type": "constructor", "inputs": [], "stateMutability": "nonpayable"},
        {
            "type": "function",
            "name": "allowance",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "authority",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {"name": "_owner", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {"name": "amount", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "canCall",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesRoleHaveCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesUserHaveRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBufferedEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPooledEthByShares",
            "inputs": [
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRate",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRolesWithCapability",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSharesByPooledEth",
            "inputs": [
                {
                    "name": "_ethAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTargetCustomAuthority",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalPooledEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalShares",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserRoles",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCapabilityPublic",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCompetitionMode",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isUnrestricted",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "leakyTransferFrom",
            "inputs": [
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "maxMintAmount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setAuthority",
            "inputs": [
                {
                    "name": "newAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setMaxMintAmount",
            "inputs": [
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPublicCapability",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRate",
            "inputs": [
                {"name": "_rate_", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRoleCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setTargetCustomAuthority",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "customAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUnrestrictedMintStatus",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "_status", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sharesOf",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "submit",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transfer",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "newOwner",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferShares",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferSharesFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "spender",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AuthorityUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAuthority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PublicCapabilityUpdated",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RoleCapabilityUpdated",
            "inputs": [
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TargetCustomAuthorityUpdated",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "authority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TransferShares",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "sharesValue",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserRoleUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "error",
            "name": "ERC20InsufficientAllowance",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "allowance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InsufficientBalance",
            "inputs": [
                {
                    "name": "sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "balance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidApprover",
            "inputs": [
                {
                    "name": "approver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidReceiver",
            "inputs": [
                {
                    "name": "receiver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSender",
            "inputs": [
                {"name": "sender", "type": "address", "internalType": "address"}
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSpender",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
    ],
)


class LeakyLidoERC20InsufficientAllowanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientAllowance."""

    # Error name
    name: str = "ERC20InsufficientAllowance"
    # 4 byte error selector
    selector: str = "0xfb8f41b2"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientAllowance(address,uint256,uint256)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InsufficientBalanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientBalance."""

    # Error name
    name: str = "ERC20InsufficientBalance"
    # 4 byte error selector
    selector: str = "0xe450d38c"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientBalance(address,uint256,uint256)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidApproverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidApprover."""

    # Error name
    name: str = "ERC20InvalidApprover"
    # 4 byte error selector
    selector: str = "0xe602df05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidApprover(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidReceiverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidReceiver."""

    # Error name
    name: str = "ERC20InvalidReceiver"
    # 4 byte error selector
    selector: str = "0xec442f05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidReceiver(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidSenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSender."""

    # Error name
    name: str = "ERC20InvalidSender"
    # 4 byte error selector
    selector: str = "0x96c6fd1e"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSender(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidSpenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSpender."""

    # Error name
    name: str = "ERC20InvalidSpender"
    # 4 byte error selector
    selector: str = "0x94280d62"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSpender(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the LeakyLido contract."""

    ERC20InsufficientAllowance: LeakyLidoERC20InsufficientAllowanceContractError

    ERC20InsufficientBalance: LeakyLidoERC20InsufficientBalanceContractError

    ERC20InvalidApprover: LeakyLidoERC20InvalidApproverContractError

    ERC20InvalidReceiver: LeakyLidoERC20InvalidReceiverContractError

    ERC20InvalidSender: LeakyLidoERC20InvalidSenderContractError

    ERC20InvalidSpender: LeakyLidoERC20InvalidSpenderContractError

    def __init__(
        self,
    ) -> None:
        self.ERC20InsufficientAllowance = (
            LeakyLidoERC20InsufficientAllowanceContractError()
        )
        self.ERC20InsufficientBalance = (
            LeakyLidoERC20InsufficientBalanceContractError()
        )
        self.ERC20InvalidApprover = LeakyLidoERC20InvalidApproverContractError()
        self.ERC20InvalidReceiver = LeakyLidoERC20InvalidReceiverContractError()
        self.ERC20InvalidSender = LeakyLidoERC20InvalidSenderContractError()
        self.ERC20InvalidSpender = LeakyLidoERC20InvalidSpenderContractError()

        self._all = [
            self.ERC20InsufficientAllowance,
            self.ERC20InsufficientBalance,
            self.ERC20InvalidApprover,
            self.ERC20InvalidReceiver,
            self.ERC20InvalidSender,
            self.ERC20InvalidSpender,
        ]


class LeakyLidoAllowanceContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowance(str,str) method."""

    _function_name = "allowance"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoAllowanceContractFunction(PypechainContractFunction):
    """ContractFunction for the allowance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str) -> LeakyLidoAllowanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoAllowanceContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoAllowanceContractFunction0._type_signature: LeakyLidoAllowanceContractFunction0.factory(
                "LeakyLidoAllowanceContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoApproveContractFunction0(PypechainContractFunction):
    """ContractFunction for the approve(str,int) method."""

    _function_name = "approve"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoApproveContractFunction(PypechainContractFunction):
    """ContractFunction for the approve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "approve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, spender: str, value: int) -> LeakyLidoApproveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoApproveContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoApproveContractFunction0._type_signature: LeakyLidoApproveContractFunction0.factory(
                "LeakyLidoApproveContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the authority() method."""

    _function_name = "authority"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the authority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "authority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoAuthorityContractFunction0._type_signature: LeakyLidoAuthorityContractFunction0.factory(
                "LeakyLidoAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoBalanceOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the balanceOf(str) method."""

    _function_name = "balanceOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoBalanceOfContractFunction(PypechainContractFunction):
    """ContractFunction for the balanceOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "balanceOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _owner: str) -> LeakyLidoBalanceOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoBalanceOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoBalanceOfContractFunction0._type_signature: LeakyLidoBalanceOfContractFunction0.factory(
                "LeakyLidoBalanceOfContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoBurnContractFunction0(PypechainContractFunction):
    """ContractFunction for the burn(int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoBurnContractFunction1(PypechainContractFunction):
    """ContractFunction for the burn(str,int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoBurnContractFunction(PypechainContractFunction):
    """ContractFunction for the burn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "burn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, amount: int) -> LeakyLidoBurnContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _target: str, _amount: int) -> LeakyLidoBurnContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoBurnContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoBurnContractFunction0._type_signature: LeakyLidoBurnContractFunction0.factory(
                "LeakyLidoBurnContractFunction0", **kwargs
            ),
            LeakyLidoBurnContractFunction1._type_signature: LeakyLidoBurnContractFunction1.factory(
                "LeakyLidoBurnContractFunction1", **kwargs
            ),
        }
        return out


class LeakyLidoCanCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the canCall(str,str,bytes) method."""

    _function_name = "canCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoCanCallContractFunction(PypechainContractFunction):
    """ContractFunction for the canCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "canCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, target: str, functionSig: bytes) -> LeakyLidoCanCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoCanCallContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoCanCallContractFunction0._type_signature: LeakyLidoCanCallContractFunction0.factory(
                "LeakyLidoCanCallContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoDecimalsContractFunction0(PypechainContractFunction):
    """ContractFunction for the decimals() method."""

    _function_name = "decimals"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDecimalsContractFunction(PypechainContractFunction):
    """ContractFunction for the decimals method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "decimals"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoDecimalsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDecimalsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoDecimalsContractFunction0._type_signature: LeakyLidoDecimalsContractFunction0.factory(
                "LeakyLidoDecimalsContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoDoesRoleHaveCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability(int,bytes) method."""

    _function_name = "doesRoleHaveCapability"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDoesRoleHaveCapabilityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesRoleHaveCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes) -> LeakyLidoDoesRoleHaveCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDoesRoleHaveCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoDoesRoleHaveCapabilityContractFunction0._type_signature: LeakyLidoDoesRoleHaveCapabilityContractFunction0.factory(
                "LeakyLidoDoesRoleHaveCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoDoesUserHaveRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole(str,int) method."""

    _function_name = "doesUserHaveRole"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDoesUserHaveRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesUserHaveRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int) -> LeakyLidoDoesUserHaveRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDoesUserHaveRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoDoesUserHaveRoleContractFunction0._type_signature: LeakyLidoDoesUserHaveRoleContractFunction0.factory(
                "LeakyLidoDoesUserHaveRoleContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetBufferedEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBufferedEther() method."""

    _function_name = "getBufferedEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetBufferedEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the getBufferedEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBufferedEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetBufferedEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetBufferedEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetBufferedEtherContractFunction0._type_signature: LeakyLidoGetBufferedEtherContractFunction0.factory(
                "LeakyLidoGetBufferedEtherContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetPooledEthBySharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPooledEthByShares(int) method."""

    _function_name = "getPooledEthByShares"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetPooledEthBySharesContractFunction(PypechainContractFunction):
    """ContractFunction for the getPooledEthByShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPooledEthByShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sharesAmount: int) -> LeakyLidoGetPooledEthBySharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetPooledEthBySharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetPooledEthBySharesContractFunction0._type_signature: LeakyLidoGetPooledEthBySharesContractFunction0.factory(
                "LeakyLidoGetPooledEthBySharesContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRate() method."""

    _function_name = "getRate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the getRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetRateContractFunction0._type_signature: LeakyLidoGetRateContractFunction0.factory(
                "LeakyLidoGetRateContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetRolesWithCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability(bytes) method."""

    _function_name = "getRolesWithCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetRolesWithCapabilityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRolesWithCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> LeakyLidoGetRolesWithCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetRolesWithCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetRolesWithCapabilityContractFunction0._type_signature: LeakyLidoGetRolesWithCapabilityContractFunction0.factory(
                "LeakyLidoGetRolesWithCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetSharesByPooledEthContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSharesByPooledEth(int) method."""

    _function_name = "getSharesByPooledEth"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetSharesByPooledEthContractFunction(PypechainContractFunction):
    """ContractFunction for the getSharesByPooledEth method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSharesByPooledEth"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _ethAmount: int) -> LeakyLidoGetSharesByPooledEthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetSharesByPooledEthContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetSharesByPooledEthContractFunction0._type_signature: LeakyLidoGetSharesByPooledEthContractFunction0.factory(
                "LeakyLidoGetSharesByPooledEthContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority(str) method."""

    _function_name = "getTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoGetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetTargetCustomAuthorityContractFunction0._type_signature: LeakyLidoGetTargetCustomAuthorityContractFunction0.factory(
                "LeakyLidoGetTargetCustomAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetTotalPooledEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalPooledEther() method."""

    _function_name = "getTotalPooledEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTotalPooledEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the getTotalPooledEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalPooledEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetTotalPooledEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTotalPooledEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetTotalPooledEtherContractFunction0._type_signature: LeakyLidoGetTotalPooledEtherContractFunction0.factory(
                "LeakyLidoGetTotalPooledEtherContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetTotalSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalShares() method."""

    _function_name = "getTotalShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTotalSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the getTotalShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetTotalSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTotalSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetTotalSharesContractFunction0._type_signature: LeakyLidoGetTotalSharesContractFunction0.factory(
                "LeakyLidoGetTotalSharesContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoGetUserRolesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserRoles(str) method."""

    _function_name = "getUserRoles"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetUserRolesContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserRoles method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserRoles"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoGetUserRolesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetUserRolesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoGetUserRolesContractFunction0._type_signature: LeakyLidoGetUserRolesContractFunction0.factory(
                "LeakyLidoGetUserRolesContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoIsCapabilityPublicContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCapabilityPublic(bytes) method."""

    _function_name = "isCapabilityPublic"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsCapabilityPublicContractFunction(PypechainContractFunction):
    """ContractFunction for the isCapabilityPublic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCapabilityPublic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> LeakyLidoIsCapabilityPublicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsCapabilityPublicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoIsCapabilityPublicContractFunction0._type_signature: LeakyLidoIsCapabilityPublicContractFunction0.factory(
                "LeakyLidoIsCapabilityPublicContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoIsCompetitionModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode() method."""

    _function_name = "isCompetitionMode"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsCompetitionModeContractFunction(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCompetitionMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoIsCompetitionModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsCompetitionModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoIsCompetitionModeContractFunction0._type_signature: LeakyLidoIsCompetitionModeContractFunction0.factory(
                "LeakyLidoIsCompetitionModeContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoIsUnrestrictedContractFunction0(PypechainContractFunction):
    """ContractFunction for the isUnrestricted(str) method."""

    _function_name = "isUnrestricted"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsUnrestrictedContractFunction(PypechainContractFunction):
    """ContractFunction for the isUnrestricted method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isUnrestricted"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoIsUnrestrictedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsUnrestrictedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoIsUnrestrictedContractFunction0._type_signature: LeakyLidoIsUnrestrictedContractFunction0.factory(
                "LeakyLidoIsUnrestrictedContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoLeakyTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the leakyTransferFrom(str,str,int) method."""

    _function_name = "leakyTransferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoLeakyTransferFromContractFunction(PypechainContractFunction):
    """ContractFunction for the leakyTransferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "leakyTransferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str, amount: int) -> LeakyLidoLeakyTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoLeakyTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoLeakyTransferFromContractFunction0._type_signature: LeakyLidoLeakyTransferFromContractFunction0.factory(
                "LeakyLidoLeakyTransferFromContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxMintAmount() method."""

    _function_name = "maxMintAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the maxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoMaxMintAmountContractFunction0._type_signature: LeakyLidoMaxMintAmountContractFunction0.factory(
                "LeakyLidoMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the mint(str,int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoMintContractFunction1(PypechainContractFunction):
    """ContractFunction for the mint(int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoMintContractFunction(PypechainContractFunction):
    """ContractFunction for the mint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> LeakyLidoMintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _amount: int) -> LeakyLidoMintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoMintContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoMintContractFunction0._type_signature: LeakyLidoMintContractFunction0.factory(
                "LeakyLidoMintContractFunction0", **kwargs
            ),
            LeakyLidoMintContractFunction1._type_signature: LeakyLidoMintContractFunction1.factory(
                "LeakyLidoMintContractFunction1", **kwargs
            ),
        }
        return out


class LeakyLidoNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoNameContractFunction(PypechainContractFunction):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoNameContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoNameContractFunction0._type_signature: LeakyLidoNameContractFunction0.factory(
                "LeakyLidoNameContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoOwnerContractFunction0(PypechainContractFunction):
    """ContractFunction for the owner() method."""

    _function_name = "owner"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoOwnerContractFunction(PypechainContractFunction):
    """ContractFunction for the owner method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "owner"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoOwnerContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoOwnerContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoOwnerContractFunction0._type_signature: LeakyLidoOwnerContractFunction0.factory(
                "LeakyLidoOwnerContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setAuthority(str) method."""

    _function_name = "setAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the setAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newAuthority: str) -> LeakyLidoSetAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetAuthorityContractFunction0._type_signature: LeakyLidoSetAuthorityContractFunction0.factory(
                "LeakyLidoSetAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount(int) method."""

    _function_name = "setMaxMintAmount"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setMaxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _maxMintAmount: int) -> LeakyLidoSetMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetMaxMintAmountContractFunction0._type_signature: LeakyLidoSetMaxMintAmountContractFunction0.factory(
                "LeakyLidoSetMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetPublicCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPublicCapability(bytes,bool) method."""

    _function_name = "setPublicCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bool"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetPublicCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the setPublicCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPublicCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, functionSig: bytes, enabled: bool) -> LeakyLidoSetPublicCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetPublicCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetPublicCapabilityContractFunction0._type_signature: LeakyLidoSetPublicCapabilityContractFunction0.factory(
                "LeakyLidoSetPublicCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRate(int) method."""

    _function_name = "setRate"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the setRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _rate_: int) -> LeakyLidoSetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetRateContractFunction0._type_signature: LeakyLidoSetRateContractFunction0.factory(
                "LeakyLidoSetRateContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetRoleCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRoleCapability(int,bytes,bool) method."""

    _function_name = "setRoleCapability"
    _type_signature = expand_struct_type_str(
        tuple(["int", "bytes", "bool"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetRoleCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the setRoleCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRoleCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes, enabled: bool) -> LeakyLidoSetRoleCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetRoleCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetRoleCapabilityContractFunction0._type_signature: LeakyLidoSetRoleCapabilityContractFunction0.factory(
                "LeakyLidoSetRoleCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority(str,str) method."""

    _function_name = "setTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, customAuthority: str) -> LeakyLidoSetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetTargetCustomAuthorityContractFunction0._type_signature: LeakyLidoSetTargetCustomAuthorityContractFunction0.factory(
                "LeakyLidoSetTargetCustomAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetUnrestrictedMintStatusContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus(str,bool) method."""

    _function_name = "setUnrestrictedMintStatus"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetUnrestrictedMintStatusContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUnrestrictedMintStatus"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _target: str, _status: bool) -> LeakyLidoSetUnrestrictedMintStatusContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetUnrestrictedMintStatusContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetUnrestrictedMintStatusContractFunction0._type_signature: LeakyLidoSetUnrestrictedMintStatusContractFunction0.factory(
                "LeakyLidoSetUnrestrictedMintStatusContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSetUserRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserRole(str,int,bool) method."""

    _function_name = "setUserRole"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetUserRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the setUserRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int, enabled: bool) -> LeakyLidoSetUserRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetUserRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSetUserRoleContractFunction0._type_signature: LeakyLidoSetUserRoleContractFunction0.factory(
                "LeakyLidoSetUserRoleContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSharesOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the sharesOf(str) method."""

    _function_name = "sharesOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSharesOfContractFunction(PypechainContractFunction):
    """ContractFunction for the sharesOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sharesOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoSharesOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSharesOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSharesOfContractFunction0._type_signature: LeakyLidoSharesOfContractFunction0.factory(
                "LeakyLidoSharesOfContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSubmitContractFunction0(PypechainContractFunction):
    """ContractFunction for the submit(str) method."""

    _function_name = "submit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSubmitContractFunction(PypechainContractFunction):
    """ContractFunction for the submit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "submit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoSubmitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSubmitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSubmitContractFunction0._type_signature: LeakyLidoSubmitContractFunction0.factory(
                "LeakyLidoSubmitContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoSymbolContractFunction0(PypechainContractFunction):
    """ContractFunction for the symbol() method."""

    _function_name = "symbol"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSymbolContractFunction(PypechainContractFunction):
    """ContractFunction for the symbol method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "symbol"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoSymbolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSymbolContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoSymbolContractFunction0._type_signature: LeakyLidoSymbolContractFunction0.factory(
                "LeakyLidoSymbolContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTotalSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalSupply() method."""

    _function_name = "totalSupply"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTotalSupplyContractFunction(PypechainContractFunction):
    """ContractFunction for the totalSupply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalSupply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoTotalSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTotalSupplyContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTotalSupplyContractFunction0._type_signature: LeakyLidoTotalSupplyContractFunction0.factory(
                "LeakyLidoTotalSupplyContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the transfer(str,int) method."""

    _function_name = "transfer"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferContractFunction(PypechainContractFunction):
    """ContractFunction for the transfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> LeakyLidoTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTransferContractFunction0._type_signature: LeakyLidoTransferContractFunction0.factory(
                "LeakyLidoTransferContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferFrom(str,str,int) method."""

    _function_name = "transferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferFromContractFunction(PypechainContractFunction):
    """ContractFunction for the transferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _amount: int) -> LeakyLidoTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTransferFromContractFunction0._type_signature: LeakyLidoTransferFromContractFunction0.factory(
                "LeakyLidoTransferFromContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTransferOwnershipContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferOwnership(str) method."""

    _function_name = "transferOwnership"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoTransferOwnershipContractFunction(PypechainContractFunction):
    """ContractFunction for the transferOwnership method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferOwnership"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newOwner: str) -> LeakyLidoTransferOwnershipContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferOwnershipContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTransferOwnershipContractFunction0._type_signature: LeakyLidoTransferOwnershipContractFunction0.factory(
                "LeakyLidoTransferOwnershipContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTransferSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferShares(str,int) method."""

    _function_name = "transferShares"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the transferShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _sharesAmount: int) -> LeakyLidoTransferSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTransferSharesContractFunction0._type_signature: LeakyLidoTransferSharesContractFunction0.factory(
                "LeakyLidoTransferSharesContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoTransferSharesFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferSharesFrom(str,str,int) method."""

    _function_name = "transferSharesFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferSharesFromContractFunction(PypechainContractFunction):
    """ContractFunction for the transferSharesFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferSharesFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _sharesAmount: int) -> LeakyLidoTransferSharesFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferSharesFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            LeakyLidoTransferSharesFromContractFunction0._type_signature: LeakyLidoTransferSharesFromContractFunction0.factory(
                "LeakyLidoTransferSharesFromContractFunction0", **kwargs
            ),
        }
        return out


class LeakyLidoContractFunctions(ContractFunctions):
    """ContractFunctions for the LeakyLido contract."""

    allowance: LeakyLidoAllowanceContractFunction

    approve: LeakyLidoApproveContractFunction

    authority: LeakyLidoAuthorityContractFunction

    balanceOf: LeakyLidoBalanceOfContractFunction

    burn: LeakyLidoBurnContractFunction

    canCall: LeakyLidoCanCallContractFunction

    decimals: LeakyLidoDecimalsContractFunction

    doesRoleHaveCapability: LeakyLidoDoesRoleHaveCapabilityContractFunction

    doesUserHaveRole: LeakyLidoDoesUserHaveRoleContractFunction

    getBufferedEther: LeakyLidoGetBufferedEtherContractFunction

    getPooledEthByShares: LeakyLidoGetPooledEthBySharesContractFunction

    getRate: LeakyLidoGetRateContractFunction

    getRolesWithCapability: LeakyLidoGetRolesWithCapabilityContractFunction

    getSharesByPooledEth: LeakyLidoGetSharesByPooledEthContractFunction

    getTargetCustomAuthority: LeakyLidoGetTargetCustomAuthorityContractFunction

    getTotalPooledEther: LeakyLidoGetTotalPooledEtherContractFunction

    getTotalShares: LeakyLidoGetTotalSharesContractFunction

    getUserRoles: LeakyLidoGetUserRolesContractFunction

    isCapabilityPublic: LeakyLidoIsCapabilityPublicContractFunction

    isCompetitionMode: LeakyLidoIsCompetitionModeContractFunction

    isUnrestricted: LeakyLidoIsUnrestrictedContractFunction

    leakyTransferFrom: LeakyLidoLeakyTransferFromContractFunction

    maxMintAmount: LeakyLidoMaxMintAmountContractFunction

    mint: LeakyLidoMintContractFunction

    name: LeakyLidoNameContractFunction

    owner: LeakyLidoOwnerContractFunction

    setAuthority: LeakyLidoSetAuthorityContractFunction

    setMaxMintAmount: LeakyLidoSetMaxMintAmountContractFunction

    setPublicCapability: LeakyLidoSetPublicCapabilityContractFunction

    setRate: LeakyLidoSetRateContractFunction

    setRoleCapability: LeakyLidoSetRoleCapabilityContractFunction

    setTargetCustomAuthority: LeakyLidoSetTargetCustomAuthorityContractFunction

    setUnrestrictedMintStatus: (
        LeakyLidoSetUnrestrictedMintStatusContractFunction
    )

    setUserRole: LeakyLidoSetUserRoleContractFunction

    sharesOf: LeakyLidoSharesOfContractFunction

    submit: LeakyLidoSubmitContractFunction

    symbol: LeakyLidoSymbolContractFunction

    totalSupply: LeakyLidoTotalSupplyContractFunction

    transfer: LeakyLidoTransferContractFunction

    transferFrom: LeakyLidoTransferFromContractFunction

    transferOwnership: LeakyLidoTransferOwnershipContractFunction

    transferShares: LeakyLidoTransferSharesContractFunction

    transferSharesFrom: LeakyLidoTransferSharesFromContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.allowance = LeakyLidoAllowanceContractFunction.factory(
            "allowance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowance",
        )
        self.approve = LeakyLidoApproveContractFunction.factory(
            "approve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="approve",
        )
        self.authority = LeakyLidoAuthorityContractFunction.factory(
            "authority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="authority",
        )
        self.balanceOf = LeakyLidoBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="balanceOf",
        )
        self.burn = LeakyLidoBurnContractFunction.factory(
            "burn",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="burn",
        )
        self.canCall = LeakyLidoCanCallContractFunction.factory(
            "canCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="canCall",
        )
        self.decimals = LeakyLidoDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="decimals",
        )
        self.doesRoleHaveCapability = (
            LeakyLidoDoesRoleHaveCapabilityContractFunction.factory(
                "doesRoleHaveCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesRoleHaveCapability",
            )
        )
        self.doesUserHaveRole = (
            LeakyLidoDoesUserHaveRoleContractFunction.factory(
                "doesUserHaveRole",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesUserHaveRole",
            )
        )
        self.getBufferedEther = (
            LeakyLidoGetBufferedEtherContractFunction.factory(
                "getBufferedEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getBufferedEther",
            )
        )
        self.getPooledEthByShares = (
            LeakyLidoGetPooledEthBySharesContractFunction.factory(
                "getPooledEthByShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPooledEthByShares",
            )
        )
        self.getRate = LeakyLidoGetRateContractFunction.factory(
            "getRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRate",
        )
        self.getRolesWithCapability = (
            LeakyLidoGetRolesWithCapabilityContractFunction.factory(
                "getRolesWithCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getRolesWithCapability",
            )
        )
        self.getSharesByPooledEth = (
            LeakyLidoGetSharesByPooledEthContractFunction.factory(
                "getSharesByPooledEth",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getSharesByPooledEth",
            )
        )
        self.getTargetCustomAuthority = (
            LeakyLidoGetTargetCustomAuthorityContractFunction.factory(
                "getTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTargetCustomAuthority",
            )
        )
        self.getTotalPooledEther = (
            LeakyLidoGetTotalPooledEtherContractFunction.factory(
                "getTotalPooledEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTotalPooledEther",
            )
        )
        self.getTotalShares = LeakyLidoGetTotalSharesContractFunction.factory(
            "getTotalShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getTotalShares",
        )
        self.getUserRoles = LeakyLidoGetUserRolesContractFunction.factory(
            "getUserRoles",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserRoles",
        )
        self.isCapabilityPublic = (
            LeakyLidoIsCapabilityPublicContractFunction.factory(
                "isCapabilityPublic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCapabilityPublic",
            )
        )
        self.isCompetitionMode = (
            LeakyLidoIsCompetitionModeContractFunction.factory(
                "isCompetitionMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCompetitionMode",
            )
        )
        self.isUnrestricted = LeakyLidoIsUnrestrictedContractFunction.factory(
            "isUnrestricted",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isUnrestricted",
        )
        self.leakyTransferFrom = (
            LeakyLidoLeakyTransferFromContractFunction.factory(
                "leakyTransferFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="leakyTransferFrom",
            )
        )
        self.maxMintAmount = LeakyLidoMaxMintAmountContractFunction.factory(
            "maxMintAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxMintAmount",
        )
        self.mint = LeakyLidoMintContractFunction.factory(
            "mint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mint",
        )
        self.name = LeakyLidoNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.owner = LeakyLidoOwnerContractFunction.factory(
            "owner",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="owner",
        )
        self.setAuthority = LeakyLidoSetAuthorityContractFunction.factory(
            "setAuthority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setAuthority",
        )
        self.setMaxMintAmount = (
            LeakyLidoSetMaxMintAmountContractFunction.factory(
                "setMaxMintAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setMaxMintAmount",
            )
        )
        self.setPublicCapability = (
            LeakyLidoSetPublicCapabilityContractFunction.factory(
                "setPublicCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPublicCapability",
            )
        )
        self.setRate = LeakyLidoSetRateContractFunction.factory(
            "setRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setRate",
        )
        self.setRoleCapability = (
            LeakyLidoSetRoleCapabilityContractFunction.factory(
                "setRoleCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setRoleCapability",
            )
        )
        self.setTargetCustomAuthority = (
            LeakyLidoSetTargetCustomAuthorityContractFunction.factory(
                "setTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setTargetCustomAuthority",
            )
        )
        self.setUnrestrictedMintStatus = (
            LeakyLidoSetUnrestrictedMintStatusContractFunction.factory(
                "setUnrestrictedMintStatus",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUnrestrictedMintStatus",
            )
        )
        self.setUserRole = LeakyLidoSetUserRoleContractFunction.factory(
            "setUserRole",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserRole",
        )
        self.sharesOf = LeakyLidoSharesOfContractFunction.factory(
            "sharesOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sharesOf",
        )
        self.submit = LeakyLidoSubmitContractFunction.factory(
            "submit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="submit",
        )
        self.symbol = LeakyLidoSymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="symbol",
        )
        self.totalSupply = LeakyLidoTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalSupply",
        )
        self.transfer = LeakyLidoTransferContractFunction.factory(
            "transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transfer",
        )
        self.transferFrom = LeakyLidoTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferFrom",
        )
        self.transferOwnership = (
            LeakyLidoTransferOwnershipContractFunction.factory(
                "transferOwnership",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferOwnership",
            )
        )
        self.transferShares = LeakyLidoTransferSharesContractFunction.factory(
            "transferShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferShares",
        )
        self.transferSharesFrom = (
            LeakyLidoTransferSharesFromContractFunction.factory(
                "transferSharesFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferSharesFrom",
            )
        )


class LeakyLidoApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ApprovalEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ApprovalEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for AuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoOwnershipTransferredContractEvent(ContractEvent):
    """ContractEvent for OwnershipTransferred."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoPublicCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for PublicCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoRoleCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for RoleCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTargetCustomAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for TargetCustomAuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTransferContractEvent(ContractEvent):
    """ContractEvent for Transfer."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTransferSharesContractEvent(ContractEvent):
    """ContractEvent for TransferShares."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoUserRoleUpdatedContractEvent(ContractEvent):
    """ContractEvent for UserRoleUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoContractEvents(ContractEvents):
    """ContractEvents for the LeakyLido contract."""

    Approval: Type[LeakyLidoApprovalContractEvent]

    AuthorityUpdated: Type[LeakyLidoAuthorityUpdatedContractEvent]

    OwnershipTransferred: Type[LeakyLidoOwnershipTransferredContractEvent]

    PublicCapabilityUpdated: Type[LeakyLidoPublicCapabilityUpdatedContractEvent]

    RoleCapabilityUpdated: Type[LeakyLidoRoleCapabilityUpdatedContractEvent]

    TargetCustomAuthorityUpdated: Type[
        LeakyLidoTargetCustomAuthorityUpdatedContractEvent
    ]

    Transfer: Type[LeakyLidoTransferContractEvent]

    TransferShares: Type[LeakyLidoTransferSharesContractEvent]

    UserRoleUpdated: Type[LeakyLidoUserRoleUpdatedContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.Approval = cast(
            Type[LeakyLidoApprovalContractEvent],
            LeakyLidoApprovalContractEvent.factory(
                "Approval",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Approval",
            ),
        )
        self.AuthorityUpdated = cast(
            Type[LeakyLidoAuthorityUpdatedContractEvent],
            LeakyLidoAuthorityUpdatedContractEvent.factory(
                "AuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AuthorityUpdated",
            ),
        )
        self.OwnershipTransferred = cast(
            Type[LeakyLidoOwnershipTransferredContractEvent],
            LeakyLidoOwnershipTransferredContractEvent.factory(
                "OwnershipTransferred",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OwnershipTransferred",
            ),
        )
        self.PublicCapabilityUpdated = cast(
            Type[LeakyLidoPublicCapabilityUpdatedContractEvent],
            LeakyLidoPublicCapabilityUpdatedContractEvent.factory(
                "PublicCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PublicCapabilityUpdated",
            ),
        )
        self.RoleCapabilityUpdated = cast(
            Type[LeakyLidoRoleCapabilityUpdatedContractEvent],
            LeakyLidoRoleCapabilityUpdatedContractEvent.factory(
                "RoleCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RoleCapabilityUpdated",
            ),
        )
        self.TargetCustomAuthorityUpdated = cast(
            Type[LeakyLidoTargetCustomAuthorityUpdatedContractEvent],
            LeakyLidoTargetCustomAuthorityUpdatedContractEvent.factory(
                "TargetCustomAuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TargetCustomAuthorityUpdated",
            ),
        )
        self.Transfer = cast(
            Type[LeakyLidoTransferContractEvent],
            LeakyLidoTransferContractEvent.factory(
                "Transfer",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Transfer",
            ),
        )
        self.TransferShares = cast(
            Type[LeakyLidoTransferSharesContractEvent],
            LeakyLidoTransferSharesContractEvent.factory(
                "TransferShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TransferShares",
            ),
        )
        self.UserRoleUpdated = cast(
            Type[LeakyLidoUserRoleUpdatedContractEvent],
            LeakyLidoUserRoleUpdatedContractEvent.factory(
                "UserRoleUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="UserRoleUpdated",
            ),
        )


class LeakyLidoContract(Contract):
    """A web3.py Contract class for the LeakyLido contract."""

    abi: ABI = leakylido_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x60a06040523480156200001157600080fd5b50604080518082018252601781527f4c6971756964207374616b656420457468657220322e300000000000000000006020808301919091528251808401845260058152640e6e88aa8960db1b91810191909152600080546001600160a01b0319908116825560018054309216821790559351909384938493600019939192909185919082908290829033907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a35050505081600990816200010c9190620001de565b50600a6200011b8282620001de565b505050600d9390935542600e55151560805250600b55620002aa565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200016257607f821691505b6020821081036200018357634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620001d9576000816000526020600020601f850160051c81016020861015620001b45750805b601f850160051c820191505b81811015620001d557828155600101620001c0565b5050505b505050565b81516001600160401b03811115620001fa57620001fa62000137565b62000212816200020b84546200014d565b8462000189565b602080601f8311600181146200024a5760008415620002315750858301515b600019600386901b1c1916600185901b178555620001d5565b600085815260208120601f198616915b828110156200027b578886015182559484019460019091019084016200025a565b50858210156200029a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b608051611f4e620002f760003960008181610592015281816108d8015281816109f601528181610bf001528181610c7101528181610cd70152818161117801526111da0152611f4e6000f3fe6080604052600436106102725760003560e01c8063728b952b1161014f578063aed30777116100c1578063dd62ed3e1161007a578063dd62ed3e1461078f578063e688747b146107d5578063ea7ca27614610818578063ed0d0efb1461085c578063f2fde38b14610889578063f5eb42dc146108a957600080fd5b8063aed30777146106b4578063b7009613146106e4578063bf7e214f14610704578063c51ea9cc14610724578063c53a398514610744578063d5002f2e1461077a57600080fd5b80638fcb4e5b116101135780638fcb4e5b1461060c57806395d89b411461062c5780639dc29fac14610641578063a0712d6814610661578063a1903eab14610681578063a9059cbb1461069457600080fd5b8063728b952b146105405780637a28fb88146105605780637a8c63b5146105805780637a9e5e4b146105b45780638da5cb5b146105d457600080fd5b8063313ce567116101e857806347b714e0116101ac57806347b714e0146104975780634b5159da146104ab578063679aefce146104cb57806367aff484146104e05780636d7804591461050057806370a082311461052057600080fd5b8063313ce5671461040657806334fcf4371461042257806337cfdaca1461044257806340c10f191461045757806342966c681461047757600080fd5b80630bade8a41161023a5780630bade8a41461034b5780630ea9b75b1461037b57806318160ddd1461039b57806319208451146103b0578063239c70ae146103d057806323b872dd146103e657600080fd5b806305f05a941461027757806306a36aee1461029957806306fdde03146102d9578063088a4ed0146102fb578063095ea7b31461031b575b600080fd5b34801561028357600080fd5b50610297610292366004611ae2565b6108d6565b005b3480156102a557600080fd5b506102c66102b4366004611b1b565b60036020526000908152604090205481565b6040519081526020015b60405180910390f35b3480156102e557600080fd5b506102ee610962565b6040516102d09190611b38565b34801561030757600080fd5b50610297610316366004611b87565b6109f4565b34801561032757600080fd5b5061033b610336366004611ba0565b610a51565b60405190151581526020016102d0565b34801561035757600080fd5b5061033b610366366004611be9565b60046020526000908152604090205460ff1681565b34801561038757600080fd5b50610297610396366004611c15565b610a6b565b3480156103a757600080fd5b506008546102c6565b3480156103bc57600080fd5b506102c66103cb366004611b87565b610b43565b3480156103dc57600080fd5b506102c6600b5481565b3480156103f257600080fd5b5061033b610401366004611c5c565b610b61565b34801561041257600080fd5b50604051601281526020016102d0565b34801561042e57600080fd5b5061029761043d366004611b87565b610bee565b34801561044e57600080fd5b506102c6610c53565b34801561046357600080fd5b50610297610472366004611ba0565b610c6f565b34801561048357600080fd5b50610297610492366004611b87565b610cd5565b3480156104a357600080fd5b5060006102c6565b3480156104b757600080fd5b506102976104c6366004611c9d565b610d3a565b3480156104d757600080fd5b50600d546102c6565b3480156104ec57600080fd5b506102976104fb366004611cb9565b610dcc565b34801561050c57600080fd5b506102c661051b366004611c5c565b610e94565b34801561052c57600080fd5b506102c661053b366004611b1b565b610f2b565b34801561054c57600080fd5b5061029761055b366004611ce7565b610f4d565b34801561056c57600080fd5b506102c661057b366004611b87565b610fd6565b34801561058c57600080fd5b5061033b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156105c057600080fd5b506102976105cf366004611b1b565b610feb565b3480156105e057600080fd5b506000546105f4906001600160a01b031681565b6040516001600160a01b0390911681526020016102d0565b34801561061857600080fd5b506102c6610627366004611ba0565b6110d5565b34801561063857600080fd5b506102ee611167565b34801561064d57600080fd5b5061029761065c366004611ba0565b611176565b34801561066d57600080fd5b5061029761067c366004611b87565b6111d8565b6102c661068f366004611b1b565b61123a565b3480156106a057600080fd5b5061033b6106af366004611ba0565b6112ff565b3480156106c057600080fd5b5061033b6106cf366004611b1b565b600c6020526000908152604090205460ff1681565b3480156106f057600080fd5b5061033b6106ff366004611d15565b611387565b34801561071057600080fd5b506001546105f4906001600160a01b031681565b34801561073057600080fd5b5061033b61073f366004611c5c565b611485565b34801561075057600080fd5b506105f461075f366004611b1b565b6002602052600090815260409020546001600160a01b031681565b34801561078657600080fd5b506010546102c6565b34801561079b57600080fd5b506102c66107aa366004611ce7565b6001600160a01b03918216600090815260076020908152604080832093909416825291909152205490565b3480156107e157600080fd5b5061033b6107f0366004611d5c565b6001600160e01b03191660009081526005602052604090205460ff919091161c600116151590565b34801561082457600080fd5b5061033b610833366004611d8f565b6001600160a01b0391909116600090815260036020526040902054600160ff9092161c16151590565b34801561086857600080fd5b506102c6610877366004611be9565b60056020526000908152604090205481565b34801561089557600080fd5b506102976108a4366004611b1b565b611525565b3480156108b557600080fd5b506102c66108c4366004611b1b565b60116020526000908152604090205481565b7f00000000000000000000000000000000000000000000000000000000000000001561093757610912336000356001600160e01b0319166115a2565b6109375760405162461bcd60e51b815260040161092e90611dbb565b60405180910390fd5b6001600160a01b03919091166000908152600c60205260409020805460ff1916911515919091179055565b60606009805461097190611df2565b80601f016020809104026020016040519081016040528092919081815260200182805461099d90611df2565b80156109ea5780601f106109bf576101008083540402835291602001916109ea565b820191906000526020600020905b8154815290600101906020018083116109cd57829003601f168201915b5050505050905090565b7f000000000000000000000000000000000000000000000000000000000000000015610a4c57610a30336000356001600160e01b0319166115a2565b610a4c5760405162461bcd60e51b815260040161092e90611dbb565b600b55565b600033610a5f81858561164c565b60019150505b92915050565b610a81336000356001600160e01b0319166115a2565b610a9d5760405162461bcd60e51b815260040161092e90611e2c565b8015610acd576001600160e01b0319821660009081526005602052604090208054600160ff86161b179055610af4565b6001600160e01b0319821660009081526005602052604090208054600160ff86161b191690555b816001600160e01b0319168360ff167fbfe16b2c35ce23dfd1ab0e7b5d086a10060c9b52d1574e1680c881b3b3a2b15183604051610b36911515815260200190565b60405180910390a3505050565b6000610a65610b5160105490565b610b59610c53565b84919061165e565b6000610b6b61167c565b6000610b7683610b43565b9050610b838585836116ad565b506040518381526001600160a01b038516903390600080516020611ef98339815191529060200160405180910390a36040518181526001600160a01b038516903390600080516020611ed9833981519152906020015b60405180910390a360019150505b9392505050565b7f000000000000000000000000000000000000000000000000000000000000000015610c4657610c2a336000356001600160e01b0319166115a2565b610c465760405162461bcd60e51b815260040161092e90611dbb565b610c4e61167c565b600d55565b6000610c5d611729565b600f54610c6a9190611e68565b905090565b7f000000000000000000000000000000000000000000000000000000000000000015610cc757610cab336000356001600160e01b0319166115a2565b610cc75760405162461bcd60e51b815260040161092e90611dbb565b610cd1828261178e565b5050565b7f000000000000000000000000000000000000000000000000000000000000000015610d2d57610d11336000356001600160e01b0319166115a2565b610d2d5760405162461bcd60e51b815260040161092e90611dbb565b610d373382611880565b50565b610d50336000356001600160e01b0319166115a2565b610d6c5760405162461bcd60e51b815260040161092e90611e2c565b6001600160e01b03198216600081815260046020908152604091829020805460ff191685151590811790915591519182527f36d28126bef21a4f3765d7fcb7c45cead463ae4c41094ef3b771ede598544103910160405180910390a25050565b610de2336000356001600160e01b0319166115a2565b610dfe5760405162461bcd60e51b815260040161092e90611e2c565b8015610e2d576001600160a01b03831660009081526003602052604090208054600160ff85161b179055610e53565b6001600160a01b03831660009081526003602052604090208054600160ff85161b191690555b8160ff16836001600160a01b03167f4c9bdd0c8e073eb5eda2250b18d8e5121ff27b62064fbeeeed4869bb99bc5bf283604051610b36911515815260200190565b6000610e9e61167c565b6000610eab8585856116ad565b9050836001600160a01b0316856001600160a01b0316600080516020611ef983398151915283604051610ee091815260200190565b60405180910390a3836001600160a01b0316856001600160a01b0316600080516020611ed983398151915285604051610f1b91815260200190565b60405180910390a3949350505050565b6001600160a01b038116600090815260116020526040812054610a6590610fd6565b610f63336000356001600160e01b0319166115a2565b610f7f5760405162461bcd60e51b815260040161092e90611e2c565b6001600160a01b0382811660008181526002602052604080822080546001600160a01b0319169486169485179055517fa4908e11a5f895b13d51526c331ac93cdd30e59772361c5d07874eb36bff20659190a35050565b6000610a65610fe3610c53565b601054610b59565b6000546001600160a01b0316331480611080575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061103f90339030906001600160e01b03196000351690600401611e7b565b602060405180830381865afa15801561105c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110809190611ea8565b61108957600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b60006110df61167c565b60006110eb84846118ea565b9050836001600160a01b0316336001600160a01b0316600080516020611ef98339815191528360405161112091815260200190565b60405180910390a36040518381526001600160a01b038516903390600080516020611ed98339815191529060200160405180910390a361115f83610fd6565b949350505050565b6060600a805461097190611df2565b7f0000000000000000000000000000000000000000000000000000000000000000156111ce576111b2336000356001600160e01b0319166115a2565b6111ce5760405162461bcd60e51b815260040161092e90611dbb565b610cd18282611880565b7f00000000000000000000000000000000000000000000000000000000000000001561123057611214336000356001600160e01b0319166115a2565b6112305760405162461bcd60e51b815260040161092e90611dbb565b610d37338261178e565b600061124461167c565b60105460000361128457346010819055600f8190553360009081526011602052604081208054909190611278908490611e68565b90915550349392505050565b60006112a261129260105490565b61129a610c53565b34919061165e565b905034600f60008282546112b69190611e68565b9250508190555080601060008282546112cf9190611e68565b909155505033600090815260116020526040812080548392906112f3908490611e68565b90915550909392505050565b600061130961167c565b600061131483610b43565b905061132084826118ea565b506040518381526001600160a01b038516903390600080516020611ef98339815191529060200160405180910390a36040518181526001600160a01b038516903390600080516020611ed98339815191529060200160405180910390a35060019392505050565b6001600160a01b0380831660009081526002602052604081205490911680156114235760405163b700961360e01b81526001600160a01b0382169063b7009613906113da90889088908890600401611e7b565b602060405180830381865afa1580156113f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061141b9190611ea8565b915050610be7565b6001600160e01b0319831660009081526004602052604090205460ff168061147c57506001600160e01b031983166000908152600560209081526040808320546001600160a01b03891684526003909252909120541615155b95945050505050565b60008061149183610b43565b6001600160a01b0386166000908152601160205260408120805492935083929091906114be908490611ec5565b90915550506001600160a01b038416600090815260116020526040812080548392906114eb908490611e68565b92505081905550836001600160a01b0316856001600160a01b0316600080516020611ef983398151915285604051610bd991815260200190565b61153b336000356001600160e01b0319166115a2565b6115575760405162461bcd60e51b815260040161092e90611e2c565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b6001546000906001600160a01b0316801580159061162c575060405163b700961360e01b81526001600160a01b0382169063b7009613906115eb90879030908890600401611e7b565b602060405180830381865afa158015611608573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061162c9190611ea8565b8061115f57506000546001600160a01b0385811691161491505092915050565b6116598383836001611947565b505050565b600082600019048411830215820261167557600080fd5b5091020490565b6000611686611729565b905080156116a65780600f60008282546116a09190611e68565b90915550505b5042600e55565b6000806116b983610fd6565b90506116c6853383611a1d565b6001600160a01b038516600090815260116020526040812080548592906116ee908490611ec5565b90915550506001600160a01b0384166000908152601160205260408120805485929061171b908490611e68565b909155509095945050505050565b6000600d5460000361173b5750600090565b600e5442101561174b5750600090565b60006117696301e13380600e54426117639190611ec5565b90611a95565b90506000610be761178583600d54611aaa90919063ffffffff16565b600f5490611aaa565b336000908152600c602052604090205460ff166117f757600b548111156117f75760405162461bcd60e51b815260206004820152601d60248201527f4d6f636b4c69646f3a20496e76616c6964206d696e7420616d6f756e74000000604482015260640161092e565b600061180260105490565b60000361181057508061181c565b61181982610b43565b90505b6001600160a01b03831660009081526011602052604081208054839290611844908490611e68565b9250508190555081600f600082825461185d9190611e68565b9250508190555080601060008282546118769190611e68565b9091555050505050565b600061188b82610b43565b6001600160a01b0384166000908152601160205260408120805492935083929091906118b8908490611ec5565b9250508190555081600f60008282546118d19190611ec5565b9250508190555080601060008282546118769190611ec5565b3360009081526011602052604081208054839190839061190b908490611ec5565b90915550506001600160a01b03831660009081526011602052604081208054849290611938908490611e68565b90915550610be7905082610fd6565b6001600160a01b0384166119715760405163e602df0560e01b81526000600482015260240161092e565b6001600160a01b03831661199b57604051634a1406b160e11b81526000600482015260240161092e565b6001600160a01b0380851660009081526007602090815260408083209387168352929052208290558015611a1757826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051611a0e91815260200190565b60405180910390a35b50505050565b6001600160a01b038381166000908152600760209081526040808320938616835292905220546000198114611a175781811015611a8657604051637dc7a0d960e11b81526001600160a01b0384166004820152602481018290526044810183905260640161092e565b611a1784848484036000611947565b6000610be783670de0b6b3a76400008461165e565b6000610be78383670de0b6b3a764000061165e565b6001600160a01b0381168114610d3757600080fd5b8015158114610d3757600080fd5b60008060408385031215611af557600080fd5b8235611b0081611abf565b91506020830135611b1081611ad4565b809150509250929050565b600060208284031215611b2d57600080fd5b8135610be781611abf565b60006020808352835180602085015260005b81811015611b6657858101830151858201604001528201611b4a565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215611b9957600080fd5b5035919050565b60008060408385031215611bb357600080fd5b8235611bbe81611abf565b946020939093013593505050565b80356001600160e01b031981168114611be457600080fd5b919050565b600060208284031215611bfb57600080fd5b610be782611bcc565b803560ff81168114611be457600080fd5b600080600060608486031215611c2a57600080fd5b611c3384611c04565b9250611c4160208501611bcc565b91506040840135611c5181611ad4565b809150509250925092565b600080600060608486031215611c7157600080fd5b8335611c7c81611abf565b92506020840135611c8c81611abf565b929592945050506040919091013590565b60008060408385031215611cb057600080fd5b611b0083611bcc565b600080600060608486031215611cce57600080fd5b8335611cd981611abf565b9250611c4160208501611c04565b60008060408385031215611cfa57600080fd5b8235611d0581611abf565b91506020830135611b1081611abf565b600080600060608486031215611d2a57600080fd5b8335611d3581611abf565b92506020840135611d4581611abf565b9150611d5360408501611bcc565b90509250925092565b60008060408385031215611d6f57600080fd5b611d7883611c04565b9150611d8660208401611bcc565b90509250929050565b60008060408385031215611da257600080fd5b8235611dad81611abf565b9150611d8660208401611c04565b60208082526018908201527f4d6f636b4c69646f3a206e6f7420617574686f72697a65640000000000000000604082015260600190565b600181811c90821680611e0657607f821691505b602082108103611e2657634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a6557610a65611e52565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b600060208284031215611eba57600080fd5b8151610be781611ad4565b81810381811115610a6557610a65611e5256fe9d9c909296d9c674451c0c24f02cb64981eb3b727f99865939192f880a755dcbddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220ad62e00377262ddf922b5c396a0d55b857c17eddf3eba2290e370562511a132664736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = LeakyLidoContractFunctions(leakylido_abi, self.w3, address)  # type: ignore
        self.events = LeakyLidoContractEvents(leakylido_abi, self.w3, address)  # type: ignore
        self.errors = LeakyLidoContractErrors()

    events: LeakyLidoContractEvents

    errors: LeakyLidoContractErrors = LeakyLidoContractErrors()

    functions: LeakyLidoContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = LeakyLidoContractFunctions(leakylido_abi, w3, None)
        contract.errors = LeakyLidoContractErrors()

        return contract
