"""A web3.py Contract class for the YieldSpaceMathTest contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..LPMath import LPMathContract
from ..StdInvariant import StdInvariantTypes as StdInvariant
from .YieldSpaceMathTestTypes import (
    Log_addressEvent,
    Log_arrayEvent,
    Log_bytes32Event,
    Log_bytesEvent,
    Log_intEvent,
    Log_named_addressEvent,
    Log_named_arrayEvent,
    Log_named_bytes32Event,
    Log_named_bytesEvent,
    Log_named_decimal_intEvent,
    Log_named_decimal_uintEvent,
    Log_named_intEvent,
    Log_named_stringEvent,
    Log_named_uintEvent,
    Log_stringEvent,
    Log_uintEvent,
    LogEvent,
    LogsEvent,
)

structs = {
    "StdInvariant.FuzzSelector": StdInvariant.FuzzSelector,
    "StdInvariant.FuzzInterface": StdInvariant.FuzzInterface,
}

yieldspacemathtest_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "IS_TEST",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "failed",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifactSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifactSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetInterfaces",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedInterfaces_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzInterface[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "artifacts",
                            "type": "string[]",
                            "internalType": "string[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "test__calculateBondsOutGivenSharesInDown__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateMaxBuy",
            "inputs": [
                {
                    "name": "fixedRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "shareReserves",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "vaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "initialVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateOutGivenIn",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOut",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOutDown__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOutUp__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOut__extremeValues",
            "inputs": [
                {
                    "name": "fixedRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "shareReserves",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "vaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "initialVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "tradeSize",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "log",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_address",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes32",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_int",
            "inputs": [
                {
                    "name": "",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_address",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes32",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_string",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_string",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_uint",
            "inputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "logs",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "ExpInvalidExponent", "inputs": []},
        {"type": "error", "name": "InsufficientLiquidity", "inputs": []},
        {"type": "error", "name": "LnInvalidInput", "inputs": []},
        {"type": "error", "name": "UnsafeCastToInt256", "inputs": []},
    ],
)


class YieldSpaceMathTestExpInvalidExponentContractError(PypechainBaseError):
    """ContractError for ExpInvalidExponent."""

    # Error name
    name: str = "ExpInvalidExponent"
    # 4 byte error selector
    selector: str = "0x73a2d6b1"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ExpInvalidExponent()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestInsufficientLiquidityContractError(PypechainBaseError):
    """ContractError for InsufficientLiquidity."""

    # Error name
    name: str = "InsufficientLiquidity"
    # 4 byte error selector
    selector: str = "0xbb55fd27"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InsufficientLiquidity()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestLnInvalidInputContractError(PypechainBaseError):
    """ContractError for LnInvalidInput."""

    # Error name
    name: str = "LnInvalidInput"
    # 4 byte error selector
    selector: str = "0xe61b4975"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "LnInvalidInput()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestUnsafeCastToInt256ContractError(PypechainBaseError):
    """ContractError for UnsafeCastToInt256."""

    # Error name
    name: str = "UnsafeCastToInt256"
    # 4 byte error selector
    selector: str = "0x72dd4e02"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "UnsafeCastToInt256()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the YieldSpaceMathTest contract."""

    ExpInvalidExponent: YieldSpaceMathTestExpInvalidExponentContractError

    InsufficientLiquidity: YieldSpaceMathTestInsufficientLiquidityContractError

    LnInvalidInput: YieldSpaceMathTestLnInvalidInputContractError

    UnsafeCastToInt256: YieldSpaceMathTestUnsafeCastToInt256ContractError

    def __init__(
        self,
    ) -> None:
        self.ExpInvalidExponent = (
            YieldSpaceMathTestExpInvalidExponentContractError()
        )
        self.InsufficientLiquidity = (
            YieldSpaceMathTestInsufficientLiquidityContractError()
        )
        self.LnInvalidInput = YieldSpaceMathTestLnInvalidInputContractError()
        self.UnsafeCastToInt256 = (
            YieldSpaceMathTestUnsafeCastToInt256ContractError()
        )

        self._all = [
            self.ExpInvalidExponent,
            self.InsufficientLiquidity,
            self.LnInvalidInput,
            self.UnsafeCastToInt256,
        ]


class YieldSpaceMathTestIS_TESTContractFunction0(PypechainContractFunction):
    """ContractFunction for the IS_TEST() method."""

    _function_name = "IS_TEST"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestIS_TESTContractFunction(PypechainContractFunction):
    """ContractFunction for the IS_TEST method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "IS_TEST"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestIS_TESTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestIS_TESTContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestIS_TESTContractFunction0._type_signature: YieldSpaceMathTestIS_TESTContractFunction0.factory(
                "YieldSpaceMathTestIS_TESTContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestExcludeArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts() method."""

    _function_name = "excludeArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeArtifactsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeArtifactsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestExcludeArtifactsContractFunction0._type_signature: YieldSpaceMathTestExcludeArtifactsContractFunction0.factory(
                "YieldSpaceMathTestExcludeArtifactsContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestExcludeContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts() method."""

    _function_name = "excludeContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeContractsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeContractsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestExcludeContractsContractFunction0._type_signature: YieldSpaceMathTestExcludeContractsContractFunction0.factory(
                "YieldSpaceMathTestExcludeContractsContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestExcludeSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders() method."""

    _function_name = "excludeSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeSendersContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeSendersContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestExcludeSendersContractFunction0._type_signature: YieldSpaceMathTestExcludeSendersContractFunction0.factory(
                "YieldSpaceMathTestExcludeSendersContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestFailedContractFunction0(PypechainContractFunction):
    """ContractFunction for the failed() method."""

    _function_name = "failed"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestFailedContractFunction(PypechainContractFunction):
    """ContractFunction for the failed method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "failed"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestFailedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestFailedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestFailedContractFunction0._type_signature: YieldSpaceMathTestFailedContractFunction0.factory(
                "YieldSpaceMathTestFailedContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTargetArtifactSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors() method."""

    _function_name = "targetArtifactSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetArtifactSelectorsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifactSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetArtifactSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetArtifactSelectorsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetArtifactSelectorsContractFunction0._type_signature: YieldSpaceMathTestTargetArtifactSelectorsContractFunction0.factory(
                "YieldSpaceMathTestTargetArtifactSelectorsContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTargetArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts() method."""

    _function_name = "targetArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetArtifactsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetArtifactsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetArtifactsContractFunction0._type_signature: YieldSpaceMathTestTargetArtifactsContractFunction0.factory(
                "YieldSpaceMathTestTargetArtifactsContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTargetContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts() method."""

    _function_name = "targetContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetContractsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetContractsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetContractsContractFunction0._type_signature: YieldSpaceMathTestTargetContractsContractFunction0.factory(
                "YieldSpaceMathTestTargetContractsContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTargetInterfacesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces() method."""

    _function_name = "targetInterfaces"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzInterface]:
        """returns list[StdInvariant.FuzzInterface]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzInterface]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzInterface],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetInterfacesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetInterfaces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetInterfacesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetInterfacesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetInterfacesContractFunction0._type_signature: YieldSpaceMathTestTargetInterfacesContractFunction0.factory(
                "YieldSpaceMathTestTargetInterfacesContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTargetSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors() method."""

    _function_name = "targetSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetSelectorsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetSelectorsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetSelectorsContractFunction0._type_signature: YieldSpaceMathTestTargetSelectorsContractFunction0.factory(
                "YieldSpaceMathTestTargetSelectorsContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTargetSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders() method."""

    _function_name = "targetSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetSendersContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetSendersContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTargetSendersContractFunction0._type_signature: YieldSpaceMathTestTargetSendersContractFunction0.factory(
                "YieldSpaceMathTestTargetSendersContractFunction0", **kwargs
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateBondsOutGivenSharesInDown__failure() method."""

    _function_name = "test__calculateBondsOutGivenSharesInDown__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateBondsOutGivenSharesInDown__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateBondsOutGivenSharesInDown__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateMaxBuyContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateMaxBuy(int,int,int,int) method."""

    _function_name = "test__calculateMaxBuy"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateMaxBuyContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateMaxBuy method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateMaxBuy"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fixedRate: int, shareReserves: int, vaultSharePrice: int, initialVaultSharePrice: int) -> YieldSpaceMathTestTest__calculateMaxBuyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateMaxBuyContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateMaxBuyContractFunction0._type_signature: YieldSpaceMathTestTest__calculateMaxBuyContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateMaxBuyContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateOutGivenInContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateOutGivenIn() method."""

    _function_name = "test__calculateOutGivenIn"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateOutGivenInContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateOutGivenIn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateOutGivenIn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateOutGivenInContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateOutGivenInContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateOutGivenInContractFunction0._type_signature: YieldSpaceMathTestTest__calculateOutGivenInContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateOutGivenInContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut() method."""

    _function_name = "test__calculateSharesInGivenBondsOut"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOut"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutDown__failure() method."""

    _function_name = "test__calculateSharesInGivenBondsOutDown__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutDown__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOutDown__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutUp__failure() method."""

    _function_name = "test__calculateSharesInGivenBondsOutUp__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutUp__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOutUp__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut__extremeValues(int,int,int,int,int) method."""

    _function_name = "test__calculateSharesInGivenBondsOut__extremeValues"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "int"]), structs
    )
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut__extremeValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOut__extremeValues"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fixedRate: int, shareReserves: int, vaultSharePrice: int, initialVaultSharePrice: int, tradeSize: int) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0.factory(
                "YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0",
                **kwargs,
            ),
        }
        return out


class YieldSpaceMathTestContractFunctions(ContractFunctions):
    """ContractFunctions for the YieldSpaceMathTest contract."""

    IS_TEST: YieldSpaceMathTestIS_TESTContractFunction

    excludeArtifacts: YieldSpaceMathTestExcludeArtifactsContractFunction

    excludeContracts: YieldSpaceMathTestExcludeContractsContractFunction

    excludeSenders: YieldSpaceMathTestExcludeSendersContractFunction

    failed: YieldSpaceMathTestFailedContractFunction

    targetArtifactSelectors: (
        YieldSpaceMathTestTargetArtifactSelectorsContractFunction
    )

    targetArtifacts: YieldSpaceMathTestTargetArtifactsContractFunction

    targetContracts: YieldSpaceMathTestTargetContractsContractFunction

    targetInterfaces: YieldSpaceMathTestTargetInterfacesContractFunction

    targetSelectors: YieldSpaceMathTestTargetSelectorsContractFunction

    targetSenders: YieldSpaceMathTestTargetSendersContractFunction

    test__calculateBondsOutGivenSharesInDown__failure: YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction

    test__calculateMaxBuy: (
        YieldSpaceMathTestTest__calculateMaxBuyContractFunction
    )

    test__calculateOutGivenIn: (
        YieldSpaceMathTestTest__calculateOutGivenInContractFunction
    )

    test__calculateSharesInGivenBondsOut: (
        YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction
    )

    test__calculateSharesInGivenBondsOutDown__failure: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction

    test__calculateSharesInGivenBondsOutUp__failure: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction

    test__calculateSharesInGivenBondsOut__extremeValues: YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.IS_TEST = YieldSpaceMathTestIS_TESTContractFunction.factory(
            "IS_TEST",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="IS_TEST",
        )
        self.excludeArtifacts = (
            YieldSpaceMathTestExcludeArtifactsContractFunction.factory(
                "excludeArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeArtifacts",
            )
        )
        self.excludeContracts = (
            YieldSpaceMathTestExcludeContractsContractFunction.factory(
                "excludeContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeContracts",
            )
        )
        self.excludeSenders = (
            YieldSpaceMathTestExcludeSendersContractFunction.factory(
                "excludeSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeSenders",
            )
        )
        self.failed = YieldSpaceMathTestFailedContractFunction.factory(
            "failed",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="failed",
        )
        self.targetArtifactSelectors = (
            YieldSpaceMathTestTargetArtifactSelectorsContractFunction.factory(
                "targetArtifactSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifactSelectors",
            )
        )
        self.targetArtifacts = (
            YieldSpaceMathTestTargetArtifactsContractFunction.factory(
                "targetArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifacts",
            )
        )
        self.targetContracts = (
            YieldSpaceMathTestTargetContractsContractFunction.factory(
                "targetContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetContracts",
            )
        )
        self.targetInterfaces = (
            YieldSpaceMathTestTargetInterfacesContractFunction.factory(
                "targetInterfaces",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetInterfaces",
            )
        )
        self.targetSelectors = (
            YieldSpaceMathTestTargetSelectorsContractFunction.factory(
                "targetSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSelectors",
            )
        )
        self.targetSenders = (
            YieldSpaceMathTestTargetSendersContractFunction.factory(
                "targetSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSenders",
            )
        )
        self.test__calculateBondsOutGivenSharesInDown__failure = YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction.factory(
            "test__calculateBondsOutGivenSharesInDown__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateBondsOutGivenSharesInDown__failure",
        )
        self.test__calculateMaxBuy = (
            YieldSpaceMathTestTest__calculateMaxBuyContractFunction.factory(
                "test__calculateMaxBuy",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test__calculateMaxBuy",
            )
        )
        self.test__calculateOutGivenIn = (
            YieldSpaceMathTestTest__calculateOutGivenInContractFunction.factory(
                "test__calculateOutGivenIn",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test__calculateOutGivenIn",
            )
        )
        self.test__calculateSharesInGivenBondsOut = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction.factory(
            "test__calculateSharesInGivenBondsOut",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOut",
        )
        self.test__calculateSharesInGivenBondsOutDown__failure = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction.factory(
            "test__calculateSharesInGivenBondsOutDown__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOutDown__failure",
        )
        self.test__calculateSharesInGivenBondsOutUp__failure = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction.factory(
            "test__calculateSharesInGivenBondsOutUp__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOutUp__failure",
        )
        self.test__calculateSharesInGivenBondsOut__extremeValues = YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction.factory(
            "test__calculateSharesInGivenBondsOut__extremeValues",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOut__extremeValues",
        )


class YieldSpaceMathTestLogContractEvent(ContractEvent):
    """ContractEvent for log."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_addressContractEvent(ContractEvent):
    """ContractEvent for log_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_arrayContractEvent(ContractEvent):
    """ContractEvent for log_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_bytesContractEvent(ContractEvent):
    """ContractEvent for log_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_intContractEvent(ContractEvent):
    """ContractEvent for log_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_addressContractEvent(ContractEvent):
    """ContractEvent for log_named_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_arrayContractEvent(ContractEvent):
    """ContractEvent for log_named_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_bytesContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_decimal_intContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_decimal_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_intContractEvent(ContractEvent):
    """ContractEvent for log_named_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_stringContractEvent(ContractEvent):
    """ContractEvent for log_named_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_stringContractEvent(ContractEvent):
    """ContractEvent for log_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_uintContractEvent(ContractEvent):
    """ContractEvent for log_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLogsContractEvent(ContractEvent):
    """ContractEvent for logs."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogsEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogsEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestContractEvents(ContractEvents):
    """ContractEvents for the YieldSpaceMathTest contract."""

    log: Type[YieldSpaceMathTestLogContractEvent]

    log_address: Type[YieldSpaceMathTestLog_addressContractEvent]

    log_array: Type[YieldSpaceMathTestLog_arrayContractEvent]

    log_bytes: Type[YieldSpaceMathTestLog_bytesContractEvent]

    log_bytes32: Type[YieldSpaceMathTestLog_bytes32ContractEvent]

    log_int: Type[YieldSpaceMathTestLog_intContractEvent]

    log_named_address: Type[YieldSpaceMathTestLog_named_addressContractEvent]

    log_named_array: Type[YieldSpaceMathTestLog_named_arrayContractEvent]

    log_named_bytes: Type[YieldSpaceMathTestLog_named_bytesContractEvent]

    log_named_bytes32: Type[YieldSpaceMathTestLog_named_bytes32ContractEvent]

    log_named_decimal_int: Type[
        YieldSpaceMathTestLog_named_decimal_intContractEvent
    ]

    log_named_decimal_uint: Type[
        YieldSpaceMathTestLog_named_decimal_uintContractEvent
    ]

    log_named_int: Type[YieldSpaceMathTestLog_named_intContractEvent]

    log_named_string: Type[YieldSpaceMathTestLog_named_stringContractEvent]

    log_named_uint: Type[YieldSpaceMathTestLog_named_uintContractEvent]

    log_string: Type[YieldSpaceMathTestLog_stringContractEvent]

    log_uint: Type[YieldSpaceMathTestLog_uintContractEvent]

    logs: Type[YieldSpaceMathTestLogsContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.log = cast(
            Type[YieldSpaceMathTestLogContractEvent],
            YieldSpaceMathTestLogContractEvent.factory(
                "log",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log",
            ),
        )
        self.log_address = cast(
            Type[YieldSpaceMathTestLog_addressContractEvent],
            YieldSpaceMathTestLog_addressContractEvent.factory(
                "log_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_address",
            ),
        )
        self.log_array = cast(
            Type[YieldSpaceMathTestLog_arrayContractEvent],
            YieldSpaceMathTestLog_arrayContractEvent.factory(
                "log_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_array",
            ),
        )
        self.log_bytes = cast(
            Type[YieldSpaceMathTestLog_bytesContractEvent],
            YieldSpaceMathTestLog_bytesContractEvent.factory(
                "log_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes",
            ),
        )
        self.log_bytes32 = cast(
            Type[YieldSpaceMathTestLog_bytes32ContractEvent],
            YieldSpaceMathTestLog_bytes32ContractEvent.factory(
                "log_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes32",
            ),
        )
        self.log_int = cast(
            Type[YieldSpaceMathTestLog_intContractEvent],
            YieldSpaceMathTestLog_intContractEvent.factory(
                "log_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_int",
            ),
        )
        self.log_named_address = cast(
            Type[YieldSpaceMathTestLog_named_addressContractEvent],
            YieldSpaceMathTestLog_named_addressContractEvent.factory(
                "log_named_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_address",
            ),
        )
        self.log_named_array = cast(
            Type[YieldSpaceMathTestLog_named_arrayContractEvent],
            YieldSpaceMathTestLog_named_arrayContractEvent.factory(
                "log_named_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_array",
            ),
        )
        self.log_named_bytes = cast(
            Type[YieldSpaceMathTestLog_named_bytesContractEvent],
            YieldSpaceMathTestLog_named_bytesContractEvent.factory(
                "log_named_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes",
            ),
        )
        self.log_named_bytes32 = cast(
            Type[YieldSpaceMathTestLog_named_bytes32ContractEvent],
            YieldSpaceMathTestLog_named_bytes32ContractEvent.factory(
                "log_named_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes32",
            ),
        )
        self.log_named_decimal_int = cast(
            Type[YieldSpaceMathTestLog_named_decimal_intContractEvent],
            YieldSpaceMathTestLog_named_decimal_intContractEvent.factory(
                "log_named_decimal_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_int",
            ),
        )
        self.log_named_decimal_uint = cast(
            Type[YieldSpaceMathTestLog_named_decimal_uintContractEvent],
            YieldSpaceMathTestLog_named_decimal_uintContractEvent.factory(
                "log_named_decimal_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_uint",
            ),
        )
        self.log_named_int = cast(
            Type[YieldSpaceMathTestLog_named_intContractEvent],
            YieldSpaceMathTestLog_named_intContractEvent.factory(
                "log_named_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_int",
            ),
        )
        self.log_named_string = cast(
            Type[YieldSpaceMathTestLog_named_stringContractEvent],
            YieldSpaceMathTestLog_named_stringContractEvent.factory(
                "log_named_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_string",
            ),
        )
        self.log_named_uint = cast(
            Type[YieldSpaceMathTestLog_named_uintContractEvent],
            YieldSpaceMathTestLog_named_uintContractEvent.factory(
                "log_named_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_uint",
            ),
        )
        self.log_string = cast(
            Type[YieldSpaceMathTestLog_stringContractEvent],
            YieldSpaceMathTestLog_stringContractEvent.factory(
                "log_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_string",
            ),
        )
        self.log_uint = cast(
            Type[YieldSpaceMathTestLog_uintContractEvent],
            YieldSpaceMathTestLog_uintContractEvent.factory(
                "log_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_uint",
            ),
        )
        self.logs = cast(
            Type[YieldSpaceMathTestLogsContractEvent],
            YieldSpaceMathTestLogsContractEvent.factory(
                "logs",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="logs",
            ),
        )


class YieldSpaceMathTestContract(Contract):
    """A web3.py Contract class for the YieldSpaceMathTest contract."""

    abi: ABI = yieldspacemathtest_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x6080604052600c8054600160ff199182168117909255601e8054909116909117905534801561002d57600080fd5b5061486b8061003d6000396000f3fe608060405234801561001057600080fd5b50600436106101165760003560e01c806385226c81116100a2578063ba414fa611610071578063ba414fa6146101d8578063caafb419146101f0578063dbd56c8a146101f8578063e20c9f7114610200578063fa7626d41461020857600080fd5b806385226c81146101a0578063916a17c6146101b5578063ac522b60146101bd578063b5508aa9146101d057600080fd5b8063359a0432116100e9578063359a0432146101605780633e5e3c23146101685780633f7286f4146101705780634e1230941461017857806366d9a9a01461018b57600080fd5b80630e98bbba1461011b5780631d8ab863146101255780631ed7831c1461012d5780632ade38801461014b575b600080fd5b610123610215565b005b610123610617565b610135610a0b565b60405161014291906132a0565b60405180910390f35b610153610a6d565b6040516101429190613333565b610123610baf565b610135610f30565b610135610f90565b6101236101863660046133f3565b610ff0565b61019361144e565b6040516101429190613425565b6101a8611534565b60405161014291906134da565b610193611604565b6101236101cb36600461353e565b6116ea565b6101a86119e1565b6101e0611ab1565b6040519015158152602001610142565b610123611b55565b610123611cdd565b610135611efb565b601e546101e09060ff1681565b600060405161022390613293565b604051809103906000f08015801561023f573d6000803e3d6000fd5b509050600061025f670de0b6b3a7640000680133e79f1880bca5ea611f5b565b905060006001600160a01b0383166386c85e1069152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d631000006102b6876102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b90611f79565b6102c890670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016102f3969594939291906135a2565b602060405180830381865afa158015610310573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033491906135ca565b905068058e8b841ae6c8ed9061034f8282633b9aca00611f8e565b60006001600160a01b0385166386c85e1069152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd59200000061039f896102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b6103b190670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016103dc969594939291906135a2565b602060405180830381865afa1580156103f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041d91906135ca565b905069112e83c71900141b11806104398282633b9aca00611f8e565b60006001600160a01b0387166327d0e26569152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d631000006104888b6102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b61049a90670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016104c5969594939291906135a2565b602060405180830381865afa1580156104e2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050691906135ca565b9050680549d2621fcfa28ce06105218282633b9aca00611f8e565b60006001600160a01b0389166327d0e26569152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd5920000006105718d6102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b61058390670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016105ae969594939291906135a2565b602060405180830381865afa1580156105cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ef91906135ca565b90506910460e004cd5ae5b7e0061060b8282633b9aca00611f8e565b50505050505050505050565b600060405161062590613293565b604051809103906000f080158015610641573d6000803e3d6000fd5b506040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152929350737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb3926106a19291016135e3565b600060405180830381600087803b1580156106bb57600080fd5b505af11580156106cf573d6000803e3d6000fd5b5050506001600160a01b038216905063a4a6f9d969d3c21bcecceda10000006a027b46536c66c8e30000006a027b46536c66c8e3000001610721670de0b6b3a7640000680133e79f1880bca5ea611f5b565b61073390670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b815260040161075e969594939291906135a2565b602060405180830381865afa15801561077b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079f91906135ca565b505060006040516107af90613293565b604051809103906000f0801580156107cb573d6000803e3d6000fd5b509050680aef5074226501a96a6912ae0bae78ab7704beea600080610801670de0b6b3a7640000680133e79f1880bca5ea611f5b565b90506000610823826102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b61083590670de0b6b3a764000061358f565b90506d35e51921da1a73e8caed30de384d7f01bb2ecac621ca54ea75c5329440ec17993d2f7576a8549d57adaece7d42c55461087e876000676765c793fa10079d601a1b611ffb565b9650610897866000676765c793fa10079d601a1b611ffb565b95506108b0856000676765c793fa10079d601a1b611ffb565b94506108cb82655af3107a4000670de0b6b3a7640000611ffb565b91506108e681655af3107a4000670de0b6b3a7640000611ffb565b9050848610156108fa575050505050505050565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392610957929091016135e3565b600060405180830381600087803b15801561097157600080fd5b505af1158015610985573d6000803e3d6000fd5b505060405163a4a6f9d960e01b81526001600160a01b038b16925063a4a6f9d991506109bf908a908a908a908990899089906004016135a2565b602060405180830381865afa1580156109dc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0091906135ca565b505050505050505050565b60606016805480602002602001604051908101604052809291908181526020018280548015610a6357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610a45575b5050505050905090565b6060601d805480602002602001604051908101604052809291908181526020016000905b82821015610ba657600084815260208082206040805180820182526002870290920180546001600160a01b03168352600181018054835181870281018701909452808452939591948681019491929084015b82821015610b8f578382906000526020600020018054610b02906135f6565b80601f0160208091040260200160405190810160405280929190818152602001828054610b2e906135f6565b8015610b7b5780601f10610b5057610100808354040283529160200191610b7b565b820191906000526020600020905b815481529060010190602001808311610b5e57829003601f168201915b505050505081526020019060010190610ae3565b505050508152505081526020019060010190610a91565b50505050905090565b6000604051610bbd90613293565b604051809103906000f080158015610bd9573d6000803e3d6000fd5b5090506000610bf9670de0b6b3a7640000680133e79f1880bca5ea611f5b565b905060006001600160a01b038316632e74108c69152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d63100000610c4a876102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b610c5c90670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610c87969594939291906135a2565b602060405180830381865afa158015610ca4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc891906135ca565b9050680549dc9b3ad2c9ca10610ce38282633b9aca00611f8e565b60006001600160a01b038516632e74108c69152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd592000000610d33896102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b610d4590670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610d70969594939291906135a2565b602060405180830381865afa158015610d8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db191906135ca565b90506910b361bf3f780b2c9500610dcd8282633b9aca00611f8e565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392610e2a929091016135e3565b600060405180830381600087803b158015610e4457600080fd5b505af1158015610e58573d6000803e3d6000fd5b5050506001600160a01b0387169050632e74108c69152d02c7e14af680000068055de6a779bbac000068056bc75e2d63100000610ea98a6102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b610ebb90670de0b6b3a764000061358f565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610ee6969594939291906135a2565b602060405180830381865afa158015610f03573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2791906135ca565b50505050505050565b60606018805480602002602001604051908101604052809291908181526020018280548015610a63576020028201919060005260206000209081546001600160a01b03168152600190910190602001808311610a45575050505050905090565b60606017805480602002602001604051908101604052809291908181526020018280548015610a63576020028201919060005260206000209081546001600160a01b03168152600190910190602001808311610a45575050505050905090565b6000604051610ffe90613293565b604051809103906000f08015801561101a573d6000803e3d6000fd5b50905061103785662386f26fc10000670de0b6b3a7640000611ffb565b945061105584655af3107a4000676765c793fa10079d601a1b611ffb565b935061107282670b1a2bc2ec500000674563918244f40000611ffb565b91506110878383674563918244f40000611ffb565b92506000611099866301e1338061207e565b905060008073__$2b4fa6f02a36eedfe41c65e8dd342257d3$__63b29e1d1e8888888c6301e13380896040518763ffffffff1660e01b81526004016110e3969594939291906135a2565b606060405180830381865af4158015611100573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611124919061362a565b925092505060006111358884612123565b90506000806001600160a01b03871663a9afa373848661115d670de0b6b3a76400008b611f79565b61116f90670de0b6b3a764000061358f565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018c9052608481018b905260a4016040805180830381865afa1580156111c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111e99190613658565b915091506111f8816001612149565b60006001600160a01b038816635880b9fd858761121d670de0b6b3a76400008c611f79565b61122f90670de0b6b3a764000061358f565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018d9052608481018c905260a4016040805180830381865afa158015611285573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112a99190613658565b92509050898961140b6001600160a01b038b1663d79d0835888a6112d58e670de0b6b3a764000061358f565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018690526084810185905260a401602060405180830381865afa15801561132c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061135091906135ca565b6001600160a01b038c1663d79d0835611369878b61368d565b6113738a8d61358f565b6113858f670de0b6b3a764000061358f565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018790526084810186905260a401602060405180830381865afa1580156113dc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061140091906135ca565b64e8d4a51000611f8e565b61143e61142c61141b858961368d565b611425888b61358f565b848d6121ba565b670de0b6b3a764000062989680611f8e565b5050505050505050505050505050565b6060601b805480602002602001604051908101604052809291908181526020016000905b82821015610ba65760008481526020908190206040805180820182526002860290920180546001600160a01b0316835260018101805483518187028101870190945280845293949193858301939283018282801561151c57602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116114de5790505b50505050508152505081526020019060010190611472565b6060601a805480602002602001604051908101604052809291908181526020016000905b82821015610ba6578382906000526020600020018054611577906135f6565b80601f01602080910402602001604051908101604052809291908181526020018280546115a3906135f6565b80156115f05780601f106115c5576101008083540402835291602001916115f0565b820191906000526020600020905b8154815290600101906020018083116115d357829003601f168201915b505050505081526020019060010190611558565b6060601c805480602002602001604051908101604052809291908181526020016000905b82821015610ba65760008481526020908190206040805180820182526002860290920180546001600160a01b031683526001810180548351818702810187019094528084529394919385830193928301828280156116d257602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116116945790505b50505050508152505081526020019060010190611628565b60006040516116f890613293565b604051809103906000f080158015611714573d6000803e3d6000fd5b509050620186a061173587662386f26fc10000670de0b6b3a7640000611ffb565b965061175284670b1a2bc2ec500000674563918244f40000611ffb565b93506117678585674563918244f40000611ffb565b945060065b601281116119d7576117ab61178282600161368d565b61178d90600a613784565b61179883600961368d565b6117a390600a613784565b899190611ffb565b965060006117ba6002836137a6565b6117c590600161368d565b6117cf908361358f565b90505b818110156119c45760006117ea8a6301e1338061207e565b60405163594f0e8f60e11b81529091508a90600090819073__$2b4fa6f02a36eedfe41c65e8dd342257d3$__9063b29e1d1e90611839908f908f908f9089906301e13380908c906004016135a2565b606060405180830381865af4158015611856573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061187a919061362a565b925092505060006118e46040518061018001604052808f815260200185815260200184815260200160008152602001600081526020018781526020018e81526020018d81526020018a8152602001600081526020016000815260200160008152506000600f6121da565b91506118fe90506118f687600a613784565b8b9083611ffb565b99508c90508b8b8b60006001600160a01b038d1663a4a6f9d986888561192c670de0b6b3a76400008f611f79565b61193e90670de0b6b3a764000061358f565b89896040518763ffffffff1660e01b8152600401611961969594939291906135a2565b602060405180830381865afa15801561197e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a291906135ca565b90506119af8160006123e4565b5050600190970196506117d295505050505050565b506119d060018261368d565b905061176c565b5050505050505050565b60606019805480602002602001604051908101604052809291908181526020016000905b82821015610ba6578382906000526020600020018054611a24906135f6565b80601f0160208091040260200160405190810160405280929190818152602001828054611a50906135f6565b8015611a9d5780601f10611a7257610100808354040283529160200191611a9d565b820191906000526020600020905b815481529060010190602001808311611a8057829003601f168201915b505050505081526020019060010190611a05565b60085460009060ff1615611ac9575060085460ff1690565b604051630667f9d760e41b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d600482018190526519985a5b195960d21b602483015260009163667f9d7090604401602060405180830381865afa158015611b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b4e91906135ca565b1415905090565b6000604051611b6390613293565b604051809103906000f080158015611b7f573d6000803e3d6000fd5b50905060e0610c9a6117306000611ba7670de0b6b3a7640000680133e79f1880bca5ea611f5b565b90506000611bc9826102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b611bdb90670de0b6b3a764000061358f565b90506a636f6e736f6c652e6c6f676107c0611c00816000670de0b6b3a7640000611ffb565b9050611c16826000670de0b6b3a7640000611ffb565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152929450737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392611c759291016135e3565b600060405180830381600087803b158015611c8f57600080fd5b505af1158015611ca3573d6000803e3d6000fd5b505060405163086c85e160e41b81526001600160a01b038b1692506386c85e1091506109bf908a908a908a908990899089906004016135a2565b6000604051611ceb90613293565b604051809103906000f080158015611d07573d6000803e3d6000fd5b509050680aef5074226501a96a6912ae0bae78ab7704beea600080611d3d670de0b6b3a7640000680133e79f1880bca5ea611f5b565b90506000611d5f826102b0670de0b6b3a7640000671bc16d674ec80000611f5b565b611d7190670de0b6b3a764000061358f565b90506d35e51921da1a73e8caed30de384d7f01bb2ecac621ca54ea75c5329440ec17993d2f7576a8549d57adaece7d42c554611dba876000676765c793fa10079d601a1b611ffb565b9650611dd3866000676765c793fa10079d601a1b611ffb565b9550611dec856000676765c793fa10079d601a1b611ffb565b9450611e0782655af3107a4000670de0b6b3a7640000611ffb565b9150611e2281655af3107a4000670de0b6b3a7640000611ffb565b905084861015611e36575050505050505050565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392611e93929091016135e3565b600060405180830381600087803b158015611ead57600080fd5b505af1158015611ec1573d6000803e3d6000fd5b5050604051630b9d042360e21b81526001600160a01b038b169250632e74108c91506109bf908a908a908a908990899089906004016135a2565b60606015805480602002602001604051908101604052809291908181526020018280548015610a63576020028201919060005260206000209081546001600160a01b03168152600190910190602001808311610a45575050505050905090565b6000611f7083670de0b6b3a764000084612423565b90505b92915050565b6000611f708383670de0b6b3a7640000612423565b604051630b6903e360e11b8152600481018490526024810183905260448101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906316d207c69060640160006040518083038186803b158015611fe757600080fd5b505afa158015610f27573d6000803e3d6000fd5b6000818311156120435760405162461bcd60e51b815260206004820152600e60248201526d098d2c47440dad2dc407c40dac2f60931b60448201526064015b60405180910390fd5b600061204f848461358f565b61205a90600161368d565b9050600061206882876137ba565b9050612074858261368d565b9695505050505050565b6000806120af6120a06120928660646137ce565b66a5bbed86c5a00090611f79565b6748cd4072281e000090611f5b565b90506120c3670de0b6b3a764000082611f5b565b905061211b816102b06120ee6120e96120e489670de0b6b3a764000061368d565b612441565b61246f565b6121156120e96121038a8a6301e13380612423565b6120e490670de0b6b3a764000061368d565b90611f5b565b949350505050565b600080612130848461269e565b909250905080612142576121426126dd565b5092915050565b60405163f7fe347760e01b815282151560048201528115156024820152737109709ecfa91a80626ff3989d68f67f5b1dd12d9063f7fe3477906044015b60006040518083038186803b15801561219e57600080fd5b505afa1580156121b2573d6000803e3d6000fd5b505050505050565b60006121d1826121cb858888612423565b906126f6565b95945050505050565b60008060006121f186600001518760200151612123565b9050600061220d8288604001518960e001518a60a001516121ba565b905060008061221d89858561275c565b909250905060006122318a8a8585886129b2565b9150508015612248575090945092506123dc915050565b5061225589838a86612aea565b955061226389878686612b96565b94506000806122758b8b8a8a896129b2565b91509150806122e05760405162461bcd60e51b815260206004820152603160248201527f496e697469616c20677565737320696e206063616c63756c6174654d61784c6f6044820152703733b01034b99034b739b7b63b32b73a1760791b606482015260840161203a565b60005b898110156123d4578489106123565760405162461bcd60e51b815260206004820152603360248201527f52656163686564206162736f6c757465206d617820626f6e6420616d6f756e746044820152721034b7103033b2ba2fb6b0bc2fb637b733b01760691b606482015260840161203a565b60006123648d8b8a8a612be9565b935090508261237357506123d4565b600061237f8583611f5b565b612389908c61368d565b905060006123998f838c8c612b96565b90506123a88f8f84848d6129b2565b909650945084156123be57819b50809a506123c6565b5050506123d4565b5050508060010190506122e3565b505050505050505b935093915050565b604051636d83fe6960e11b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063db07fcd290604401612186565b600082600019048411830215820261243a57600080fd5b5091020490565b60006001600160ff1b0382111561246b5760405163396ea70160e11b815260040160405180910390fd5b5090565b60008082136124915760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f1982019061251d9084901c612441565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b6000806000836126ad86612441565b6126b791906137e5565b905060008112156126cf5760008092509250506126d6565b9150600190505b9250929050565b60405163bb55fd2760e01b815260040160405180910390fd5b60008160000361270f5750670de0b6b3a7640000611f73565b8260000361271f57506000611f73565b600061272a83612441565b9050600061273a6120e986612441565b9050818102612751670de0b6b3a764000082613805565b905061207481612c82565b6000806000806127928688604001518960a00151670de0b6b3a7640000612783919061358f565b8a60c001518b60e00151612e17565b90506127e2876101400151670de0b6b3a76400006127b0919061358f565b6127dc670de0b6b3a76400006127c6818a612e46565b6127d0919061358f565b6101208b015190612e5b565b90612e5b565b9150612818876101400151670de0b6b3a7640000612800919061358f565b61281284670de0b6b3a764000061368d565b90612e46565b60a08801519092506128419061283a9061211581670de0b6b3a764000061358f565b83906126f6565b915061285e8760e001518860c00151612e4690919063ffffffff16565b612868908361368d565b91506128748183611f5b565b91506128a361283a8860a00151670de0b6b3a7640000612894919061358f565b670de0b6b3a764000090611f5b565b91505060006128bf8760e0015183611f5b90919063ffffffff16565b905060008061290c896101400151670de0b6b3a76400006128e0919061358f565b6102b0670de0b6b3a76400006128f6818c611f5b565b612900919061358f565b6101208d015190611f79565b9050612962846102b06129348c60a00151670de0b6b3a7640000612e4690919063ffffffff16565b6121cb8d6101400151670de0b6b3a7640000612950919061358f565b61211587670de0b6b3a764000061368d565b9150506129798860c0015188846102b0919061358f565b945061298b85878a6101200151612e70565b81896040015161299b919061358f565b6129a5919061358f565b9350505050935093915050565b60008060006129cd86858a61012001518b6101600151612e9d565b905060006129e88960c0015183611f5b90919063ffffffff16565b60c08a01516129f8908990611f5b565b8a51612a04919061368d565b612a0e919061358f565b90506000868a60800151612a22919061368d565b90506000612a308a82612eb2565b612a3990613833565b90508a6101000151612a588c60c0015184611f5b90919063ffffffff16565b612a62919061368d565b60c08c0151612a72908390611f5b565b612a7c908561368d565b10612ad4576101008b015160c08c0151612a97908490611f5b565b60c08d0151612aa7908490611f5b565b612ab1908661368d565b612abb919061358f565b612ac5919061358f565b60019550955050505050612ae0565b60008095509550505050505b9550959350505050565b600080612af986858586612ec7565b90506000612b40670b1a2bc2ec5000006102b0612b368a60a00151670de0b6b3a7640000612b27919061358f565b670de0b6b3a764000090612e46565b6121cb868b611f5b565b90506000612b56670de0b6b3a764000083611f79565b612b72612b6b84670de0b6b3a764000061358f565b8790611f79565b612b7c919061368d565b9050612b8a88878784612ec7565b98975050505050505050565b600080612bcd848760400151612bb98960c0015189611f5b90919063ffffffff16565b8960a001518a60c001518b60e00151612fe8565b9050612bdf8584886101200151612e70565b612074908261358f565b600080612bf886868686613009565b909250905080612c0b5760009150612c79565b612c35612c2084670de0b6b3a764000061358f565b6101208801516101608901516102b091611f79565b612c3f908361368d565b9150612c53670de0b6b3a76400008361358f565b9150612c76670de0b6b3a76400008760c00151846124239092919063ffffffff16565b91505b94509492505050565b6000680248ce36a70cb26b3e198213612c9d57506000919050565b680755bf798b4a1bf1e58212612cc6576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b059150600060606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b01818105955092935090919061207474029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c612441565b6000612e2385856126f6565b612e3c612e34866121cb868b611f79565b859085612423565b612074919061368d565b6000611f7083670de0b6b3a764000084613159565b6000611f708383670de0b6b3a7640000613159565b600061211b846127dc670de0b6b3a7640000612e8c8188612e46565b612e96919061358f565b8590612e5b565b60006121d1846102b0846102b0898989612e70565b6000818313612ec15782611f70565b50919050565b600080612ed48582612eb2565b612edd90613833565b90506000612f4a8760c00151671bc16d674ec80000896101000151612f138b60c001518c60800151611f5b90919063ffffffff16565b60c08c0151612f23908890611f5b565b8c51612f2f919061368d565b612f39919061358f565b612f43919061358f565b9190612423565b9050612fdd612f7b670de0b6b3a7640000612f658189611f5b565b612f6f919061358f565b6101208a015190611f79565b670de0b6b3a7640000612fa6612f91898361358f565b6101208c01516101608d01516102b091611f79565b612fb8670de0b6b3a764000089611f5b565b612fc2919061368d565b612fcc919061358f565b612fd6919061358f565b8290611f5b565b979650505050505050565b6000612fdd87878761300288670de0b6b3a764000061358f565b878761317f565b60008060006130258760c0015187611f5b90919063ffffffff16565b90506000613041613036838861368d565b60e08a015190611f79565b90506000613075878a604001518b60a00151670de0b6b3a7640000613066919061358f565b8c60c001518d60e00151612e17565b90506130916128948a60a00151846126f690919063ffffffff16565b945060006130c06130af8b60a00151856126f690919063ffffffff16565b60e08c015160c08d01519190612423565b9050808210156130da576000809550955050505050612c79565b613110612b6b6131068c60a00151670de0b6b3a76400006130fb919061358f565b60a08e015190612e46565b6121cb848661358f565b955061313e670de0b6b3a7640000613128818a611f5b565b613132919061358f565b6101208c015190611f79565b613148908761358f565b9a60019a5098505050505050505050565b600082600019048411830215820261317057600080fd5b50910281810615159190040190565b6000806131908888888888886131ad565b9092509050806131a2576131a26126dd565b509695505050505050565b60008060006131bf898988888861326e565b90506131d2866121cb612b6b8a8d61368d565b98506131df858a86612423565b9850888110156131f6576000809250925050613263565b888103670de0b6b3a7640000811061322b5761322461321d670de0b6b3a764000089612e46565b82906126f6565b9050613243565b61324061321d670de0b6b3a764000089611f5b565b90505b8089101561325957600080935093505050613263565b8803925060019150505b965096945050505050565b600061327a85856126f6565b612e3c61328b866121cb868b612e5b565b859085613159565b610fe68061385083390190565b6020808252825182820181905260009190848201906040850190845b818110156132e15783516001600160a01b0316835292840192918401916001016132bc565b50909695505050505050565b6000815180845260005b81811015613313576020818501810151868301820152016132f7565b506000602082860101526020601f19601f83011685010191505092915050565b602080825282518282018190526000919060409081850190600581811b8701840188860187805b858110156133e357603f198b8503018752825180516001600160a01b031685528901518985018990528051898601819052908a0190606081881b870181019190870190855b818110156133cd57605f198985030183526133bb8486516132ed565b948e01949350918d019160010161339f565b505050978a01979450509188019160010161335a565b50919a9950505050505050505050565b6000806000806080858703121561340957600080fd5b5050823594602084013594506040840135936060013592509050565b600060208083018184528085518083526040925060408601915060408160051b8701018488016000805b848110156134cb57898403603f19018652825180516001600160a01b03168552880151888501889052805188860181905290890190839060608701905b808310156134b65783516001600160e01b0319168252928b019260019290920191908b019061348c565b50978a0197955050509187019160010161344f565b50919998505050505050505050565b600060208083016020845280855180835260408601915060408160051b87010192506020870160005b8281101561353157603f1988860301845261351f8583516132ed565b94509285019290850190600101613503565b5092979650505050505050565b600080600080600060a0868803121561355657600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052601160045260246000fd5b81810381811115611f7357611f73613579565b958652602086019490945260408501929092526060840152608083015260a082015260c00190565b6000602082840312156135dc57600080fd5b5051919050565b602081526000611f7060208301846132ed565b600181811c9082168061360a57607f821691505b602082108103612ec157634e487b7160e01b600052602260045260246000fd5b60008060006060848603121561363f57600080fd5b8351925060208401519150604084015190509250925092565b6000806040838503121561366b57600080fd5b825191506020830151801515811461368257600080fd5b809150509250929050565b80820180821115611f7357611f73613579565b600181815b808511156136db5781600019048211156136c1576136c1613579565b808516156136ce57918102915b93841c93908002906136a5565b509250929050565b6000826136f257506001611f73565b816136ff57506000611f73565b8160018114613715576002811461371f5761373b565b6001915050611f73565b60ff84111561373057613730613579565b50506001821b611f73565b5060208310610133831016604e8410600b841016171561375e575081810a611f73565b61376883836136a0565b806000190482111561377c5761377c613579565b029392505050565b6000611f7083836136e3565b634e487b7160e01b600052601260045260246000fd5b6000826137b5576137b5613790565b500490565b6000826137c9576137c9613790565b500690565b8082028115828204841417611f7357611f73613579565b818103600083128015838313168383128216171561214257612142613579565b60008261381457613814613790565b600160ff1b82146000198414161561382e5761382e613579565b500590565b6000600160ff1b820161384857613848613579565b506000039056fe608060405234801561001057600080fd5b50610fc6806100206000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c806386c85e101161006657806386c85e101461012a578063a4a6f9d91461013d578063a9afa37314610150578063bc50ebe614610163578063d79d08351461017657600080fd5b80630aea7563146100a357806327d0e265146100c95780632e74108c146100dc5780633ee4114a146100ef5780635880b9fd14610117575b600080fd5b6100b66100b1366004610e1e565b610189565b6040519081526020015b60405180910390f35b6100b66100d7366004610e59565b6101a4565b6100b66100ea366004610e59565b6101c1565b6101026100fd366004610e59565b6101d2565b604080519283529015156020830152016100c0565b610102610125366004610e1e565b6101f9565b6100b6610138366004610e59565b61021e565b6100b661014b366004610e59565b61022f565b61010261015e366004610e1e565b610240565b610102610171366004610e9c565b610253565b6100b6610184366004610e1e565b61027c565b600080610199878787878761028c565b979650505050505050565b6000806101b58888888888886102cb565b98975050505050505050565b6000806101b58888888888886102f9565b6000806000806101e68a8a8a8a8a8a61030a565b909450925050505b965096945050505050565b60008060008061020c89898989896103d1565b909450925050505b9550959350505050565b6000806101b5888888888888610487565b6000806101b5888888888888610498565b60008060008061020c8989898989610559565b6000806000806102688b8b8b8b8b8b8b610602565b909450925050505b97509795505050505050565b6000806101998787878787610704565b60006102988585610729565b6102b76102af866102a9868b6107a0565b90610729565b8590856107bc565b6102c19190610efe565b9695505050505050565b6000806102dc88888888888861030a565b9092509050806102ee576102ee6107e2565b509695505050505050565b6000806102dc8888888888886107fb565b600080600061031c898988888861028c565b905061032c866102a9898b610efe565b9750878110156103435760008092509250506101ee565b8781036103518186886107bc565b9050670de0b6b3a764000081106103855761037e610377670de0b6b3a7640000896108d2565b8290610729565b905061039d565b61039a610377670de0b6b3a7640000896108e7565b90505b6103a781866108d2565b9050808a10156103bf576000809350935050506101ee565b90980398600198509650505050505050565b60008060006103e38888888888610704565b9050600061040e670de0b6b3a76400006103fd88886108d2565b6104079190610efe565b83906108e7565b9050670de0b6b3a7640000811061043b57610434610377670de0b6b3a7640000896108e7565b9050610453565b610450610377670de0b6b3a7640000896108d2565b90505b61045d81866108e7565b90508881101561047557600080935093505050610214565b97909703976001975095505050505050565b6000806102dc8888888888886108fc565b6000806104a88888878787610704565b9050858710156104ba576104ba6107e2565b95859003956104c98786610729565b9650868110156104db576104db6107e2565b8681036104e98185876109ba565b9050670de0b6b3a764000081106105165761050f610377670de0b6b3a7640000886108e7565b905061052e565b61052b610377670de0b6b3a7640000886108d2565b90505b61053881856108e7565b90508881101561054a5761054a6107e2565b97909703979650505050505050565b600080600061056b888888888861028c565b90506000610596670de0b6b3a764000061058588886108e7565b61058f9190610efe565b83906108d2565b9050670de0b6b3a764000081106105c3576105bc610377670de0b6b3a7640000896108d2565b90506105db565b6105d8610377670de0b6b3a7640000896108e7565b90505b808810156105f157600080935093505050610214565b909603976001975095505050505050565b60008060008812156106245761061788610f11565b6106219087610efe565b95505b6000806106318b8b6109d8565b915091508061064857600080935093505050610270565b6000610657838b8a8a8a610704565b9050600061067461066c8a6102a98a8e6107a0565b8990896107bc565b90508082101561068e576000809550955050505050610270565b808203670de0b6b3a764000081106106bc576106b5610377670de0b6b3a76400008c6108e7565b90506106d4565b6106d1610377670de0b6b3a76400008c6108d2565b90505b8b8110156106ed57600080965096505050505050610270565b9a909a039c60019c509a5050505050505050505050565b60006107108585610729565b6102b7610721866102a9868b610a17565b8590856109ba565b6000816000036107425750670de0b6b3a764000061079a565b826000036107525750600061079a565b600061075d83610a2c565b9050600061077261076d86610a2c565b610a5a565b9050818102610789670de0b6b3a764000082610f2d565b905061079481610c89565b93505050505b92915050565b60006107b58383670de0b6b3a76400006107bc565b9392505050565b60008260001904841183021582026107d357600080fd5b50910281810615159190040190565b60405163bb55fd2760e01b815260040160405180910390fd5b600080600061080d898988888861028c565b9050868810156108245760008092509250506101ee565b96869003966108338887610729565b97508781101561084a5760008092509250506101ee565b8781036108588186886107bc565b9050670de0b6b3a764000081106108855761087e610377670de0b6b3a7640000896108d2565b905061089d565b61089a610377670de0b6b3a7640000896108e7565b90505b6108a781866108d2565b9050898110156108bf576000809350935050506101ee565b9890980398600198509650505050505050565b60006107b583670de0b6b3a7640000846107bc565b60006107b583670de0b6b3a7640000846109ba565b600080600061090e898988888861028c565b9050610928866102a96109218a8d610efe565b8790610a17565b9850610935858a866109ba565b98508881101561094c5760008092509250506101ee565b888103670de0b6b3a7640000811061097a57610973610377670de0b6b3a7640000896108d2565b9050610992565b61098f610377670de0b6b3a7640000896108e7565b90505b808910156109a8576000809350935050506101ee565b90970398600198509650505050505050565b60008260001904841183021582026109d157600080fd5b5091020490565b6000806000836109e786610a2c565b6109f19190610f69565b90506000811215610a09576000809250925050610a10565b9150600190505b9250929050565b60006107b58383670de0b6b3a76400006109ba565b60006001600160ff1b03821115610a565760405163396ea70160e11b815260040160405180910390fd5b5090565b6000808213610a7c5760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f19820190610b089084901c610a2c565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b6000680248ce36a70cb26b3e198213610ca457506000919050565b680755bf798b4a1bf1e58212610ccd576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b059150600060606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b0181810595509293509091906102c174029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c610a2c565b600080600080600060a08688031215610e3657600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008060008060008060c08789031215610e7257600080fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b600080600080600080600060e0888a031215610eb757600080fd5b505085359760208701359750604087013596606081013596506080810135955060a0810135945060c0013592509050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561079a5761079a610ee8565b6000600160ff1b8201610f2657610f26610ee8565b5060000390565b600082610f4a57634e487b7160e01b600052601260045260246000fd5b600160ff1b821460001984141615610f6457610f64610ee8565b500590565b8181036000831280158383131683831282161715610f8957610f89610ee8565b509291505056fea2646970667358221220f4913778f11740c0505e4e33561aec61a8278beb2d6dd9d55b00a7eebcd3a82664736f6c63430008160033a2646970667358221220d67ae5cb90980d3f4c85ab1f1f5d02ccf089e1d1dbd26a0188e095b745a6851a64736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = YieldSpaceMathTestContractFunctions(yieldspacemathtest_abi, self.w3, address)  # type: ignore
        self.events = YieldSpaceMathTestContractEvents(yieldspacemathtest_abi, self.w3, address)  # type: ignore
        self.errors = YieldSpaceMathTestContractErrors()

    events: YieldSpaceMathTestContractEvents

    errors: YieldSpaceMathTestContractErrors = (
        YieldSpaceMathTestContractErrors()
    )

    functions: YieldSpaceMathTestContractFunctions

    class LinkReferences(NamedTuple):
        """Link references required when deploying."""

        LPMath: LPMathContract

    link_references_placeholder_lookup: dict[str, str] = {
        "LPMath": "__$2b4fa6f02a36eedfe41c65e8dd342257d3$__",
    }

    @classmethod
    def constructor(cls, link_references: LinkReferences) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["LPMath"],
                link_references.LPMath.address[2:].lower(),
            )

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        link_references: LinkReferences,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(link_references)

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = YieldSpaceMathTestContractFunctions(
            yieldspacemathtest_abi, w3, None
        )
        contract.errors = YieldSpaceMathTestContractErrors()

        return contract
