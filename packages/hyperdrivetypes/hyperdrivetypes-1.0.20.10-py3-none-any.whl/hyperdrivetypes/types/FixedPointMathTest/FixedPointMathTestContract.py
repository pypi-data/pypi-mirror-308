"""A web3.py Contract class for the FixedPointMathTest contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..StdInvariant import StdInvariantTypes as StdInvariant
from .FixedPointMathTestTypes import (
    Log_addressEvent,
    Log_arrayEvent,
    Log_bytes32Event,
    Log_bytesEvent,
    Log_intEvent,
    Log_named_addressEvent,
    Log_named_arrayEvent,
    Log_named_bytes32Event,
    Log_named_bytesEvent,
    Log_named_decimal_intEvent,
    Log_named_decimal_uintEvent,
    Log_named_intEvent,
    Log_named_stringEvent,
    Log_named_uintEvent,
    Log_stringEvent,
    Log_uintEvent,
    LogEvent,
    LogsEvent,
)

structs = {
    "StdInvariant.FuzzSelector": StdInvariant.FuzzSelector,
    "StdInvariant.FuzzInterface": StdInvariant.FuzzInterface,
}

fixedpointmathtest_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "IS_TEST",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "failed",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifactSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifactSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetInterfaces",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedInterfaces_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzInterface[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "artifacts",
                            "type": "string[]",
                            "internalType": "string[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "test_differential_fuzz_pow",
            "inputs": [
                {"name": "x", "type": "uint256", "internalType": "uint256"},
                {"name": "y", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_differential_fuzz_pow_zero",
            "inputs": [
                {"name": "x", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_divDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_divUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_exp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_divDown_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_divUp_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_exp_negative_or_zero_input",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_ln_negative_or_zero_input",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_mulDivDown_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_mulDivUp_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_ln",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDivDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDivUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_pow",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateWeightedAverage",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateWeightedAverage_fuzz",
            "inputs": [
                {
                    "name": "average",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalWeight",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "delta", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "deltaWeight",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "log",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_address",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes32",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_int",
            "inputs": [
                {
                    "name": "",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_address",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes32",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_string",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_string",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_uint",
            "inputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "logs",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
    ],
)


class FixedPointMathTestContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the FixedPointMathTest contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class FixedPointMathTestIS_TESTContractFunction0(PypechainContractFunction):
    """ContractFunction for the IS_TEST() method."""

    _function_name = "IS_TEST"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestIS_TESTContractFunction(PypechainContractFunction):
    """ContractFunction for the IS_TEST method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "IS_TEST"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestIS_TESTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestIS_TESTContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestIS_TESTContractFunction0._type_signature: FixedPointMathTestIS_TESTContractFunction0.factory(
                "FixedPointMathTestIS_TESTContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestExcludeArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts() method."""

    _function_name = "excludeArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeArtifactsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeArtifactsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestExcludeArtifactsContractFunction0._type_signature: FixedPointMathTestExcludeArtifactsContractFunction0.factory(
                "FixedPointMathTestExcludeArtifactsContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestExcludeContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts() method."""

    _function_name = "excludeContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeContractsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeContractsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestExcludeContractsContractFunction0._type_signature: FixedPointMathTestExcludeContractsContractFunction0.factory(
                "FixedPointMathTestExcludeContractsContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestExcludeSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders() method."""

    _function_name = "excludeSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeSendersContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeSendersContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestExcludeSendersContractFunction0._type_signature: FixedPointMathTestExcludeSendersContractFunction0.factory(
                "FixedPointMathTestExcludeSendersContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestFailedContractFunction0(PypechainContractFunction):
    """ContractFunction for the failed() method."""

    _function_name = "failed"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestFailedContractFunction(PypechainContractFunction):
    """ContractFunction for the failed method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "failed"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestFailedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestFailedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestFailedContractFunction0._type_signature: FixedPointMathTestFailedContractFunction0.factory(
                "FixedPointMathTestFailedContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTargetArtifactSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors() method."""

    _function_name = "targetArtifactSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetArtifactSelectorsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifactSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetArtifactSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetArtifactSelectorsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetArtifactSelectorsContractFunction0._type_signature: FixedPointMathTestTargetArtifactSelectorsContractFunction0.factory(
                "FixedPointMathTestTargetArtifactSelectorsContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTargetArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts() method."""

    _function_name = "targetArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetArtifactsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetArtifactsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetArtifactsContractFunction0._type_signature: FixedPointMathTestTargetArtifactsContractFunction0.factory(
                "FixedPointMathTestTargetArtifactsContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTargetContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts() method."""

    _function_name = "targetContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetContractsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetContractsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetContractsContractFunction0._type_signature: FixedPointMathTestTargetContractsContractFunction0.factory(
                "FixedPointMathTestTargetContractsContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTargetInterfacesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces() method."""

    _function_name = "targetInterfaces"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzInterface]:
        """returns list[StdInvariant.FuzzInterface]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzInterface]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzInterface],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetInterfacesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetInterfaces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetInterfacesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetInterfacesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetInterfacesContractFunction0._type_signature: FixedPointMathTestTargetInterfacesContractFunction0.factory(
                "FixedPointMathTestTargetInterfacesContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTargetSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors() method."""

    _function_name = "targetSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetSelectorsContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetSelectorsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetSelectorsContractFunction0._type_signature: FixedPointMathTestTargetSelectorsContractFunction0.factory(
                "FixedPointMathTestTargetSelectorsContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTargetSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders() method."""

    _function_name = "targetSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetSendersContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetSendersContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTargetSendersContractFunction0._type_signature: FixedPointMathTestTargetSendersContractFunction0.factory(
                "FixedPointMathTestTargetSendersContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_differential_fuzz_powContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow(int,int) method."""

    _function_name = "test_differential_fuzz_pow"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_differential_fuzz_powContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_differential_fuzz_pow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, x: int, y: int) -> FixedPointMathTestTest_differential_fuzz_powContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_differential_fuzz_powContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_differential_fuzz_powContractFunction0._type_signature: FixedPointMathTestTest_differential_fuzz_powContractFunction0.factory(
                "FixedPointMathTestTest_differential_fuzz_powContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow_zero(int) method."""

    _function_name = "test_differential_fuzz_pow_zero"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow_zero method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_differential_fuzz_pow_zero"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, x: int) -> FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0._type_signature: FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0.factory(
                "FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_divDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_divDown() method."""

    _function_name = "test_divDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_divDownContractFunction(PypechainContractFunction):
    """ContractFunction for the test_divDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_divDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_divDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_divDownContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_divDownContractFunction0._type_signature: FixedPointMathTestTest_divDownContractFunction0.factory(
                "FixedPointMathTestTest_divDownContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_divUpContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_divUp() method."""

    _function_name = "test_divUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_divUpContractFunction(PypechainContractFunction):
    """ContractFunction for the test_divUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_divUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_divUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_divUpContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_divUpContractFunction0._type_signature: FixedPointMathTestTest_divUpContractFunction0.factory(
                "FixedPointMathTestTest_divUpContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_expContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_exp() method."""

    _function_name = "test_exp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_expContractFunction(PypechainContractFunction):
    """ContractFunction for the test_exp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_exp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_expContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_expContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_expContractFunction0._type_signature: FixedPointMathTestTest_expContractFunction0.factory(
                "FixedPointMathTestTest_expContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divDown_zero_denominator() method."""

    _function_name = "test_fail_divDown_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divDown_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_divDown_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0.factory(
                "FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divUp_zero_denominator() method."""

    _function_name = "test_fail_divUp_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divUp_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_divUp_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0.factory(
                "FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_exp_negative_or_zero_input() method."""

    _function_name = "test_fail_exp_negative_or_zero_input"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_exp_negative_or_zero_input method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_exp_negative_or_zero_input"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0._type_signature: FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0.factory(
                "FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_ln_negative_or_zero_input() method."""

    _function_name = "test_fail_ln_negative_or_zero_input"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_ln_negative_or_zero_input method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_ln_negative_or_zero_input"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0._type_signature: FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0.factory(
                "FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivDown_zero_denominator() method."""

    _function_name = "test_fail_mulDivDown_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivDown_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_mulDivDown_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0.factory(
                "FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivUp_zero_denominator() method."""

    _function_name = "test_fail_mulDivUp_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivUp_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_mulDivUp_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0.factory(
                "FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_lnContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_ln() method."""

    _function_name = "test_ln"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_lnContractFunction(PypechainContractFunction):
    """ContractFunction for the test_ln method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_ln"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_lnContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_lnContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_lnContractFunction0._type_signature: FixedPointMathTestTest_lnContractFunction0.factory(
                "FixedPointMathTestTest_lnContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_mulDivDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivDown() method."""

    _function_name = "test_mulDivDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDivDownContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDivDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDivDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDivDownContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_mulDivDownContractFunction0._type_signature: FixedPointMathTestTest_mulDivDownContractFunction0.factory(
                "FixedPointMathTestTest_mulDivDownContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_mulDivUpContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivUp() method."""

    _function_name = "test_mulDivUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDivUpContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDivUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDivUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDivUpContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_mulDivUpContractFunction0._type_signature: FixedPointMathTestTest_mulDivUpContractFunction0.factory(
                "FixedPointMathTestTest_mulDivUpContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_mulDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDown() method."""

    _function_name = "test_mulDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDownContractFunction(PypechainContractFunction):
    """ContractFunction for the test_mulDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDownContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_mulDownContractFunction0._type_signature: FixedPointMathTestTest_mulDownContractFunction0.factory(
                "FixedPointMathTestTest_mulDownContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_mulUpContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_mulUp() method."""

    _function_name = "test_mulUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulUpContractFunction(PypechainContractFunction):
    """ContractFunction for the test_mulUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulUpContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_mulUpContractFunction0._type_signature: FixedPointMathTestTest_mulUpContractFunction0.factory(
                "FixedPointMathTestTest_mulUpContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_powContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_pow() method."""

    _function_name = "test_pow"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_powContractFunction(PypechainContractFunction):
    """ContractFunction for the test_pow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_pow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_powContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_powContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_powContractFunction0._type_signature: FixedPointMathTestTest_powContractFunction0.factory(
                "FixedPointMathTestTest_powContractFunction0", **kwargs
            ),
        }
        return out


class FixedPointMathTestTest_updateWeightedAverageContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage() method."""

    _function_name = "test_updateWeightedAverage"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_updateWeightedAverageContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateWeightedAverage"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_updateWeightedAverageContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_updateWeightedAverageContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_updateWeightedAverageContractFunction0._type_signature: FixedPointMathTestTest_updateWeightedAverageContractFunction0.factory(
                "FixedPointMathTestTest_updateWeightedAverageContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage_fuzz(int,int,int,int) method."""

    _function_name = "test_updateWeightedAverage_fuzz"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage_fuzz method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateWeightedAverage_fuzz"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, average: int, totalWeight: int, delta: int, deltaWeight: int) -> FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0._type_signature: FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0.factory(
                "FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0",
                **kwargs,
            ),
        }
        return out


class FixedPointMathTestContractFunctions(ContractFunctions):
    """ContractFunctions for the FixedPointMathTest contract."""

    IS_TEST: FixedPointMathTestIS_TESTContractFunction

    excludeArtifacts: FixedPointMathTestExcludeArtifactsContractFunction

    excludeContracts: FixedPointMathTestExcludeContractsContractFunction

    excludeSenders: FixedPointMathTestExcludeSendersContractFunction

    failed: FixedPointMathTestFailedContractFunction

    targetArtifactSelectors: (
        FixedPointMathTestTargetArtifactSelectorsContractFunction
    )

    targetArtifacts: FixedPointMathTestTargetArtifactsContractFunction

    targetContracts: FixedPointMathTestTargetContractsContractFunction

    targetInterfaces: FixedPointMathTestTargetInterfacesContractFunction

    targetSelectors: FixedPointMathTestTargetSelectorsContractFunction

    targetSenders: FixedPointMathTestTargetSendersContractFunction

    test_differential_fuzz_pow: (
        FixedPointMathTestTest_differential_fuzz_powContractFunction
    )

    test_differential_fuzz_pow_zero: (
        FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction
    )

    test_divDown: FixedPointMathTestTest_divDownContractFunction

    test_divUp: FixedPointMathTestTest_divUpContractFunction

    test_exp: FixedPointMathTestTest_expContractFunction

    test_fail_divDown_zero_denominator: (
        FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction
    )

    test_fail_divUp_zero_denominator: (
        FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction
    )

    test_fail_exp_negative_or_zero_input: (
        FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction
    )

    test_fail_ln_negative_or_zero_input: (
        FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction
    )

    test_fail_mulDivDown_zero_denominator: (
        FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction
    )

    test_fail_mulDivUp_zero_denominator: (
        FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction
    )

    test_ln: FixedPointMathTestTest_lnContractFunction

    test_mulDivDown: FixedPointMathTestTest_mulDivDownContractFunction

    test_mulDivUp: FixedPointMathTestTest_mulDivUpContractFunction

    test_mulDown: FixedPointMathTestTest_mulDownContractFunction

    test_mulUp: FixedPointMathTestTest_mulUpContractFunction

    test_pow: FixedPointMathTestTest_powContractFunction

    test_updateWeightedAverage: (
        FixedPointMathTestTest_updateWeightedAverageContractFunction
    )

    test_updateWeightedAverage_fuzz: (
        FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction
    )

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.IS_TEST = FixedPointMathTestIS_TESTContractFunction.factory(
            "IS_TEST",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="IS_TEST",
        )
        self.excludeArtifacts = (
            FixedPointMathTestExcludeArtifactsContractFunction.factory(
                "excludeArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeArtifacts",
            )
        )
        self.excludeContracts = (
            FixedPointMathTestExcludeContractsContractFunction.factory(
                "excludeContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeContracts",
            )
        )
        self.excludeSenders = (
            FixedPointMathTestExcludeSendersContractFunction.factory(
                "excludeSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeSenders",
            )
        )
        self.failed = FixedPointMathTestFailedContractFunction.factory(
            "failed",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="failed",
        )
        self.targetArtifactSelectors = (
            FixedPointMathTestTargetArtifactSelectorsContractFunction.factory(
                "targetArtifactSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifactSelectors",
            )
        )
        self.targetArtifacts = (
            FixedPointMathTestTargetArtifactsContractFunction.factory(
                "targetArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifacts",
            )
        )
        self.targetContracts = (
            FixedPointMathTestTargetContractsContractFunction.factory(
                "targetContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetContracts",
            )
        )
        self.targetInterfaces = (
            FixedPointMathTestTargetInterfacesContractFunction.factory(
                "targetInterfaces",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetInterfaces",
            )
        )
        self.targetSelectors = (
            FixedPointMathTestTargetSelectorsContractFunction.factory(
                "targetSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSelectors",
            )
        )
        self.targetSenders = (
            FixedPointMathTestTargetSendersContractFunction.factory(
                "targetSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSenders",
            )
        )
        self.test_differential_fuzz_pow = FixedPointMathTestTest_differential_fuzz_powContractFunction.factory(
            "test_differential_fuzz_pow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_differential_fuzz_pow",
        )
        self.test_differential_fuzz_pow_zero = FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction.factory(
            "test_differential_fuzz_pow_zero",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_differential_fuzz_pow_zero",
        )
        self.test_divDown = (
            FixedPointMathTestTest_divDownContractFunction.factory(
                "test_divDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_divDown",
            )
        )
        self.test_divUp = FixedPointMathTestTest_divUpContractFunction.factory(
            "test_divUp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_divUp",
        )
        self.test_exp = FixedPointMathTestTest_expContractFunction.factory(
            "test_exp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_exp",
        )
        self.test_fail_divDown_zero_denominator = FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction.factory(
            "test_fail_divDown_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_divDown_zero_denominator",
        )
        self.test_fail_divUp_zero_denominator = FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction.factory(
            "test_fail_divUp_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_divUp_zero_denominator",
        )
        self.test_fail_exp_negative_or_zero_input = FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction.factory(
            "test_fail_exp_negative_or_zero_input",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_exp_negative_or_zero_input",
        )
        self.test_fail_ln_negative_or_zero_input = FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction.factory(
            "test_fail_ln_negative_or_zero_input",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_ln_negative_or_zero_input",
        )
        self.test_fail_mulDivDown_zero_denominator = FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction.factory(
            "test_fail_mulDivDown_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_mulDivDown_zero_denominator",
        )
        self.test_fail_mulDivUp_zero_denominator = FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction.factory(
            "test_fail_mulDivUp_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_mulDivUp_zero_denominator",
        )
        self.test_ln = FixedPointMathTestTest_lnContractFunction.factory(
            "test_ln",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_ln",
        )
        self.test_mulDivDown = (
            FixedPointMathTestTest_mulDivDownContractFunction.factory(
                "test_mulDivDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDivDown",
            )
        )
        self.test_mulDivUp = (
            FixedPointMathTestTest_mulDivUpContractFunction.factory(
                "test_mulDivUp",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDivUp",
            )
        )
        self.test_mulDown = (
            FixedPointMathTestTest_mulDownContractFunction.factory(
                "test_mulDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDown",
            )
        )
        self.test_mulUp = FixedPointMathTestTest_mulUpContractFunction.factory(
            "test_mulUp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_mulUp",
        )
        self.test_pow = FixedPointMathTestTest_powContractFunction.factory(
            "test_pow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_pow",
        )
        self.test_updateWeightedAverage = FixedPointMathTestTest_updateWeightedAverageContractFunction.factory(
            "test_updateWeightedAverage",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateWeightedAverage",
        )
        self.test_updateWeightedAverage_fuzz = FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction.factory(
            "test_updateWeightedAverage_fuzz",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateWeightedAverage_fuzz",
        )


class FixedPointMathTestLogContractEvent(ContractEvent):
    """ContractEvent for log."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_addressContractEvent(ContractEvent):
    """ContractEvent for log_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_arrayContractEvent(ContractEvent):
    """ContractEvent for log_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_bytesContractEvent(ContractEvent):
    """ContractEvent for log_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_intContractEvent(ContractEvent):
    """ContractEvent for log_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_addressContractEvent(ContractEvent):
    """ContractEvent for log_named_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_arrayContractEvent(ContractEvent):
    """ContractEvent for log_named_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_bytesContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_decimal_intContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_decimal_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_intContractEvent(ContractEvent):
    """ContractEvent for log_named_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_stringContractEvent(ContractEvent):
    """ContractEvent for log_named_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_stringContractEvent(ContractEvent):
    """ContractEvent for log_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_uintContractEvent(ContractEvent):
    """ContractEvent for log_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLogsContractEvent(ContractEvent):
    """ContractEvent for logs."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogsEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogsEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestContractEvents(ContractEvents):
    """ContractEvents for the FixedPointMathTest contract."""

    log: Type[FixedPointMathTestLogContractEvent]

    log_address: Type[FixedPointMathTestLog_addressContractEvent]

    log_array: Type[FixedPointMathTestLog_arrayContractEvent]

    log_bytes: Type[FixedPointMathTestLog_bytesContractEvent]

    log_bytes32: Type[FixedPointMathTestLog_bytes32ContractEvent]

    log_int: Type[FixedPointMathTestLog_intContractEvent]

    log_named_address: Type[FixedPointMathTestLog_named_addressContractEvent]

    log_named_array: Type[FixedPointMathTestLog_named_arrayContractEvent]

    log_named_bytes: Type[FixedPointMathTestLog_named_bytesContractEvent]

    log_named_bytes32: Type[FixedPointMathTestLog_named_bytes32ContractEvent]

    log_named_decimal_int: Type[
        FixedPointMathTestLog_named_decimal_intContractEvent
    ]

    log_named_decimal_uint: Type[
        FixedPointMathTestLog_named_decimal_uintContractEvent
    ]

    log_named_int: Type[FixedPointMathTestLog_named_intContractEvent]

    log_named_string: Type[FixedPointMathTestLog_named_stringContractEvent]

    log_named_uint: Type[FixedPointMathTestLog_named_uintContractEvent]

    log_string: Type[FixedPointMathTestLog_stringContractEvent]

    log_uint: Type[FixedPointMathTestLog_uintContractEvent]

    logs: Type[FixedPointMathTestLogsContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.log = cast(
            Type[FixedPointMathTestLogContractEvent],
            FixedPointMathTestLogContractEvent.factory(
                "log",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log",
            ),
        )
        self.log_address = cast(
            Type[FixedPointMathTestLog_addressContractEvent],
            FixedPointMathTestLog_addressContractEvent.factory(
                "log_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_address",
            ),
        )
        self.log_array = cast(
            Type[FixedPointMathTestLog_arrayContractEvent],
            FixedPointMathTestLog_arrayContractEvent.factory(
                "log_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_array",
            ),
        )
        self.log_bytes = cast(
            Type[FixedPointMathTestLog_bytesContractEvent],
            FixedPointMathTestLog_bytesContractEvent.factory(
                "log_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes",
            ),
        )
        self.log_bytes32 = cast(
            Type[FixedPointMathTestLog_bytes32ContractEvent],
            FixedPointMathTestLog_bytes32ContractEvent.factory(
                "log_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes32",
            ),
        )
        self.log_int = cast(
            Type[FixedPointMathTestLog_intContractEvent],
            FixedPointMathTestLog_intContractEvent.factory(
                "log_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_int",
            ),
        )
        self.log_named_address = cast(
            Type[FixedPointMathTestLog_named_addressContractEvent],
            FixedPointMathTestLog_named_addressContractEvent.factory(
                "log_named_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_address",
            ),
        )
        self.log_named_array = cast(
            Type[FixedPointMathTestLog_named_arrayContractEvent],
            FixedPointMathTestLog_named_arrayContractEvent.factory(
                "log_named_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_array",
            ),
        )
        self.log_named_bytes = cast(
            Type[FixedPointMathTestLog_named_bytesContractEvent],
            FixedPointMathTestLog_named_bytesContractEvent.factory(
                "log_named_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes",
            ),
        )
        self.log_named_bytes32 = cast(
            Type[FixedPointMathTestLog_named_bytes32ContractEvent],
            FixedPointMathTestLog_named_bytes32ContractEvent.factory(
                "log_named_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes32",
            ),
        )
        self.log_named_decimal_int = cast(
            Type[FixedPointMathTestLog_named_decimal_intContractEvent],
            FixedPointMathTestLog_named_decimal_intContractEvent.factory(
                "log_named_decimal_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_int",
            ),
        )
        self.log_named_decimal_uint = cast(
            Type[FixedPointMathTestLog_named_decimal_uintContractEvent],
            FixedPointMathTestLog_named_decimal_uintContractEvent.factory(
                "log_named_decimal_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_uint",
            ),
        )
        self.log_named_int = cast(
            Type[FixedPointMathTestLog_named_intContractEvent],
            FixedPointMathTestLog_named_intContractEvent.factory(
                "log_named_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_int",
            ),
        )
        self.log_named_string = cast(
            Type[FixedPointMathTestLog_named_stringContractEvent],
            FixedPointMathTestLog_named_stringContractEvent.factory(
                "log_named_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_string",
            ),
        )
        self.log_named_uint = cast(
            Type[FixedPointMathTestLog_named_uintContractEvent],
            FixedPointMathTestLog_named_uintContractEvent.factory(
                "log_named_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_uint",
            ),
        )
        self.log_string = cast(
            Type[FixedPointMathTestLog_stringContractEvent],
            FixedPointMathTestLog_stringContractEvent.factory(
                "log_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_string",
            ),
        )
        self.log_uint = cast(
            Type[FixedPointMathTestLog_uintContractEvent],
            FixedPointMathTestLog_uintContractEvent.factory(
                "log_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_uint",
            ),
        )
        self.logs = cast(
            Type[FixedPointMathTestLogsContractEvent],
            FixedPointMathTestLogsContractEvent.factory(
                "logs",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="logs",
            ),
        )


class FixedPointMathTestContract(Contract):
    """A web3.py Contract class for the FixedPointMathTest contract."""

    abi: ABI = fixedpointmathtest_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x6080604052600c8054600160ff199182168117909255601e8054909116909117905534801561002d57600080fd5b50614fed8061003d6000396000f3fe608060405234801561001057600080fd5b50600436106101da5760003560e01c806366d9a9a011610104578063ba414fa6116100a2578063fa7626d411610071578063fa7626d41461031f578063fb588a481461032c578063fb928cde14610334578063fbba16f91461033c57600080fd5b8063ba414fa6146102e4578063e20c9f71146102fc578063e3bfaadd14610304578063ed6fe59a1461030c57600080fd5b8063916a17c6116100de578063916a17c6146102c4578063a7d78b82146102cc578063b1cd1825146102d4578063b5508aa9146102dc57600080fd5b806366d9a9a01461029257806385226c81146102a75780638d9108a5146102bc57600080fd5b8063343de8cb1161017c57806352ff9e5f1161014b57806352ff9e5f14610272578063545d72021461027a5780635c7b14aa1461028257806362ca87971461028a57600080fd5b8063343de8cb1461025257806339c71a7d1461025a5780633e5e3c23146102625780633f7286f41461026a57600080fd5b80631ed7831c116101b85780631ed7831c1461020f57806320423cbc1461022d5780632ab1873c146102355780632ade38801461023d57600080fd5b806307d72d02146101df5780630faf012b146101f45780631a0c8ad814610207575b600080fd5b6101f26101ed36600461419f565b610344565b005b6101f26102023660046141b8565b61040f565b6101f26104f6565b610217610725565b60405161022491906141da565b60405180910390f35b6101f2610787565b6101f261099f565b610245610a89565b6040516102249190614227565b6101f2610bcb565b6101f26112b0565b6102176113bd565b61021761141d565b6101f261147d565b6101f2611543565b6101f2611992565b6101f2611b80565b61029a611cbe565b604051610224919061431c565b6102af611da4565b60405161022491906143d1565b6101f2611e74565b61029a611f40565b6101f2612026565b6101f26121d0565b6102af61229e565b6102ec61236e565b6040519015158152602001610224565b610217612412565b6101f2612472565b6101f261031a366004614463565b61298b565b601e546102ec9060ff1681565b6101f2612ae1565b6101f2612bb3565b6101f2612e40565b610354816000600160ff1b612f13565b9050600060405161036490614192565b604051809103906000f080158015610380573d6000803e3d6000fd5b50604051632e4c697f60e01b8152600481018490526000602482018190529192506001600160a01b03831690632e4c697f90604401602060405180830381865afa1580156103d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f69190614495565b905061040a81670de0b6b3a7640000612f95565b505050565b61041f826000600160ff1b612f13565b915061042e8160006001612f13565b9050600060405161043e90614192565b604051809103906000f08015801561045a573d6000803e3d6000fd5b50604051632e4c697f60e01b815260048101859052602481018490529091506000906001600160a01b03831690632e4c697f90604401602060405180830381865afa1580156104ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d19190614495565b905060006104df8585612ffc565b90506104ef8282620186a0613172565b5050505050565b600060405161050490614192565b604051809103906000f080158015610520573d6000803e3d6000fd5b5060405163e46751e360e01b8152670de0b6b3a764000060048201529091506105a6906001600160a01b0383169063e46751e390602401602060405180830381865afa158015610574573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105989190614495565b6725b946ebc0b361736131e8565b60405163e46751e360e01b815260006004820152610621906001600160a01b0383169063e46751e390602401602060405180830381865afa1580156105ef573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106139190614495565b670de0b6b3a76400006131e8565b60405163e46751e360e01b8152670de0b6b3a763ffff1960048201526106a4906001600160a01b0383169063e46751e390602401602060405180830381865afa158015610672573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106969190614495565b67051af86713316a916131e8565b60405163e46751e360e01b8152680248ce36a70cb26b3e196004820152610722906001600160a01b0383169063e46751e3906024015b602060405180830381865afa1580156106f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071b9190614495565b60006131e8565b50565b6060601680548060200260200160405190810160405280929190818152602001828054801561077d57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161075f575b5050505050905090565b600060405161079590614192565b604051809103906000f0801580156107b1573d6000803e3d6000fd5b50604051634dd2fa9760e11b8152671158e460913d000060048201526706f05b59d3b200006024820152909150610846906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa158015610814573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108389190614495565b6722b1c8c1227a0000612f95565b604051634dd2fa9760e11b81526729a2241af62c00006004820152670de0b6b3a764000060248201526108d7906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa1580156108a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108c99190614495565b6729a2241af62c0000612f95565b604051634dd2fa9760e11b8152600260048201526d04ee2d6d415b85acef81000000006024820152610960906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa158015610935573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109599190614495565b6000612f95565b604051634dd2fa9760e11b815260006004820152670de0b6b3a76400006024820152610722906001600160a01b03831690639ba5f52e90604401610918565b60006040516109ad90614192565b604051809103906000f0801580156109c9573d6000803e3d6000fd5b50604051638e6f235360e01b8152670de0b6b3a76400006004820152909150610a05906001600160a01b03831690638e6f2353906024016106da565b604051638e6f235360e01b815269d3c21bcecceda10000006004820152610722906001600160a01b03831690638e6f235390602401602060405180830381865afa158015610a57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7b9190614495565b67bfba8da79e1e89b86131e8565b6060601d805480602002602001604051908101604052809291908181526020016000905b82821015610bc257600084815260208082206040805180820182526002870290920180546001600160a01b03168352600181018054835181870281018701909452808452939591948681019491929084015b82821015610bab578382906000526020600020018054610b1e906144ae565b80601f0160208091040260200160405190810160405280929190818152602001828054610b4a906144ae565b8015610b975780601f10610b6c57610100808354040283529160200191610b97565b820191906000526020600020905b815481529060010190602001808311610b7a57829003601f168201915b505050505081526020019060010190610aff565b505050508152505081526020019060010190610aad565b50505050905090565b6000604051610bd990614192565b604051809103906000f080158015610bf5573d6000803e3d6000fd5b50604051624af5ab60e61b81526b0813f3978f8940984400000060048201526b019d971e4fe8401e7400000060248201526b033b2e3c9fd0803ce80000006044820152909150610ca7906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610c71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c959190614495565b6b0409f9cbc7c4a04c22000000612f95565b604051624af5ab60e61b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152670de0b6b3a76400006044820152610d45906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610d13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d379190614495565b671158e460913d0000612f95565b604051624af5ab60e61b8152630ee6b28060048201526302faf08060248201526305f5e1006044820152610dd3906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610da5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc99190614495565b6307735940612f95565b604051624af5ab60e61b8152610171600482015261010f6024820152606460448201819052610e57916001600160a01b038416916312bd6ac09101602060405180830381865afa158015610e2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4f9190614495565b6103e8612f95565b604051624af5ab60e61b81526b033b2e3c9fd0803ce80000006004820181905260248201526b06765c793fa10079d00000006044820152610efa906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610ec4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ee89190614495565b6b019d971e4fe8401e74000000612f95565b604051624af5ab60e61b8152670de0b6b3a7640000600482018190526024820152671bc16d674ec800006044820152610f91906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610f5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f839190614495565b6706f05b59d3b20000612f95565b604051624af5ab60e61b81526305f5e100600482018190526024820152630bebc200604482015261101c906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610fee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110129190614495565b6302faf080612f95565b604051624af5ab60e61b81526b06765c793fa10079d0000000600482018190526b09b18ab5df7180b6b8000000602483015260448201526110bf906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015611089573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110ad9190614495565b6b09b18ab5df7180b6b8000000612f95565b604051624af5ab60e61b81526729a2241af62c000060048201819052671bc16d674ec8000060248301526044820152611156906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015611124573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111489190614495565b671bc16d674ec80000612f95565b604051624af5ab60e61b8152630bebc200600482018190526311e1a300602483015260448201526111e1906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa1580156111b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d79190614495565b6311e1a300612f95565b604051624af5ab60e61b815260006004820152670de0b6b3a7640000602482018190526044820152611226906001600160a01b038316906312bd6ac090606401610918565b604051624af5ab60e61b8152670de0b6b3a76400006004820181905260006024830152604482015261126b906001600160a01b038316906312bd6ac090606401610918565b604051624af5ab60e61b81526000600482018190526024820152670de0b6b3a76400006044820152610722906001600160a01b038316906312bd6ac090606401610918565b60006040516112be90614192565b604051809103906000f0801580156112da573d6000803e3d6000fd5b509050600080516020614f9883398151915260001c6001600160a01b031663f48448146040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561132957600080fd5b505af115801561133d573d6000803e3d6000fd5b5050604051634dd2fa9760e11b8152670de0b6b3a76400006004820152600060248201526001600160a01b0384169250639ba5f52e91506044015b602060405180830381865afa158015611395573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113b99190614495565b5050565b6060601880548060200260200160405190810160405280929190818152602001828054801561077d576020028201919060005260206000209081546001600160a01b0316815260019091019060200180831161075f575050505050905090565b6060601780548060200260200160405190810160405280929190818152602001828054801561077d576020028201919060005260206000209081546001600160a01b0316815260019091019060200180831161075f575050505050905090565b600060405161148b90614192565b604051809103906000f0801580156114a7573d6000803e3d6000fd5b50604051630618f58760e51b815263e61b497560e01b6004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d9063c31eb0e090602401600060405180830381600087803b1580156114fe57600080fd5b505af1158015611512573d6000803e3d6000fd5b5050604051638e6f235360e01b8152600060048201526001600160a01b0384169250638e6f23539150602401611378565b600060405161155190614192565b604051809103906000f08015801561156d573d6000803e3d6000fd5b50604051632d9efb8160e21b81526b0813f3978f8940984400000060048201526b019d971e4fe8401e7400000060248201526b033b2e3c9fd0803ce800000060448201529091506115d1906001600160a01b0383169063b67bee0490606401610c54565b604051632d9efb8160e21b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152670de0b6b3a76400006044820152611625906001600160a01b0383169063b67bee0490606401610cf6565b604051632d9efb8160e21b8152630ee6b28060048201526302faf08060248201526305f5e100604482015261166d906001600160a01b0383169063b67bee0490606401610d88565b604051632d9efb8160e21b8152610171600482015261010f60248201526064604482018190526116f2916001600160a01b0384169163b67bee049101602060405180830381865afa1580156116c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116ea9190614495565b6103e7612f95565b604051632d9efb8160e21b81526b033b2e3c9fd0803ce80000006004820181905260248201526b06765c793fa10079d00000006044820152611747906001600160a01b0383169063b67bee0490606401610ea7565b604051632d9efb8160e21b8152670de0b6b3a7640000600482018190526024820152671bc16d674ec800006044820152611794906001600160a01b0383169063b67bee0490606401610f42565b604051632d9efb8160e21b81526305f5e100600482018190526024820152630bebc20060448201526117d9906001600160a01b0383169063b67bee0490606401610fd1565b604051632d9efb8160e21b81526b06765c793fa10079d0000000600482018190526b09b18ab5df7180b6b80000006024830152604482015261182e906001600160a01b0383169063b67bee049060640161106c565b604051632d9efb8160e21b81526729a2241af62c000060048201819052671bc16d674ec800006024830152604482015261187b906001600160a01b0383169063b67bee0490606401611107565b604051632d9efb8160e21b8152630bebc200600482018190526311e1a300602483015260448201526118c0906001600160a01b0383169063b67bee0490606401611196565b604051632d9efb8160e21b815260006004820152670de0b6b3a7640000602482018190526044820152611906906001600160a01b0383169063b67bee0490606401610918565b604051632d9efb8160e21b8152670de0b6b3a76400006004820181905260006024830152604482015261194c906001600160a01b0383169063b67bee0490606401610918565b604051632d9efb8160e21b81526000600482018190526024820152670de0b6b3a76400006044820152610722906001600160a01b0383169063b67bee0490606401610918565b60006040516119a090614192565b604051809103906000f0801580156119bc573d6000803e3d6000fd5b50604051633cf93e1f60e21b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152909150611a06906001600160a01b0383169063f3e4f87c90604401610cf6565b604051633cf93e1f60e21b81526729a2241af62c00006004820152670de0b6b3a76400006024820152611a4c906001600160a01b0383169063f3e4f87c90604401610888565b604051633cf93e1f60e21b8152610171600482015261010f6024820152611aca906001600160a01b0383169063f3e4f87c906044015b602060405180830381865afa158015611a9f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac39190614495565b6001612f95565b604051633cf93e1f60e21b815260006004820152670de0b6b3a76400006024820152611b09906001600160a01b0383169063f3e4f87c90604401610918565b604051633cf93e1f60e21b8152670de0b6b3a7640000600482015260006024820152611b48906001600160a01b0383169063f3e4f87c90604401610918565b604051633cf93e1f60e21b81526000600482018190526024820152610722906001600160a01b0383169063f3e4f87c90604401610918565b6000604051611b8e90614192565b604051809103906000f080158015611baa573d6000803e3d6000fd5b5060405163cbe8623f60e01b8152671158e460913d000060048201526706f05b59d3b200006024820152909150611bf4906001600160a01b0383169063cbe8623f906044016107f7565b60405163cbe8623f60e01b81526729a2241af62c00006004820152670de0b6b3a76400006024820152611c3a906001600160a01b0383169063cbe8623f90604401610888565b60405163cbe8623f60e01b8152600260048201526d04ee2d6d415b85acef81000000006024820152611c7f906001600160a01b0383169063cbe8623f90604401611a82565b60405163cbe8623f60e01b815260006004820152670de0b6b3a76400006024820152610722906001600160a01b0383169063cbe8623f90604401610918565b6060601b805480602002602001604051908101604052809291908181526020016000905b82821015610bc25760008481526020908190206040805180820182526002860290920180546001600160a01b03168352600181018054835181870281018701909452808452939491938583019392830182828015611d8c57602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b03191681526020019060040190602082600301049283019260010382029150808411611d4e5790505b50505050508152505081526020019060010190611ce2565b6060601a805480602002602001604051908101604052809291908181526020016000905b82821015610bc2578382906000526020600020018054611de7906144ae565b80601f0160208091040260200160405190810160405280929190818152602001828054611e13906144ae565b8015611e605780601f10611e3557610100808354040283529160200191611e60565b820191906000526020600020905b815481529060010190602001808311611e4357829003601f168201915b505050505081526020019060010190611dc8565b6000604051611e8290614192565b604051809103906000f080158015611e9e573d6000803e3d6000fd5b509050600080516020614f9883398151915260001c6001600160a01b031663f48448146040518163ffffffff1660e01b8152600401600060405180830381600087803b158015611eed57600080fd5b505af1158015611f01573d6000803e3d6000fd5b505060405163cbe8623f60e01b8152670de0b6b3a76400006004820152600060248201526001600160a01b038416925063cbe8623f9150604401611378565b6060601c805480602002602001604051908101604052809291908181526020016000905b82821015610bc25760008481526020908190206040805180820182526002860290920180546001600160a01b0316835260018101805483518187028101870190945280845293949193858301939283018282801561200e57602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b03191681526020019060040190602082600301049283019260010382029150808411611fd05790505b50505050508152505081526020019060010190611f64565b600060405161203490614192565b604051809103906000f080158015612050573d6000803e3d6000fd5b50604051630c9b988160e01b81526722b1c8c1227a000060048201526706f05b59d3b20000602482015290915061209a906001600160a01b03831690630c9b988190604401610cf6565b604051630c9b988160e01b81526729a2241af62c00006004820152670de0b6b3a764000060248201526120e0906001600160a01b03831690630c9b988190604401610888565b604051630c9b988160e01b8152610171600482015261010f602482015261211a906001600160a01b03831690630c9b988190604401610918565b604051630c9b988160e01b815260006004820152670de0b6b3a76400006024820152612159906001600160a01b03831690630c9b988190604401610918565b604051630c9b988160e01b8152670de0b6b3a7640000600482015260006024820152612198906001600160a01b03831690630c9b988190604401610918565b604051630c9b988160e01b81526000600482018190526024820152610722906001600160a01b03831690630c9b988190604401610918565b60006040516121de90614192565b604051809103906000f0801580156121fa573d6000803e3d6000fd5b50604051630618f58760e51b81526373a2d6b160e01b6004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d9063c31eb0e090602401600060405180830381600087803b15801561225157600080fd5b505af1158015612265573d6000803e3d6000fd5b505060405163e46751e360e01b8152680755bf798b4a1bf1e560048201526001600160a01b038416925063e46751e39150602401611378565b60606019805480602002602001604051908101604052809291908181526020016000905b82821015610bc25783829060005260206000200180546122e1906144ae565b80601f016020809104026020016040519081016040528092919081815260200182805461230d906144ae565b801561235a5780601f1061232f5761010080835404028352916020019161235a565b820191906000526020600020905b81548152906001019060200180831161233d57829003601f168201915b5050505050815260200190600101906122c2565b60085460009060ff1615612386575060085460ff1690565b604051630667f9d760e41b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d600482018190526519985a5b195960d21b602483015260009163667f9d7090604401602060405180830381865afa1580156123e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061240b9190614495565b1415905090565b6060601580548060200260200160405190810160405280929190818152602001828054801561077d576020028201919060005260206000209081546001600160a01b0316815260019091019060200180831161075f575050505050905090565b600060405161248090614192565b604051809103906000f08015801561249c573d6000803e3d6000fd5b50604051632e4c697f60e01b815260006004820181905260248201819052919250819081906001600160a01b03851690632e4c697f90604401602060405180830381865afa1580156124f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125169190614495565b905060006125248484612ffc565b90506125308282612f95565b604051632e4c697f60e01b8152693f870857a3e0e38000006004820181905260006024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa15801561258e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125b29190614495565b91506125be8484612ffc565b90506125ca8282612f95565b604051632e4c697f60e01b8152600060048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa158015612626573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061264a9190614495565b91506126568484612ffc565b90506126628282612f95565b604051632e4c697f60e01b8152693f870857a3e0e380000060048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa1580156126c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126eb9190614495565b91506126f78484612ffc565b90506127078282620186a0613172565b604051632e4c697f60e01b815269261dd1ce2f208880000060048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa15801561276c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127909190614495565b915061279c8484612ffc565b90506127ac8282620186a0613172565b604051632e4c697f60e01b81526923210168cbc69589efa160048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa158015612811573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128359190614495565b91506128418484612ffc565b90506128518282620186a0613172565b604051632e4c697f60e01b81526910522d11711bd8e4997160048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa1580156128b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128da9190614495565b91506128e68484612ffc565b90506128f68282620186a0613172565b604051632e4c697f60e01b81526903e89f12e2375d69fb1060048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa15801561295b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061297f9190614495565b91506104df8484612ffc565b600060405161299990614192565b604051809103906000f0801580156129b5573d6000803e3d6000fd5b5090506129d285633b9aca006a52b7d2dcc80cd2e4000000612f13565b94506129ee84633b9aca006a52b7d2dcc80cd2e4000000612f13565b9350612a0a83633b9aca006a52b7d2dcc80cd2e4000000612f13565b9250612a2682633b9aca006a52b7d2dcc80cd2e4000000612f13565b6040516381e5f7c960e01b815260048101879052602481018690526044810185905260648101829052600160848201529092506000906001600160a01b038316906381e5f7c99060a401602060405180830381865afa158015612a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ab19190614495565b9050612ac681612ac18887613227565b61323f565b612ad981612ad4888761327e565b613294565b505050505050565b6000604051612aef90614192565b604051809103906000f080158015612b0b573d6000803e3d6000fd5b509050600080516020614f9883398151915260001c6001600160a01b031663f48448146040518163ffffffff1660e01b8152600401600060405180830381600087803b158015612b5a57600080fd5b505af1158015612b6e573d6000803e3d6000fd5b5050604051624af5ab60e61b8152670de0b6b3a7640000600482018190526024820152600060448201526001600160a01b03841692506312bd6ac09150606401611378565b6000604051612bc190614192565b604051809103906000f080158015612bdd573d6000803e3d6000fd5b506040516381e5f7c960e01b8152671bc16d674ec800006004820152670de0b6b3a764000060248201526729a2241af62c000060448201526000606482015260016084820152909150612c43906001600160a01b038316906381e5f7c99060a401611107565b6040516381e5f7c960e01b8152670de0b6b3a7640000600482018190526024820181905260448201819052606482015260016084820152612ce2906001600160a01b038316906381e5f7c99060a4015b602060405180830381865afa158015612cb0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cd49190614495565b670de0b6b3a7640000612f95565b6040516381e5f7c960e01b8152670de0b6b3a7640000600482018190526024820181905260448201819052606482015260006084820152612d36906001600160a01b038316906381e5f7c99060a401610918565b6040516381e5f7c960e01b8152670de0b6b3a764000060048201819052671bc16d674ec80000602483015260448201819052606482015260006084820152612d91906001600160a01b038316906381e5f7c99060a401612c93565b6040516381e5f7c960e01b815268056bc75e2d631000006004820152678ac7230489e8000060248201819052680ad78ebc5ac62000006044830152606482015260016084820152610722906001600160a01b038316906381e5f7c99060a401602060405180830381865afa158015612e0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e319190614495565b680821ab0d4414980000612f95565b6000604051612e4e90614192565b604051809103906000f080158015612e6a573d6000803e3d6000fd5b509050600080516020614f9883398151915260001c6001600160a01b031663f48448146040518163ffffffff1660e01b8152600401600060405180830381600087803b158015612eb957600080fd5b505af1158015612ecd573d6000803e3d6000fd5b5050604051632d9efb8160e21b8152670de0b6b3a7640000600482018190526024820152600060448201526001600160a01b038416925063b67bee049150606401611378565b600081831115612f5a5760405162461bcd60e51b815260206004820152600e60248201526d098d2c47440dad2dc407c40dac2f60931b604482015260640160405180910390fd5b6000612f6684846144fe565b612f71906001614511565b90506000612f7f828761453a565b9050612f8b8582614511565b9695505050505050565b60405163260a5b1560e21b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906398296c54906044015b60006040518083038186803b158015612fe857600080fd5b505afa158015612ad9573d6000803e3d6000fd5b6000816000036130155750670de0b6b3a764000061316c565b826000036130255750600061316c565b61303560ff84901c1560066132d3565b8261305961305068056bc75e2d63100000600160fe1b61454e565b841060076132d3565b8260008261307767016345785d8a0000670de0b6b3a7640000614562565b12801561309c5750613099670de0b6b3a764000067016345785d8a0000614589565b83125b156131055760006130ac846132e1565b9050670de0b6b3a7640000836130c282846145b1565b6130cc91906145c5565b6130d691906145f5565b836130e9670de0b6b3a7640000846145f5565b6130f391906145c5565b6130fd9190614589565b91505061311c565b8161310f84613518565b61311991906145c5565b90505b61312e670de0b6b3a7640000826145f5565b905061315d81680238fd42c5cf03ffff1913158015613156575068070c1cc73b00c800008213155b60086132d3565b61316681613afe565b93505050505b92915050565b604051630b6903e360e11b8152600481018490526024810183905260448101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906316d207c69060640160006040518083038186803b1580156131cb57600080fd5b505afa1580156131df573d6000803e3d6000fd5b50505050505050565b60405163fe74f05b60e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063fe74f05b90604401612fd0565b60008183116132365782613238565b815b9392505050565b60405163a8d4d1d960e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063a8d4d1d990604401612fd0565b600081831161328d5781613238565b5090919050565b604051638466f41560e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d90638466f41590604401612fd0565b816113b9576113b981614135565b60006132f5670de0b6b3a7640000836145c5565b915060006133116a0c097ce7bc90715b34b9f160241b84614589565b6a0c097ce7bc90715b34b9f160241b61332a8186614562565b61333491906145c5565b61333e91906145f5565b905060006a0c097ce7bc90715b34b9f160241b61335b83806145c5565b61336591906145f5565b905081806a0c097ce7bc90715b34b9f160241b61338284836145c5565b61338c91906145f5565b91506133996003836145f5565b6133a39082614589565b90506a0c097ce7bc90715b34b9f160241b6133be84846145c5565b6133c891906145f5565b91506133d56005836145f5565b6133df9082614589565b90506a0c097ce7bc90715b34b9f160241b6133fa84846145c5565b61340491906145f5565b91506134116007836145f5565b61341b9082614589565b90506a0c097ce7bc90715b34b9f160241b61343684846145c5565b61344091906145f5565b915061344d6009836145f5565b6134579082614589565b90506a0c097ce7bc90715b34b9f160241b61347284846145c5565b61347c91906145f5565b9150613489600b836145f5565b6134939082614589565b90506a0c097ce7bc90715b34b9f160241b6134ae84846145c5565b6134b891906145f5565b91506134c5600d836145f5565b6134cf9082614589565b90506a0c097ce7bc90715b34b9f160241b6134ea84846145c5565b6134f491906145f5565b9150613501600f836145f5565b61350b9082614589565b9050612f8b8160026145c5565b6000670de0b6b3a76400008212156135585761354f82613540670de0b6b3a7640000806145c5565b61354a91906145f5565b613518565b61316c90614623565b6000613584670de0b6b3a7640000770195e54c5dd42177f53a27172fa9ec6302628270000000006145c5565b83126135c4576135ac770195e54c5dd42177f53a27172fa9ec630262827000000000846145f5565b92506135c16806f05b59d3b200000082614589565b90505b6135e2670de0b6b3a76400006b1425982cf597cd205cef73806145c5565b8312613616576135fe6b1425982cf597cd205cef7380846145f5565b92506136136803782dace9d900000082614589565b90505b6136216064826145c5565b905061362e6064846145c5565b92506e01855144814a7ff805980ff0084000831261368b576e01855144814a7ff805980ff008400061366968056bc75e2d63100000856145c5565b61367391906145f5565b925061368868ad78ebc5ac6200000082614589565b90505b6b02df0ab5a80a22c61ab5a70083126136e0576b02df0ab5a80a22c61ab5a7006136be68056bc75e2d63100000856145c5565b6136c891906145f5565b92506136dd6856bc75e2d63100000082614589565b90505b693f1fce3da636ea5cf850831261373157693f1fce3da636ea5cf85061370f68056bc75e2d63100000856145c5565b61371991906145f5565b925061372e682b5e3af16b1880000082614589565b90505b690127fa27722cc06cc5e2831261378257690127fa27722cc06cc5e261376068056bc75e2d63100000856145c5565b61376a91906145f5565b925061377f6815af1d78b58c40000082614589565b90505b68280e60114edb805d0383126137d15768280e60114edb805d036137af68056bc75e2d63100000856145c5565b6137b991906145f5565b92506137ce680ad78ebc5ac620000082614589565b90505b680ebc5fb41746121110831261382057680ebc5fb417461211106137fe68056bc75e2d63100000856145c5565b61380891906145f5565b925061381d68056bc75e2d6310000082614589565b90505b6808f00f760a4b2db55d831261386f576808f00f760a4b2db55d61384d68056bc75e2d63100000856145c5565b61385791906145f5565b925061386c6802b5e3af16b188000082614589565b90505b6806f5f177578893793783126138be576806f5f177578893793761389c68056bc75e2d63100000856145c5565b6138a691906145f5565b92506138bb68015af1d78b58c4000082614589565b90505b6806248f33704b286603831261390c576806248f33704b2866036138eb68056bc75e2d63100000856145c5565b6138f591906145f5565b925061390967ad78ebc5ac62000082614589565b90505b6805c548670b9510e7ac831261395a576805c548670b9510e7ac61393968056bc75e2d63100000856145c5565b61394391906145f5565b92506139576756bc75e2d631000082614589565b90505b600061396f68056bc75e2d6310000085614589565b68056bc75e2d631000006139838187614562565b61398d91906145c5565b61399791906145f5565b9050600068056bc75e2d631000006139af83806145c5565b6139b991906145f5565b9050818068056bc75e2d631000006139d184836145c5565b6139db91906145f5565b91506139e86003836145f5565b6139f29082614589565b905068056bc75e2d63100000613a0884846145c5565b613a1291906145f5565b9150613a1f6005836145f5565b613a299082614589565b905068056bc75e2d63100000613a3f84846145c5565b613a4991906145f5565b9150613a566007836145f5565b613a609082614589565b905068056bc75e2d63100000613a7684846145c5565b613a8091906145f5565b9150613a8d6009836145f5565b613a979082614589565b905068056bc75e2d63100000613aad84846145c5565b613ab791906145f5565b9150613ac4600b836145f5565b613ace9082614589565b9050613adb6002826145c5565b90506064613ae98287614589565b613af391906145f5565b979650505050505050565b6000613b2d680238fd42c5cf03ffff198312158015613b26575068070c1cc73b00c800008313155b60096132d3565b6000821215613b6357613b47613b4283614623565b613afe565b613b59670de0b6b3a7640000806145c5565b61316c91906145f5565b60006806f05b59d3b20000008312613baa57613b886806f05b59d3b200000084614562565b9250770195e54c5dd42177f53a27172fa9ec6302628270000000009050613be7565b6803782dace9d90000008312613be357613bcd6803782dace9d900000084614562565b92506b1425982cf597cd205cef73809050613be7565b5060015b613bf26064846145c5565b925068056bc75e2d6310000068ad78ebc5ac620000008412613c5357613c2168ad78ebc5ac6200000085614562565b935068056bc75e2d63100000613c466e01855144814a7ff805980ff0084000836145c5565b613c5091906145f5565b90505b6856bc75e2d6310000008412613ca557613c766856bc75e2d63100000085614562565b935068056bc75e2d63100000613c986b02df0ab5a80a22c61ab5a700836145c5565b613ca291906145f5565b90505b682b5e3af16b188000008412613cf557613cc8682b5e3af16b1880000085614562565b935068056bc75e2d63100000613ce8693f1fce3da636ea5cf850836145c5565b613cf291906145f5565b90505b6815af1d78b58c4000008412613d4557613d186815af1d78b58c40000085614562565b935068056bc75e2d63100000613d38690127fa27722cc06cc5e2836145c5565b613d4291906145f5565b90505b680ad78ebc5ac62000008412613d9457613d68680ad78ebc5ac620000085614562565b935068056bc75e2d63100000613d8768280e60114edb805d03836145c5565b613d9191906145f5565b90505b68056bc75e2d631000008412613de357613db768056bc75e2d6310000085614562565b935068056bc75e2d63100000613dd6680ebc5fb41746121110836145c5565b613de091906145f5565b90505b6802b5e3af16b18800008412613e3257613e066802b5e3af16b188000085614562565b935068056bc75e2d63100000613e256808f00f760a4b2db55d836145c5565b613e2f91906145f5565b90505b68015af1d78b58c400008412613e8157613e5568015af1d78b58c4000085614562565b935068056bc75e2d63100000613e746806f5f1775788937937836145c5565b613e7e91906145f5565b90505b68056bc75e2d6310000084613e968183614589565b9150600268056bc75e2d63100000613eae88846145c5565b613eb891906145f5565b613ec291906145f5565b9050613ece8183614589565b9150600368056bc75e2d63100000613ee688846145c5565b613ef091906145f5565b613efa91906145f5565b9050613f068183614589565b9150600468056bc75e2d63100000613f1e88846145c5565b613f2891906145f5565b613f3291906145f5565b9050613f3e8183614589565b9150600568056bc75e2d63100000613f5688846145c5565b613f6091906145f5565b613f6a91906145f5565b9050613f768183614589565b9150600668056bc75e2d63100000613f8e88846145c5565b613f9891906145f5565b613fa291906145f5565b9050613fae8183614589565b9150600768056bc75e2d63100000613fc688846145c5565b613fd091906145f5565b613fda91906145f5565b9050613fe68183614589565b9150600868056bc75e2d63100000613ffe88846145c5565b61400891906145f5565b61401291906145f5565b905061401e8183614589565b9150600968056bc75e2d6310000061403688846145c5565b61404091906145f5565b61404a91906145f5565b90506140568183614589565b9150600a68056bc75e2d6310000061406e88846145c5565b61407891906145f5565b61408291906145f5565b905061408e8183614589565b9150600b68056bc75e2d631000006140a688846145c5565b6140b091906145f5565b6140ba91906145f5565b90506140c68183614589565b9150600c68056bc75e2d631000006140de88846145c5565b6140e891906145f5565b6140f291906145f5565b90506140fe8183614589565b915060648468056bc75e2d6310000061411785876145c5565b61412191906145f5565b61412b91906145c5565b612f8b91906145f5565b62461bcd60e51b600090815260206004526007602452600a808304818106603090810160081b83860601918390049283060160101b016642414c230000300160c81b6044819052610722926210905360ea1b916242414c91606490fd5b6109588061464083390190565b6000602082840312156141b157600080fd5b5035919050565b600080604083850312156141cb57600080fd5b50508035926020909101359150565b6020808252825182820181905260009190848201906040850190845b8181101561421b5783516001600160a01b0316835292840192918401916001016141f6565b50909695505050505050565b600060208083018184528085518083526040925060408601915060408160051b87010184880160005b8381101561430e57603f19898403018552815180516001600160a01b031684528701518784018790528051878501819052908801906060600582901b86018101919086019060005b818110156142f857878403605f190183528451805180865260005b818110156142d1578e81840101518f82890101528e810190506142b3565b5060008682018f0152958d0195601f01601f19169094018c019350918b0191600101614298565b5050509588019593505090860190600101614250565b509098975050505050505050565b600060208083018184528085518083526040925060408601915060408160051b8701018488016000805b848110156143c257898403603f19018652825180516001600160a01b03168552880151888501889052805188860181905290890190839060608701905b808310156143ad5783516001600160e01b0319168252928b019260019290920191908b0190614383565b50978a01979550505091870191600101614346565b50919998505050505050505050565b6000602080830181845280855180835260408601915060408160051b87010192508387016000805b8381101561445557888603603f1901855282518051808852835b8181101561442e578281018a01518982018b01528901614413565b508781018901849052601f01601f19169096018701955093860193918601916001016143f9565b509398975050505050505050565b6000806000806080858703121561447957600080fd5b5050823594602084013594506040840135936060013592509050565b6000602082840312156144a757600080fd5b5051919050565b600181811c908216806144c257607f821691505b6020821081036144e257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561316c5761316c6144e8565b8082018082111561316c5761316c6144e8565b634e487b7160e01b600052601260045260246000fd5b60008261454957614549614524565b500690565b60008261455d5761455d614524565b500490565b8181036000831280158383131683831282161715614582576145826144e8565b5092915050565b80820182811260008312801582168215821617156145a9576145a96144e8565b505092915050565b6000826145c0576145c0614524565b500790565b80820260008212600160ff1b841416156145e1576145e16144e8565b818105831482151761316c5761316c6144e8565b60008261460457614604614524565b600160ff1b82146000198414161561461e5761461e6144e8565b500590565b6000600160ff1b8201614638576146386144e8565b506000039056fe608060405234801561001057600080fd5b50610938806100206000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80639ba5f52e116100665780639ba5f52e14610114578063b67bee0414610127578063cbe8623f1461013a578063e46751e31461014d578063f3e4f87c1461016057600080fd5b80630c9b9881146100a357806312bd6ac0146100c85780632e4c697f146100db57806381e5f7c9146100ee5780638e6f235314610101575b600080fd5b6100b66100b13660046107d1565b610173565b60405190815260200160405180910390f35b6100b66100d63660046107f3565b61018a565b6100b66100e93660046107d1565b6101a1565b6100b66100fc36600461081f565b6101ae565b6100b661010f366004610871565b6101c9565b6100b66101223660046107d1565b6101dc565b6100b66101353660046107f3565b6101e9565b6100b66101483660046107d1565b6101f7565b6100b661015b366004610871565b610204565b6100b661016e3660046107d1565b610210565b600080610180848461021d565b9150505b92915050565b600080610198858585610232565b95945050505050565b6000806101808484610258565b6000806101be87878787876102cd565b979650505050505050565b6000806101d583610371565b9392505050565b60008061018084846105a0565b6000806101988585856105b1565b60008061018084846105cf565b6000806101d5836105e4565b6000806101808484610779565b60006101d58383670de0b6b3a76400006105b1565b600082600019048411830215820261024957600080fd5b50910281810615159190040190565b6000816000036102715750670de0b6b3a7640000610184565b8260000361028157506000610184565b600061028c8361078e565b905060006102a161029c8661078e565b610371565b90508181026102b8670de0b6b3a7640000826108a0565b90506102c3816105e4565b9695505050505050565b6000826000036102de575084610198565b8115610337576103156102f184876108dc565b6102fb858761021d565b610305888a61021d565b61030f91906108dc565b906105a0565b9050600061032385886107bc565b905080821015610331578091505b50610198565b82850361034657506000610198565b6102c361035384876108ef565b61035d8587610779565b610367888a61021d565b61030f91906108ef565b60008082136103935760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f1982019061041f9084901c61078e565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b60006101d583670de0b6b3a7640000845b60008260001904841183021582026105c857600080fd5b5091020490565b60006101d583670de0b6b3a764000084610232565b6000680248ce36a70cb26b3e1982136105ff57506000919050565b680755bf798b4a1bf1e58212610628576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b059150600060606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b0181810595509293509091906102c374029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c61078e565b60006101d58383670de0b6b3a7640000610232565b60006001600160ff1b038211156107b85760405163396ea70160e11b815260040160405180910390fd5b5090565b60008183116107cb57826101d5565b50919050565b600080604083850312156107e457600080fd5b50508035926020909101359150565b60008060006060848603121561080857600080fd5b505081359360208301359350604090920135919050565b600080600080600060a0868803121561083757600080fd5b853594506020860135935060408601359250606086013591506080860135801515811461086357600080fd5b809150509295509295909350565b60006020828403121561088357600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b6000826108bd57634e487b7160e01b600052601260045260246000fd5b600160ff1b8214600019841416156108d7576108d761088a565b500590565b808201808211156101845761018461088a565b818103818111156101845761018461088a56fea26469706673582212200a2cec4cd88035ad14ec7e2bc3f6e0ebf01db380342bcaf650186eac385e1e6c64736f6c63430008160033885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12da26469706673582212200b5eb263f691afcc0adb8d0613d7fd32d858754a088861b30eef5b83854bc11964736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = FixedPointMathTestContractFunctions(fixedpointmathtest_abi, self.w3, address)  # type: ignore
        self.events = FixedPointMathTestContractEvents(fixedpointmathtest_abi, self.w3, address)  # type: ignore

    events: FixedPointMathTestContractEvents

    functions: FixedPointMathTestContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = FixedPointMathTestContractFunctions(
            fixedpointmathtest_abi, w3, None
        )

        return contract
