"""A web3.py Contract class for the MockEzEthPool contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.47.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

import copy
from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .MockEzEthPoolTypes import (
    ApprovalEvent,
    AuthorityUpdatedEvent,
    OwnershipTransferredEvent,
    PublicCapabilityUpdatedEvent,
    RoleCapabilityUpdatedEvent,
    TargetCustomAuthorityUpdatedEvent,
    TransferEvent,
    UserRoleUpdatedEvent,
)

structs = {}

mockezethpool_abi: ABI = cast(
    ABI,
    [
        {
            "type": "constructor",
            "inputs": [
                {
                    "name": "_initialRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_admin",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_isCompetitionMode",
                    "type": "bool",
                    "internalType": "bool",
                },
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "DOMAIN_SEPARATOR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "allowance",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"},
                {"name": "", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "authority",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {"name": "amount", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {
                    "name": "destination",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "calculateMintAmount",
            "inputs": [
                {
                    "name": "_currentValueInProtocol",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_newValueAdded",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_existingEzETHSupply",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "calculateRedeemAmount",
            "inputs": [
                {
                    "name": "_ezETHBeingBurned",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_existingEzETHSupply",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_currentValueInProtocol",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "calculateTVLs",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256[][]",
                    "internalType": "uint256[][]",
                },
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"},
                {"name": "", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "canCall",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "depositETH",
            "inputs": [],
            "outputs": [],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "doesRoleHaveCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesUserHaveRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ezETH",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBufferedEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPooledEthByShares",
            "inputs": [
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRate",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRolesWithCapability",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSharesByPooledEth",
            "inputs": [
                {
                    "name": "_ethAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTargetCustomAuthority",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalPooledEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalShares",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserRoles",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCapabilityPublic",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCompetitionMode",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isUnrestricted",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "lookupTokenAmountFromValue",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IERC20",
                },
                {"name": "", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "lookupTokenValue",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IERC20",
                },
                {"name": "", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "lookupTokenValues",
            "inputs": [
                {
                    "name": "",
                    "type": "address[]",
                    "internalType": "contract IERC20[]",
                },
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "maxMintAmount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "destination",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {"name": "amount", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "nonces",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "permit",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "renzoOracle",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setAuthority",
            "inputs": [
                {
                    "name": "newAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setMaxMintAmount",
            "inputs": [
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPublicCapability",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRate",
            "inputs": [
                {"name": "_rate_", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRoleCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setTargetCustomAuthority",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "customAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUnrestrictedMintStatus",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "_status", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sharesOf",
            "inputs": [
                {
                    "name": "_account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "submit",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalPooledEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalShares",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transfer",
            "inputs": [
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "newOwner",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferShares",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferSharesFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "spender",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AuthorityUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAuthority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PublicCapabilityUpdated",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RoleCapabilityUpdated",
            "inputs": [
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TargetCustomAuthorityUpdated",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "authority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserRoleUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "InvalidTokenAmount", "inputs": []},
    ],
)


class MockEzEthPoolInvalidTokenAmountContractError(PypechainBaseError):
    """ContractError for InvalidTokenAmount."""

    # Error name
    name: str = "InvalidTokenAmount"
    # 4 byte error selector
    selector: str = "0x21607339"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidTokenAmount()"
    # Error input types
    abi: ABI = mockezethpool_abi


class MockEzEthPoolContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the MockEzEthPool contract."""

    InvalidTokenAmount: MockEzEthPoolInvalidTokenAmountContractError

    def __init__(
        self,
    ) -> None:
        self.InvalidTokenAmount = MockEzEthPoolInvalidTokenAmountContractError()

        self._all = [
            self.InvalidTokenAmount,
        ]


class MockEzEthPoolDOMAIN_SEPARATORContractFunction0(PypechainContractFunction):
    """ContractFunction for the DOMAIN_SEPARATOR() method."""

    _function_name = "DOMAIN_SEPARATOR"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolDOMAIN_SEPARATORContractFunction(PypechainContractFunction):
    """ContractFunction for the DOMAIN_SEPARATOR method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "DOMAIN_SEPARATOR"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolDOMAIN_SEPARATORContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolDOMAIN_SEPARATORContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolDOMAIN_SEPARATORContractFunction0._type_signature: MockEzEthPoolDOMAIN_SEPARATORContractFunction0.factory(
                "MockEzEthPoolDOMAIN_SEPARATORContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolAllowanceContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowance(str,str) method."""

    _function_name = "allowance"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolAllowanceContractFunction(PypechainContractFunction):
    """ContractFunction for the allowance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str, arg2: str) -> MockEzEthPoolAllowanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolAllowanceContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolAllowanceContractFunction0._type_signature: MockEzEthPoolAllowanceContractFunction0.factory(
                "MockEzEthPoolAllowanceContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolApproveContractFunction0(PypechainContractFunction):
    """ContractFunction for the approve(str,int) method."""

    _function_name = "approve"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolApproveContractFunction(PypechainContractFunction):
    """ContractFunction for the approve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "approve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, spender: str, amount: int) -> MockEzEthPoolApproveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolApproveContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolApproveContractFunction0._type_signature: MockEzEthPoolApproveContractFunction0.factory(
                "MockEzEthPoolApproveContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the authority() method."""

    _function_name = "authority"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the authority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "authority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolAuthorityContractFunction0._type_signature: MockEzEthPoolAuthorityContractFunction0.factory(
                "MockEzEthPoolAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolBalanceOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the balanceOf(str) method."""

    _function_name = "balanceOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolBalanceOfContractFunction(PypechainContractFunction):
    """ContractFunction for the balanceOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "balanceOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolBalanceOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolBalanceOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolBalanceOfContractFunction0._type_signature: MockEzEthPoolBalanceOfContractFunction0.factory(
                "MockEzEthPoolBalanceOfContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolBurnContractFunction0(PypechainContractFunction):
    """ContractFunction for the burn(int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolBurnContractFunction1(PypechainContractFunction):
    """ContractFunction for the burn(str,int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolBurnContractFunction(PypechainContractFunction):
    """ContractFunction for the burn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "burn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, amount: int) -> MockEzEthPoolBurnContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, destination: str, amount: int) -> MockEzEthPoolBurnContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolBurnContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolBurnContractFunction0._type_signature: MockEzEthPoolBurnContractFunction0.factory(
                "MockEzEthPoolBurnContractFunction0", **kwargs
            ),
            MockEzEthPoolBurnContractFunction1._type_signature: MockEzEthPoolBurnContractFunction1.factory(
                "MockEzEthPoolBurnContractFunction1", **kwargs
            ),
        }
        return out


class MockEzEthPoolCalculateMintAmountContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the calculateMintAmount(int,int,int) method."""

    _function_name = "calculateMintAmount"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolCalculateMintAmountContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the calculateMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "calculateMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _currentValueInProtocol: int, _newValueAdded: int, _existingEzETHSupply: int) -> MockEzEthPoolCalculateMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolCalculateMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolCalculateMintAmountContractFunction0._type_signature: MockEzEthPoolCalculateMintAmountContractFunction0.factory(
                "MockEzEthPoolCalculateMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolCalculateRedeemAmountContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the calculateRedeemAmount(int,int,int) method."""

    _function_name = "calculateRedeemAmount"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolCalculateRedeemAmountContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the calculateRedeemAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "calculateRedeemAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _ezETHBeingBurned: int, _existingEzETHSupply: int, _currentValueInProtocol: int) -> MockEzEthPoolCalculateRedeemAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolCalculateRedeemAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolCalculateRedeemAmountContractFunction0._type_signature: MockEzEthPoolCalculateRedeemAmountContractFunction0.factory(
                "MockEzEthPoolCalculateRedeemAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolCalculateTVLsContractFunction0(PypechainContractFunction):
    """ContractFunction for the calculateTVLs() method."""

    _function_name = "calculateTVLs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for CalculateTVLs."""

        arg1: list[int]
        arg2: list[int]
        arg3: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [list[int], list[int], int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolCalculateTVLsContractFunction(PypechainContractFunction):
    """ContractFunction for the calculateTVLs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "calculateTVLs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolCalculateTVLsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolCalculateTVLsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolCalculateTVLsContractFunction0._type_signature: MockEzEthPoolCalculateTVLsContractFunction0.factory(
                "MockEzEthPoolCalculateTVLsContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolCanCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the canCall(str,str,bytes) method."""

    _function_name = "canCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolCanCallContractFunction(PypechainContractFunction):
    """ContractFunction for the canCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "canCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, target: str, functionSig: bytes) -> MockEzEthPoolCanCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolCanCallContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolCanCallContractFunction0._type_signature: MockEzEthPoolCanCallContractFunction0.factory(
                "MockEzEthPoolCanCallContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolDecimalsContractFunction0(PypechainContractFunction):
    """ContractFunction for the decimals() method."""

    _function_name = "decimals"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolDecimalsContractFunction(PypechainContractFunction):
    """ContractFunction for the decimals method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "decimals"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolDecimalsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolDecimalsContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolDecimalsContractFunction0._type_signature: MockEzEthPoolDecimalsContractFunction0.factory(
                "MockEzEthPoolDecimalsContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolDepositETHContractFunction0(PypechainContractFunction):
    """ContractFunction for the depositETH() method."""

    _function_name = "depositETH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolDepositETHContractFunction(PypechainContractFunction):
    """ContractFunction for the depositETH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "depositETH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolDepositETHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolDepositETHContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolDepositETHContractFunction0._type_signature: MockEzEthPoolDepositETHContractFunction0.factory(
                "MockEzEthPoolDepositETHContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolDoesRoleHaveCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability(int,bytes) method."""

    _function_name = "doesRoleHaveCapability"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolDoesRoleHaveCapabilityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesRoleHaveCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes) -> MockEzEthPoolDoesRoleHaveCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolDoesRoleHaveCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolDoesRoleHaveCapabilityContractFunction0._type_signature: MockEzEthPoolDoesRoleHaveCapabilityContractFunction0.factory(
                "MockEzEthPoolDoesRoleHaveCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolDoesUserHaveRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole(str,int) method."""

    _function_name = "doesUserHaveRole"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolDoesUserHaveRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesUserHaveRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int) -> MockEzEthPoolDoesUserHaveRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolDoesUserHaveRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolDoesUserHaveRoleContractFunction0._type_signature: MockEzEthPoolDoesUserHaveRoleContractFunction0.factory(
                "MockEzEthPoolDoesUserHaveRoleContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolEzETHContractFunction0(PypechainContractFunction):
    """ContractFunction for the ezETH() method."""

    _function_name = "ezETH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolEzETHContractFunction(PypechainContractFunction):
    """ContractFunction for the ezETH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ezETH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolEzETHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolEzETHContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolEzETHContractFunction0._type_signature: MockEzEthPoolEzETHContractFunction0.factory(
                "MockEzEthPoolEzETHContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetBufferedEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBufferedEther() method."""

    _function_name = "getBufferedEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetBufferedEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the getBufferedEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBufferedEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolGetBufferedEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetBufferedEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetBufferedEtherContractFunction0._type_signature: MockEzEthPoolGetBufferedEtherContractFunction0.factory(
                "MockEzEthPoolGetBufferedEtherContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetPooledEthBySharesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getPooledEthByShares(int) method."""

    _function_name = "getPooledEthByShares"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetPooledEthBySharesContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getPooledEthByShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPooledEthByShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sharesAmount: int) -> MockEzEthPoolGetPooledEthBySharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetPooledEthBySharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetPooledEthBySharesContractFunction0._type_signature: MockEzEthPoolGetPooledEthBySharesContractFunction0.factory(
                "MockEzEthPoolGetPooledEthBySharesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRate() method."""

    _function_name = "getRate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the getRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolGetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetRateContractFunction0._type_signature: MockEzEthPoolGetRateContractFunction0.factory(
                "MockEzEthPoolGetRateContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetRolesWithCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability(bytes) method."""

    _function_name = "getRolesWithCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetRolesWithCapabilityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRolesWithCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> MockEzEthPoolGetRolesWithCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetRolesWithCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetRolesWithCapabilityContractFunction0._type_signature: MockEzEthPoolGetRolesWithCapabilityContractFunction0.factory(
                "MockEzEthPoolGetRolesWithCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetSharesByPooledEthContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getSharesByPooledEth(int) method."""

    _function_name = "getSharesByPooledEth"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetSharesByPooledEthContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getSharesByPooledEth method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSharesByPooledEth"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _ethAmount: int) -> MockEzEthPoolGetSharesByPooledEthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetSharesByPooledEthContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetSharesByPooledEthContractFunction0._type_signature: MockEzEthPoolGetSharesByPooledEthContractFunction0.factory(
                "MockEzEthPoolGetSharesByPooledEthContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority(str) method."""

    _function_name = "getTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolGetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetTargetCustomAuthorityContractFunction0._type_signature: MockEzEthPoolGetTargetCustomAuthorityContractFunction0.factory(
                "MockEzEthPoolGetTargetCustomAuthorityContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockEzEthPoolGetTotalPooledEtherContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getTotalPooledEther() method."""

    _function_name = "getTotalPooledEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetTotalPooledEtherContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the getTotalPooledEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalPooledEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolGetTotalPooledEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetTotalPooledEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetTotalPooledEtherContractFunction0._type_signature: MockEzEthPoolGetTotalPooledEtherContractFunction0.factory(
                "MockEzEthPoolGetTotalPooledEtherContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetTotalSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalShares() method."""

    _function_name = "getTotalShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetTotalSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the getTotalShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolGetTotalSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetTotalSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetTotalSharesContractFunction0._type_signature: MockEzEthPoolGetTotalSharesContractFunction0.factory(
                "MockEzEthPoolGetTotalSharesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolGetUserRolesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserRoles(str) method."""

    _function_name = "getUserRoles"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolGetUserRolesContractFunction(PypechainContractFunction):
    """ContractFunction for the getUserRoles method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserRoles"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolGetUserRolesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolGetUserRolesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolGetUserRolesContractFunction0._type_signature: MockEzEthPoolGetUserRolesContractFunction0.factory(
                "MockEzEthPoolGetUserRolesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolIsCapabilityPublicContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the isCapabilityPublic(bytes) method."""

    _function_name = "isCapabilityPublic"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolIsCapabilityPublicContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the isCapabilityPublic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCapabilityPublic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> MockEzEthPoolIsCapabilityPublicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolIsCapabilityPublicContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolIsCapabilityPublicContractFunction0._type_signature: MockEzEthPoolIsCapabilityPublicContractFunction0.factory(
                "MockEzEthPoolIsCapabilityPublicContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolIsCompetitionModeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the isCompetitionMode() method."""

    _function_name = "isCompetitionMode"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolIsCompetitionModeContractFunction(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCompetitionMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolIsCompetitionModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolIsCompetitionModeContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolIsCompetitionModeContractFunction0._type_signature: MockEzEthPoolIsCompetitionModeContractFunction0.factory(
                "MockEzEthPoolIsCompetitionModeContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolIsUnrestrictedContractFunction0(PypechainContractFunction):
    """ContractFunction for the isUnrestricted(str) method."""

    _function_name = "isUnrestricted"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolIsUnrestrictedContractFunction(PypechainContractFunction):
    """ContractFunction for the isUnrestricted method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isUnrestricted"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolIsUnrestrictedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolIsUnrestrictedContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolIsUnrestrictedContractFunction0._type_signature: MockEzEthPoolIsUnrestrictedContractFunction0.factory(
                "MockEzEthPoolIsUnrestrictedContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolLookupTokenAmountFromValueContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the lookupTokenAmountFromValue(str,int) method."""

    _function_name = "lookupTokenAmountFromValue"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolLookupTokenAmountFromValueContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the lookupTokenAmountFromValue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "lookupTokenAmountFromValue"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str, arg2: int) -> MockEzEthPoolLookupTokenAmountFromValueContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolLookupTokenAmountFromValueContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolLookupTokenAmountFromValueContractFunction0._type_signature: MockEzEthPoolLookupTokenAmountFromValueContractFunction0.factory(
                "MockEzEthPoolLookupTokenAmountFromValueContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockEzEthPoolLookupTokenValueContractFunction0(PypechainContractFunction):
    """ContractFunction for the lookupTokenValue(str,int) method."""

    _function_name = "lookupTokenValue"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolLookupTokenValueContractFunction(PypechainContractFunction):
    """ContractFunction for the lookupTokenValue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "lookupTokenValue"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str, arg2: int) -> MockEzEthPoolLookupTokenValueContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolLookupTokenValueContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolLookupTokenValueContractFunction0._type_signature: MockEzEthPoolLookupTokenValueContractFunction0.factory(
                "MockEzEthPoolLookupTokenValueContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolLookupTokenValuesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the lookupTokenValues(list[str],list[int]) method."""

    _function_name = "lookupTokenValues"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[int]"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolLookupTokenValuesContractFunction(PypechainContractFunction):
    """ContractFunction for the lookupTokenValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "lookupTokenValues"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: list[str], arg2: list[int]) -> MockEzEthPoolLookupTokenValuesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolLookupTokenValuesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolLookupTokenValuesContractFunction0._type_signature: MockEzEthPoolLookupTokenValuesContractFunction0.factory(
                "MockEzEthPoolLookupTokenValuesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxMintAmount() method."""

    _function_name = "maxMintAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the maxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolMaxMintAmountContractFunction0._type_signature: MockEzEthPoolMaxMintAmountContractFunction0.factory(
                "MockEzEthPoolMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the mint(str,int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolMintContractFunction1(PypechainContractFunction):
    """ContractFunction for the mint(int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolMintContractFunction(PypechainContractFunction):
    """ContractFunction for the mint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, destination: str, amount: int) -> MockEzEthPoolMintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, amount: int) -> MockEzEthPoolMintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolMintContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolMintContractFunction0._type_signature: MockEzEthPoolMintContractFunction0.factory(
                "MockEzEthPoolMintContractFunction0", **kwargs
            ),
            MockEzEthPoolMintContractFunction1._type_signature: MockEzEthPoolMintContractFunction1.factory(
                "MockEzEthPoolMintContractFunction1", **kwargs
            ),
        }
        return out


class MockEzEthPoolNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolNameContractFunction(PypechainContractFunction):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolNameContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolNameContractFunction0._type_signature: MockEzEthPoolNameContractFunction0.factory(
                "MockEzEthPoolNameContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolNoncesContractFunction0(PypechainContractFunction):
    """ContractFunction for the nonces(str) method."""

    _function_name = "nonces"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolNoncesContractFunction(PypechainContractFunction):
    """ContractFunction for the nonces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "nonces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolNoncesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolNoncesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolNoncesContractFunction0._type_signature: MockEzEthPoolNoncesContractFunction0.factory(
                "MockEzEthPoolNoncesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolOwnerContractFunction0(PypechainContractFunction):
    """ContractFunction for the owner() method."""

    _function_name = "owner"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolOwnerContractFunction(PypechainContractFunction):
    """ContractFunction for the owner method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "owner"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolOwnerContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolOwnerContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolOwnerContractFunction0._type_signature: MockEzEthPoolOwnerContractFunction0.factory(
                "MockEzEthPoolOwnerContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the permit(str,str,int,int,int,bytes,bytes) method."""

    _function_name = "permit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "int", "int", "bytes", "bytes"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolPermitContractFunction(PypechainContractFunction):
    """ContractFunction for the permit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "permit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str, value: int, deadline: int, v: int, r: bytes, s: bytes) -> MockEzEthPoolPermitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolPermitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolPermitContractFunction0._type_signature: MockEzEthPoolPermitContractFunction0.factory(
                "MockEzEthPoolPermitContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolRenzoOracleContractFunction0(PypechainContractFunction):
    """ContractFunction for the renzoOracle() method."""

    _function_name = "renzoOracle"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolRenzoOracleContractFunction(PypechainContractFunction):
    """ContractFunction for the renzoOracle method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "renzoOracle"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolRenzoOracleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolRenzoOracleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolRenzoOracleContractFunction0._type_signature: MockEzEthPoolRenzoOracleContractFunction0.factory(
                "MockEzEthPoolRenzoOracleContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setAuthority(str) method."""

    _function_name = "setAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetAuthorityContractFunction(PypechainContractFunction):
    """ContractFunction for the setAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newAuthority: str) -> MockEzEthPoolSetAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetAuthorityContractFunction0._type_signature: MockEzEthPoolSetAuthorityContractFunction0.factory(
                "MockEzEthPoolSetAuthorityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount(int) method."""

    _function_name = "setMaxMintAmount"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetMaxMintAmountContractFunction(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setMaxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _maxMintAmount: int) -> MockEzEthPoolSetMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetMaxMintAmountContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetMaxMintAmountContractFunction0._type_signature: MockEzEthPoolSetMaxMintAmountContractFunction0.factory(
                "MockEzEthPoolSetMaxMintAmountContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetPublicCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setPublicCapability(bytes,bool) method."""

    _function_name = "setPublicCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bool"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetPublicCapabilityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setPublicCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPublicCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, functionSig: bytes, enabled: bool) -> MockEzEthPoolSetPublicCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetPublicCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetPublicCapabilityContractFunction0._type_signature: MockEzEthPoolSetPublicCapabilityContractFunction0.factory(
                "MockEzEthPoolSetPublicCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRate(int) method."""

    _function_name = "setRate"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetRateContractFunction(PypechainContractFunction):
    """ContractFunction for the setRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _rate_: int) -> MockEzEthPoolSetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetRateContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetRateContractFunction0._type_signature: MockEzEthPoolSetRateContractFunction0.factory(
                "MockEzEthPoolSetRateContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetRoleCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setRoleCapability(int,bytes,bool) method."""

    _function_name = "setRoleCapability"
    _type_signature = expand_struct_type_str(
        tuple(["int", "bytes", "bool"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetRoleCapabilityContractFunction(PypechainContractFunction):
    """ContractFunction for the setRoleCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRoleCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes, enabled: bool) -> MockEzEthPoolSetRoleCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetRoleCapabilityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetRoleCapabilityContractFunction0._type_signature: MockEzEthPoolSetRoleCapabilityContractFunction0.factory(
                "MockEzEthPoolSetRoleCapabilityContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority(str,str) method."""

    _function_name = "setTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetTargetCustomAuthorityContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, customAuthority: str) -> MockEzEthPoolSetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetTargetCustomAuthorityContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetTargetCustomAuthorityContractFunction0._type_signature: MockEzEthPoolSetTargetCustomAuthorityContractFunction0.factory(
                "MockEzEthPoolSetTargetCustomAuthorityContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockEzEthPoolSetUnrestrictedMintStatusContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus(str,bool) method."""

    _function_name = "setUnrestrictedMintStatus"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetUnrestrictedMintStatusContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUnrestrictedMintStatus"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _target: str, _status: bool) -> MockEzEthPoolSetUnrestrictedMintStatusContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetUnrestrictedMintStatusContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetUnrestrictedMintStatusContractFunction0._type_signature: MockEzEthPoolSetUnrestrictedMintStatusContractFunction0.factory(
                "MockEzEthPoolSetUnrestrictedMintStatusContractFunction0",
                **kwargs,
            ),
        }
        return out


class MockEzEthPoolSetUserRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserRole(str,int,bool) method."""

    _function_name = "setUserRole"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolSetUserRoleContractFunction(PypechainContractFunction):
    """ContractFunction for the setUserRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int, enabled: bool) -> MockEzEthPoolSetUserRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSetUserRoleContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSetUserRoleContractFunction0._type_signature: MockEzEthPoolSetUserRoleContractFunction0.factory(
                "MockEzEthPoolSetUserRoleContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSharesOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the sharesOf(str) method."""

    _function_name = "sharesOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolSharesOfContractFunction(PypechainContractFunction):
    """ContractFunction for the sharesOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sharesOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _account: str) -> MockEzEthPoolSharesOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSharesOfContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSharesOfContractFunction0._type_signature: MockEzEthPoolSharesOfContractFunction0.factory(
                "MockEzEthPoolSharesOfContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSubmitContractFunction0(PypechainContractFunction):
    """ContractFunction for the submit(str) method."""

    _function_name = "submit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolSubmitContractFunction(PypechainContractFunction):
    """ContractFunction for the submit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "submit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> MockEzEthPoolSubmitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSubmitContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSubmitContractFunction0._type_signature: MockEzEthPoolSubmitContractFunction0.factory(
                "MockEzEthPoolSubmitContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolSymbolContractFunction0(PypechainContractFunction):
    """ContractFunction for the symbol() method."""

    _function_name = "symbol"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolSymbolContractFunction(PypechainContractFunction):
    """ContractFunction for the symbol method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "symbol"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolSymbolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolSymbolContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolSymbolContractFunction0._type_signature: MockEzEthPoolSymbolContractFunction0.factory(
                "MockEzEthPoolSymbolContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTotalPooledEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalPooledEther() method."""

    _function_name = "totalPooledEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTotalPooledEtherContractFunction(PypechainContractFunction):
    """ContractFunction for the totalPooledEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalPooledEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolTotalPooledEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTotalPooledEtherContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTotalPooledEtherContractFunction0._type_signature: MockEzEthPoolTotalPooledEtherContractFunction0.factory(
                "MockEzEthPoolTotalPooledEtherContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTotalSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalShares() method."""

    _function_name = "totalShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTotalSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the totalShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolTotalSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTotalSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTotalSharesContractFunction0._type_signature: MockEzEthPoolTotalSharesContractFunction0.factory(
                "MockEzEthPoolTotalSharesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTotalSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalSupply() method."""

    _function_name = "totalSupply"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTotalSupplyContractFunction(PypechainContractFunction):
    """ContractFunction for the totalSupply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalSupply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> MockEzEthPoolTotalSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTotalSupplyContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTotalSupplyContractFunction0._type_signature: MockEzEthPoolTotalSupplyContractFunction0.factory(
                "MockEzEthPoolTotalSupplyContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the transfer(str,int) method."""

    _function_name = "transfer"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTransferContractFunction(PypechainContractFunction):
    """ContractFunction for the transfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, to: str, amount: int) -> MockEzEthPoolTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTransferContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTransferContractFunction0._type_signature: MockEzEthPoolTransferContractFunction0.factory(
                "MockEzEthPoolTransferContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferFrom(str,str,int) method."""

    _function_name = "transferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTransferFromContractFunction(PypechainContractFunction):
    """ContractFunction for the transferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str, amount: int) -> MockEzEthPoolTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTransferFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTransferFromContractFunction0._type_signature: MockEzEthPoolTransferFromContractFunction0.factory(
                "MockEzEthPoolTransferFromContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTransferOwnershipContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the transferOwnership(str) method."""

    _function_name = "transferOwnership"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class MockEzEthPoolTransferOwnershipContractFunction(PypechainContractFunction):
    """ContractFunction for the transferOwnership method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferOwnership"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newOwner: str) -> MockEzEthPoolTransferOwnershipContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTransferOwnershipContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTransferOwnershipContractFunction0._type_signature: MockEzEthPoolTransferOwnershipContractFunction0.factory(
                "MockEzEthPoolTransferOwnershipContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTransferSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferShares(str,int) method."""

    _function_name = "transferShares"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTransferSharesContractFunction(PypechainContractFunction):
    """ContractFunction for the transferShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _sharesAmount: int) -> MockEzEthPoolTransferSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTransferSharesContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTransferSharesContractFunction0._type_signature: MockEzEthPoolTransferSharesContractFunction0.factory(
                "MockEzEthPoolTransferSharesContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolTransferSharesFromContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the transferSharesFrom(str,str,int) method."""

    _function_name = "transferSharesFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = MockEzEthPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class MockEzEthPoolTransferSharesFromContractFunction(
    PypechainContractFunction
):
    """ContractFunction for the transferSharesFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferSharesFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _sharesAmount: int) -> MockEzEthPoolTransferSharesFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> MockEzEthPoolTransferSharesFromContractFunction:  # type: ignore
        clone = super().__call__(
            *(dataclass_to_tuple(arg) for arg in args),
            **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
        )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Look up the function class based on arg types.
        # We ensure we use a copy of the original object.
        function_obj = copy.copy(self._functions[arg_types])

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instanciated object
        # (attached to a specific web3 and contract address)
        out._functions = {
            MockEzEthPoolTransferSharesFromContractFunction0._type_signature: MockEzEthPoolTransferSharesFromContractFunction0.factory(
                "MockEzEthPoolTransferSharesFromContractFunction0", **kwargs
            ),
        }
        return out


class MockEzEthPoolContractFunctions(ContractFunctions):
    """ContractFunctions for the MockEzEthPool contract."""

    DOMAIN_SEPARATOR: MockEzEthPoolDOMAIN_SEPARATORContractFunction

    allowance: MockEzEthPoolAllowanceContractFunction

    approve: MockEzEthPoolApproveContractFunction

    authority: MockEzEthPoolAuthorityContractFunction

    balanceOf: MockEzEthPoolBalanceOfContractFunction

    burn: MockEzEthPoolBurnContractFunction

    calculateMintAmount: MockEzEthPoolCalculateMintAmountContractFunction

    calculateRedeemAmount: MockEzEthPoolCalculateRedeemAmountContractFunction

    calculateTVLs: MockEzEthPoolCalculateTVLsContractFunction

    canCall: MockEzEthPoolCanCallContractFunction

    decimals: MockEzEthPoolDecimalsContractFunction

    depositETH: MockEzEthPoolDepositETHContractFunction

    doesRoleHaveCapability: MockEzEthPoolDoesRoleHaveCapabilityContractFunction

    doesUserHaveRole: MockEzEthPoolDoesUserHaveRoleContractFunction

    ezETH: MockEzEthPoolEzETHContractFunction

    getBufferedEther: MockEzEthPoolGetBufferedEtherContractFunction

    getPooledEthByShares: MockEzEthPoolGetPooledEthBySharesContractFunction

    getRate: MockEzEthPoolGetRateContractFunction

    getRolesWithCapability: MockEzEthPoolGetRolesWithCapabilityContractFunction

    getSharesByPooledEth: MockEzEthPoolGetSharesByPooledEthContractFunction

    getTargetCustomAuthority: (
        MockEzEthPoolGetTargetCustomAuthorityContractFunction
    )

    getTotalPooledEther: MockEzEthPoolGetTotalPooledEtherContractFunction

    getTotalShares: MockEzEthPoolGetTotalSharesContractFunction

    getUserRoles: MockEzEthPoolGetUserRolesContractFunction

    isCapabilityPublic: MockEzEthPoolIsCapabilityPublicContractFunction

    isCompetitionMode: MockEzEthPoolIsCompetitionModeContractFunction

    isUnrestricted: MockEzEthPoolIsUnrestrictedContractFunction

    lookupTokenAmountFromValue: (
        MockEzEthPoolLookupTokenAmountFromValueContractFunction
    )

    lookupTokenValue: MockEzEthPoolLookupTokenValueContractFunction

    lookupTokenValues: MockEzEthPoolLookupTokenValuesContractFunction

    maxMintAmount: MockEzEthPoolMaxMintAmountContractFunction

    mint: MockEzEthPoolMintContractFunction

    name: MockEzEthPoolNameContractFunction

    nonces: MockEzEthPoolNoncesContractFunction

    owner: MockEzEthPoolOwnerContractFunction

    permit: MockEzEthPoolPermitContractFunction

    renzoOracle: MockEzEthPoolRenzoOracleContractFunction

    setAuthority: MockEzEthPoolSetAuthorityContractFunction

    setMaxMintAmount: MockEzEthPoolSetMaxMintAmountContractFunction

    setPublicCapability: MockEzEthPoolSetPublicCapabilityContractFunction

    setRate: MockEzEthPoolSetRateContractFunction

    setRoleCapability: MockEzEthPoolSetRoleCapabilityContractFunction

    setTargetCustomAuthority: (
        MockEzEthPoolSetTargetCustomAuthorityContractFunction
    )

    setUnrestrictedMintStatus: (
        MockEzEthPoolSetUnrestrictedMintStatusContractFunction
    )

    setUserRole: MockEzEthPoolSetUserRoleContractFunction

    sharesOf: MockEzEthPoolSharesOfContractFunction

    submit: MockEzEthPoolSubmitContractFunction

    symbol: MockEzEthPoolSymbolContractFunction

    totalPooledEther: MockEzEthPoolTotalPooledEtherContractFunction

    totalShares: MockEzEthPoolTotalSharesContractFunction

    totalSupply: MockEzEthPoolTotalSupplyContractFunction

    transfer: MockEzEthPoolTransferContractFunction

    transferFrom: MockEzEthPoolTransferFromContractFunction

    transferOwnership: MockEzEthPoolTransferOwnershipContractFunction

    transferShares: MockEzEthPoolTransferSharesContractFunction

    transferSharesFrom: MockEzEthPoolTransferSharesFromContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.DOMAIN_SEPARATOR = (
            MockEzEthPoolDOMAIN_SEPARATORContractFunction.factory(
                "DOMAIN_SEPARATOR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="DOMAIN_SEPARATOR",
            )
        )
        self.allowance = MockEzEthPoolAllowanceContractFunction.factory(
            "allowance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowance",
        )
        self.approve = MockEzEthPoolApproveContractFunction.factory(
            "approve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="approve",
        )
        self.authority = MockEzEthPoolAuthorityContractFunction.factory(
            "authority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="authority",
        )
        self.balanceOf = MockEzEthPoolBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="balanceOf",
        )
        self.burn = MockEzEthPoolBurnContractFunction.factory(
            "burn",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="burn",
        )
        self.calculateMintAmount = (
            MockEzEthPoolCalculateMintAmountContractFunction.factory(
                "calculateMintAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="calculateMintAmount",
            )
        )
        self.calculateRedeemAmount = (
            MockEzEthPoolCalculateRedeemAmountContractFunction.factory(
                "calculateRedeemAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="calculateRedeemAmount",
            )
        )
        self.calculateTVLs = MockEzEthPoolCalculateTVLsContractFunction.factory(
            "calculateTVLs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="calculateTVLs",
        )
        self.canCall = MockEzEthPoolCanCallContractFunction.factory(
            "canCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="canCall",
        )
        self.decimals = MockEzEthPoolDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="decimals",
        )
        self.depositETH = MockEzEthPoolDepositETHContractFunction.factory(
            "depositETH",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="depositETH",
        )
        self.doesRoleHaveCapability = (
            MockEzEthPoolDoesRoleHaveCapabilityContractFunction.factory(
                "doesRoleHaveCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesRoleHaveCapability",
            )
        )
        self.doesUserHaveRole = (
            MockEzEthPoolDoesUserHaveRoleContractFunction.factory(
                "doesUserHaveRole",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesUserHaveRole",
            )
        )
        self.ezETH = MockEzEthPoolEzETHContractFunction.factory(
            "ezETH",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="ezETH",
        )
        self.getBufferedEther = (
            MockEzEthPoolGetBufferedEtherContractFunction.factory(
                "getBufferedEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getBufferedEther",
            )
        )
        self.getPooledEthByShares = (
            MockEzEthPoolGetPooledEthBySharesContractFunction.factory(
                "getPooledEthByShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPooledEthByShares",
            )
        )
        self.getRate = MockEzEthPoolGetRateContractFunction.factory(
            "getRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRate",
        )
        self.getRolesWithCapability = (
            MockEzEthPoolGetRolesWithCapabilityContractFunction.factory(
                "getRolesWithCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getRolesWithCapability",
            )
        )
        self.getSharesByPooledEth = (
            MockEzEthPoolGetSharesByPooledEthContractFunction.factory(
                "getSharesByPooledEth",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getSharesByPooledEth",
            )
        )
        self.getTargetCustomAuthority = (
            MockEzEthPoolGetTargetCustomAuthorityContractFunction.factory(
                "getTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTargetCustomAuthority",
            )
        )
        self.getTotalPooledEther = (
            MockEzEthPoolGetTotalPooledEtherContractFunction.factory(
                "getTotalPooledEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTotalPooledEther",
            )
        )
        self.getTotalShares = (
            MockEzEthPoolGetTotalSharesContractFunction.factory(
                "getTotalShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTotalShares",
            )
        )
        self.getUserRoles = MockEzEthPoolGetUserRolesContractFunction.factory(
            "getUserRoles",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserRoles",
        )
        self.isCapabilityPublic = (
            MockEzEthPoolIsCapabilityPublicContractFunction.factory(
                "isCapabilityPublic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCapabilityPublic",
            )
        )
        self.isCompetitionMode = (
            MockEzEthPoolIsCompetitionModeContractFunction.factory(
                "isCompetitionMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCompetitionMode",
            )
        )
        self.isUnrestricted = (
            MockEzEthPoolIsUnrestrictedContractFunction.factory(
                "isUnrestricted",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isUnrestricted",
            )
        )
        self.lookupTokenAmountFromValue = (
            MockEzEthPoolLookupTokenAmountFromValueContractFunction.factory(
                "lookupTokenAmountFromValue",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="lookupTokenAmountFromValue",
            )
        )
        self.lookupTokenValue = (
            MockEzEthPoolLookupTokenValueContractFunction.factory(
                "lookupTokenValue",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="lookupTokenValue",
            )
        )
        self.lookupTokenValues = (
            MockEzEthPoolLookupTokenValuesContractFunction.factory(
                "lookupTokenValues",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="lookupTokenValues",
            )
        )
        self.maxMintAmount = MockEzEthPoolMaxMintAmountContractFunction.factory(
            "maxMintAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxMintAmount",
        )
        self.mint = MockEzEthPoolMintContractFunction.factory(
            "mint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mint",
        )
        self.name = MockEzEthPoolNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.nonces = MockEzEthPoolNoncesContractFunction.factory(
            "nonces",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="nonces",
        )
        self.owner = MockEzEthPoolOwnerContractFunction.factory(
            "owner",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="owner",
        )
        self.permit = MockEzEthPoolPermitContractFunction.factory(
            "permit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="permit",
        )
        self.renzoOracle = MockEzEthPoolRenzoOracleContractFunction.factory(
            "renzoOracle",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="renzoOracle",
        )
        self.setAuthority = MockEzEthPoolSetAuthorityContractFunction.factory(
            "setAuthority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setAuthority",
        )
        self.setMaxMintAmount = (
            MockEzEthPoolSetMaxMintAmountContractFunction.factory(
                "setMaxMintAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setMaxMintAmount",
            )
        )
        self.setPublicCapability = (
            MockEzEthPoolSetPublicCapabilityContractFunction.factory(
                "setPublicCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPublicCapability",
            )
        )
        self.setRate = MockEzEthPoolSetRateContractFunction.factory(
            "setRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setRate",
        )
        self.setRoleCapability = (
            MockEzEthPoolSetRoleCapabilityContractFunction.factory(
                "setRoleCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setRoleCapability",
            )
        )
        self.setTargetCustomAuthority = (
            MockEzEthPoolSetTargetCustomAuthorityContractFunction.factory(
                "setTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setTargetCustomAuthority",
            )
        )
        self.setUnrestrictedMintStatus = (
            MockEzEthPoolSetUnrestrictedMintStatusContractFunction.factory(
                "setUnrestrictedMintStatus",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUnrestrictedMintStatus",
            )
        )
        self.setUserRole = MockEzEthPoolSetUserRoleContractFunction.factory(
            "setUserRole",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserRole",
        )
        self.sharesOf = MockEzEthPoolSharesOfContractFunction.factory(
            "sharesOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sharesOf",
        )
        self.submit = MockEzEthPoolSubmitContractFunction.factory(
            "submit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="submit",
        )
        self.symbol = MockEzEthPoolSymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="symbol",
        )
        self.totalPooledEther = (
            MockEzEthPoolTotalPooledEtherContractFunction.factory(
                "totalPooledEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="totalPooledEther",
            )
        )
        self.totalShares = MockEzEthPoolTotalSharesContractFunction.factory(
            "totalShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalShares",
        )
        self.totalSupply = MockEzEthPoolTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalSupply",
        )
        self.transfer = MockEzEthPoolTransferContractFunction.factory(
            "transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transfer",
        )
        self.transferFrom = MockEzEthPoolTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferFrom",
        )
        self.transferOwnership = (
            MockEzEthPoolTransferOwnershipContractFunction.factory(
                "transferOwnership",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferOwnership",
            )
        )
        self.transferShares = (
            MockEzEthPoolTransferSharesContractFunction.factory(
                "transferShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferShares",
            )
        )
        self.transferSharesFrom = (
            MockEzEthPoolTransferSharesFromContractFunction.factory(
                "transferSharesFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferSharesFrom",
            )
        )


class MockEzEthPoolApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ApprovalEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ApprovalEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for AuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolOwnershipTransferredContractEvent(ContractEvent):
    """ContractEvent for OwnershipTransferred."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolPublicCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for PublicCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolRoleCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for RoleCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolTargetCustomAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for TargetCustomAuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolTransferContractEvent(ContractEvent):
    """ContractEvent for Transfer."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolUserRoleUpdatedContractEvent(ContractEvent):
    """ContractEvent for UserRoleUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class MockEzEthPoolContractEvents(ContractEvents):
    """ContractEvents for the MockEzEthPool contract."""

    Approval: Type[MockEzEthPoolApprovalContractEvent]

    AuthorityUpdated: Type[MockEzEthPoolAuthorityUpdatedContractEvent]

    OwnershipTransferred: Type[MockEzEthPoolOwnershipTransferredContractEvent]

    PublicCapabilityUpdated: Type[
        MockEzEthPoolPublicCapabilityUpdatedContractEvent
    ]

    RoleCapabilityUpdated: Type[MockEzEthPoolRoleCapabilityUpdatedContractEvent]

    TargetCustomAuthorityUpdated: Type[
        MockEzEthPoolTargetCustomAuthorityUpdatedContractEvent
    ]

    Transfer: Type[MockEzEthPoolTransferContractEvent]

    UserRoleUpdated: Type[MockEzEthPoolUserRoleUpdatedContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.Approval = cast(
            Type[MockEzEthPoolApprovalContractEvent],
            MockEzEthPoolApprovalContractEvent.factory(
                "Approval",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Approval",
            ),
        )
        self.AuthorityUpdated = cast(
            Type[MockEzEthPoolAuthorityUpdatedContractEvent],
            MockEzEthPoolAuthorityUpdatedContractEvent.factory(
                "AuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AuthorityUpdated",
            ),
        )
        self.OwnershipTransferred = cast(
            Type[MockEzEthPoolOwnershipTransferredContractEvent],
            MockEzEthPoolOwnershipTransferredContractEvent.factory(
                "OwnershipTransferred",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OwnershipTransferred",
            ),
        )
        self.PublicCapabilityUpdated = cast(
            Type[MockEzEthPoolPublicCapabilityUpdatedContractEvent],
            MockEzEthPoolPublicCapabilityUpdatedContractEvent.factory(
                "PublicCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PublicCapabilityUpdated",
            ),
        )
        self.RoleCapabilityUpdated = cast(
            Type[MockEzEthPoolRoleCapabilityUpdatedContractEvent],
            MockEzEthPoolRoleCapabilityUpdatedContractEvent.factory(
                "RoleCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RoleCapabilityUpdated",
            ),
        )
        self.TargetCustomAuthorityUpdated = cast(
            Type[MockEzEthPoolTargetCustomAuthorityUpdatedContractEvent],
            MockEzEthPoolTargetCustomAuthorityUpdatedContractEvent.factory(
                "TargetCustomAuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TargetCustomAuthorityUpdated",
            ),
        )
        self.Transfer = cast(
            Type[MockEzEthPoolTransferContractEvent],
            MockEzEthPoolTransferContractEvent.factory(
                "Transfer",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Transfer",
            ),
        )
        self.UserRoleUpdated = cast(
            Type[MockEzEthPoolUserRoleUpdatedContractEvent],
            MockEzEthPoolUserRoleUpdatedContractEvent.factory(
                "UserRoleUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="UserRoleUpdated",
            ),
        )


class MockEzEthPoolContract(Contract):
    """A web3.py Contract class for the MockEzEthPool contract."""

    abi: ABI = mockezethpool_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x6101006040523480156200001257600080fd5b5060405162002bcf38038062002bcf833981016040819052620000359162000211565b6040518060400160405280600b81526020016a0a4cadcf4de40caf48aa8960ab1b815250604051806040016040528060058152602001640caf48aa8960db1b815250601285858582308181898989826000908162000094919062000316565b506001620000a3838262000316565b5060ff81166080524660a052620000b962000175565b60c0525050600680546001600160a01b038086166001600160a01b03199283168117909355600780549186169190921617905560405190915033907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a35050505090151560e052600c55505050600e94909455505042600f5550620004609050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051620001a99190620003e2565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b600080600080608085870312156200022857600080fd5b845160208601519094506001600160a01b03811681146200024857600080fd5b604086015190935080151581146200025f57600080fd5b6060959095015193969295505050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200029a57607f821691505b602082108103620002bb57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111562000311576000816000526020600020601f850160051c81016020861015620002ec5750805b601f850160051c820191505b818110156200030d57828155600101620002f8565b5050505b505050565b81516001600160401b038111156200033257620003326200026f565b6200034a8162000343845462000285565b84620002c1565b602080601f831160018114620003825760008415620003695750858301515b600019600386901b1c1916600185901b1785556200030d565b600085815260208120601f198616915b82811015620003b35788860151825594840194600190910190840162000392565b5085821015620003d25787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000808354620003f28162000285565b600182811680156200040d5760018114620004235762000454565b60ff198416875282151583028701945062000454565b8760005260208060002060005b858110156200044b5781548a82015290840190820162000430565b50505082870194505b50929695505050505050565b60805160a05160c05160e051612704620004cb6000396000818161076001528181610b8101528181610c9201528181610f340152818161100b015281816110aa0152818161150f015261157101526000610fd001526000610f9b0152600061056e01526127046000f3fe6080604052600436106103805760003560e01c80637a28fb88116101d1578063b700961311610102578063dd62ed3e116100a0578063f2fde38b1161006f578063f2fde38b14610ab9578063f5eb42dc14610ad9578063f6326fb314610af9578063ff9969cd14610b0157600080fd5b8063dd62ed3e146109cd578063e688747b14610a05578063ea7ca27614610a48578063ed0d0efb14610a8c57600080fd5b8063c53a3985116100dc578063c53a398514610942578063c5c83cb014610978578063d5002f2e14610998578063d505accf146109ad57600080fd5b8063b7009613146108e7578063ba28a57114610907578063bf7e214f1461092257600080fd5b80638fcb4e5b1161016f578063a0712d6811610149578063a0712d6814610864578063a1903eab14610884578063a9059cbb14610897578063aed30777146108b757600080fd5b80638fcb4e5b1461080f57806395d89b411461082f5780639dc29fac1461084457600080fd5b80637ecebe00116101ab5780637ecebe00146107a2578063892866a4146104c95780638da5cb5b146107cf5780638f686e6a146107ef57600080fd5b80637a28fb881461072e5780637a8c63b51461074e5780637a9e5e4b1461078257600080fd5b806334fcf437116102b657806347b714e01161025457806369415b861161022357806369415b86146106ab5780636d780459146106c157806370a08231146106e1578063728b952b1461070e57600080fd5b806347b714e0146106425780634b5159da14610656578063679aefce1461067657806367aff4841461068b57600080fd5b806337cfdaca1161029057806337cfdaca146105d75780633a98ef39146105ec57806340c10f191461060257806342966c681461062257600080fd5b806334fcf437146105a25780633644e515146105c2578063379336251461038557600080fd5b80630ea9b75b1161032357806319208451116102fd5780631920845114610506578063239c70ae1461052657806323b872dd1461053c578063313ce5671461055c57600080fd5b80630ea9b75b146104a957806313a73c78146104c957806318160ddd146104f057600080fd5b806306fdde031161035f57806306fdde0314610407578063088a4ed014610429578063095ea7b3146104495780630bade8a41461047957600080fd5b806252e3fd1461038557806305f05a94146103b857806306a36aee146103da575b600080fd5b34801561039157600080fd5b506103a56103a0366004611e9d565b610b25565b6040519081526020015b60405180910390f35b3480156103c457600080fd5b506103d86103d3366004611ed7565b610b7f565b005b3480156103e657600080fd5b506103a56103f5366004611f10565b60096020526000908152604090205481565b34801561041357600080fd5b5061041c610c02565b6040516103af9190611f2d565b34801561043557600080fd5b506103d8610444366004611f7c565b610c90565b34801561045557600080fd5b50610469610464366004611e9d565b610ced565b60405190151581526020016103af565b34801561048557600080fd5b50610469610494366004611fb2565b600a6020526000908152604090205460ff1681565b3480156104b557600080fd5b506103d86104c4366004611fde565b610d5a565b3480156104d557600080fd5b50305b6040516001600160a01b0390911681526020016103af565b3480156104fc57600080fd5b506103a560025481565b34801561051257600080fd5b506103a5610521366004611f7c565b610e32565b34801561053257600080fd5b506103a5600c5481565b34801561054857600080fd5b50610469610557366004612025565b610e50565b34801561056857600080fd5b506105907f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff90911681526020016103af565b3480156105ae57600080fd5b506103d86105bd366004611f7c565b610f32565b3480156105ce57600080fd5b506103a5610f97565b3480156105e357600080fd5b506103a5610ff2565b3480156105f857600080fd5b506103a560115481565b34801561060e57600080fd5b506103d861061d366004611e9d565b611009565b34801561062e57600080fd5b506103d861063d366004611f7c565b6110a8565b34801561064e57600080fd5b5060006103a5565b34801561066257600080fd5b506103d8610671366004612066565b61110d565b34801561068257600080fd5b50600e546103a5565b34801561069757600080fd5b506103d86106a6366004612082565b61119f565b3480156106b757600080fd5b506103a560105481565b3480156106cd57600080fd5b506103a56106dc366004612025565b611267565b3480156106ed57600080fd5b506103a56106fc366004611f10565b60036020526000908152604090205481565b34801561071a57600080fd5b506103d86107293660046120b0565b61129f565b34801561073a57600080fd5b506103a5610749366004611f7c565b611328565b34801561075a57600080fd5b506104697f000000000000000000000000000000000000000000000000000000000000000081565b34801561078e57600080fd5b506103d861079d366004611f10565b61133d565b3480156107ae57600080fd5b506103a56107bd366004611f10565b60056020526000908152604090205481565b3480156107db57600080fd5b506006546104d8906001600160a01b031681565b3480156107fb57600080fd5b506103a561080a3660046120de565b611427565b34801561081b57600080fd5b506103a561082a366004611e9d565b6114d5565b34801561083b57600080fd5b5061041c611500565b34801561085057600080fd5b506103d861085f366004611e9d565b61150d565b34801561087057600080fd5b506103d861087f366004611f7c565b61156f565b6103a5610892366004611f10565b61160a565b3480156108a357600080fd5b506104696108b2366004611e9d565b611696565b3480156108c357600080fd5b506104696108d2366004611f10565b600d6020526000908152604090205460ff1681565b3480156108f357600080fd5b5061046961090236600461210a565b6116fc565b34801561091357600080fd5b506103a56103a036600461222b565b34801561092e57600080fd5b506007546104d8906001600160a01b031681565b34801561094e57600080fd5b506104d861095d366004611f10565b6008602052600090815260409020546001600160a01b031681565b34801561098457600080fd5b506103a56109933660046120de565b6117fa565b3480156109a457600080fd5b506011546103a5565b3480156109b957600080fd5b506103d86109c83660046122ed565b61183d565b3480156109d957600080fd5b506103a56109e83660046120b0565b600460209081526000928352604080842090915290825290205481565b348015610a1157600080fd5b50610469610a2036600461235b565b6001600160e01b0319166000908152600b602052604090205460ff919091161c600116151590565b348015610a5457600080fd5b50610469610a6336600461238e565b6001600160a01b0391909116600090815260096020526040902054600160ff9092161c16151590565b348015610a9857600080fd5b506103a5610aa7366004611fb2565b600b6020526000908152604090205481565b348015610ac557600080fd5b506103d8610ad4366004611f10565b611a81565b348015610ae557600080fd5b506103a5610af4366004611f10565b611aff565b6103d8611b34565b348015610b0d57600080fd5b50610b16611b7c565b6040516103af939291906123f6565b60405162461bcd60e51b815260206004820152602160248201527f6c6f6f6b7570546f6b656e56616c75653a204e6f7420496d706c656d656e74656044820152601960fa1b60648201526000906084015b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000015610bd757610bbb336000356001600160e01b031916611bab565b610bd75760405162461bcd60e51b8152600401610b7690612475565b6001600160a01b03919091166000908152600d60205260409020805460ff1916911515919091179055565b60008054610c0f906124ac565b80601f0160208091040260200160405190810160405280929190818152602001828054610c3b906124ac565b8015610c885780601f10610c5d57610100808354040283529160200191610c88565b820191906000526020600020905b815481529060010190602001808311610c6b57829003601f168201915b505050505081565b7f000000000000000000000000000000000000000000000000000000000000000015610ce857610ccc336000356001600160e01b031916611bab565b610ce85760405162461bcd60e51b8152600401610b7690612475565b600c55565b3360008181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590610d489086815260200190565b60405180910390a35060015b92915050565b610d70336000356001600160e01b031916611bab565b610d8c5760405162461bcd60e51b8152600401610b76906124e6565b8015610dbc576001600160e01b031982166000908152600b602052604090208054600160ff86161b179055610de3565b6001600160e01b031982166000908152600b602052604090208054600160ff86161b191690555b816001600160e01b0319168360ff167fbfe16b2c35ce23dfd1ab0e7b5d086a10060c9b52d1574e1680c881b3b3a2b15183604051610e25911515815260200190565b60405180910390a3505050565b6000610d54610e4060115490565b610e48610ff2565b849190611c54565b6001600160a01b03831660009081526004602090815260408083203384529091528120546000198114610eac57610e878382612522565b6001600160a01b03861660009081526004602090815260408083203384529091529020555b6001600160a01b03851660009081526003602052604081208054859290610ed4908490612522565b90915550506001600160a01b03808516600081815260036020526040908190208054870190555190918716906000805160206126af83398151915290610f1d9087815260200190565b60405180910390a360019150505b9392505050565b7f000000000000000000000000000000000000000000000000000000000000000015610f8a57610f6e336000356001600160e01b031916611bab565b610f8a5760405162461bcd60e51b8152600401610b7690612475565b610f92611c72565b600e55565b60007f00000000000000000000000000000000000000000000000000000000000000004614610fcd57610fc8611ca3565b905090565b507f000000000000000000000000000000000000000000000000000000000000000090565b6000610ffc611d3d565b601054610fc89190612535565b7f00000000000000000000000000000000000000000000000000000000000000001561106157611045336000356001600160e01b031916611bab565b6110615760405162461bcd60e51b8152600401610b7690612475565b336000908152600d602052604090205460ff1661109a57600c5481111561109a5760405162461bcd60e51b8152600401610b7690612548565b6110a48282611da2565b5050565b7f000000000000000000000000000000000000000000000000000000000000000015611100576110e4336000356001600160e01b031916611bab565b6111005760405162461bcd60e51b8152600401610b7690612475565b61110a3382611dfc565b50565b611123336000356001600160e01b031916611bab565b61113f5760405162461bcd60e51b8152600401610b76906124e6565b6001600160e01b031982166000818152600a6020908152604091829020805460ff191685151590811790915591519182527f36d28126bef21a4f3765d7fcb7c45cead463ae4c41094ef3b771ede598544103910160405180910390a25050565b6111b5336000356001600160e01b031916611bab565b6111d15760405162461bcd60e51b8152600401610b76906124e6565b8015611200576001600160a01b03831660009081526009602052604090208054600160ff85161b179055611226565b6001600160a01b03831660009081526009602052604090208054600160ff85161b191690555b8160ff16836001600160a01b03167f4c9bdd0c8e073eb5eda2250b18d8e5121ff27b62064fbeeeed4869bb99bc5bf283604051610e25911515815260200190565b6000611271611c72565b600061128961127e610ff2565b601154859190611c54565b9050611296858583610e50565b50949350505050565b6112b5336000356001600160e01b031916611bab565b6112d15760405162461bcd60e51b8152600401610b76906124e6565b6001600160a01b0382811660008181526008602052604080822080546001600160a01b0319169486169485179055517fa4908e11a5f895b13d51526c331ac93cdd30e59772361c5d07874eb36bff20659190a35050565b6000610d54611335610ff2565b601154610e48565b6006546001600160a01b03163314806113d2575060075460405163b700961360e01b81526001600160a01b039091169063b70096139061139190339030906001600160e01b0319600035169060040161258a565b602060405180830381865afa1580156113ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d291906125b7565b6113db57600080fd5b600780546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6000831580611434575081155b15611440575081610f2b565b600061144c8486612535565b61145e85670de0b6b3a76400006125d4565b61146891906125eb565b9050600061147e82670de0b6b3a7640000612522565b611490670de0b6b3a7640000866125d4565b61149a91906125eb565b905060006114a88583612522565b9050806000036114cb57604051632160733960e01b815260040160405180910390fd5b9695505050505050565b60006114df611c72565b60006114ec61127e610ff2565b90506114f88482611696565b509392505050565b60018054610c0f906124ac565b7f00000000000000000000000000000000000000000000000000000000000000001561156557611549336000356001600160e01b031916611bab565b6115655760405162461bcd60e51b8152600401610b7690612475565b6110a48282611dfc565b7f0000000000000000000000000000000000000000000000000000000000000000156115c7576115ab336000356001600160e01b031916611bab565b6115c75760405162461bcd60e51b8152600401610b7690612475565b336000908152600d602052604090205460ff1661160057600c548111156116005760405162461bcd60e51b8152600401610b7690612548565b61110a3382611da2565b6000611614611c72565b60115460000361163b573460118190556010819055611634903390611da2565b5034919050565b600061165961164960115490565b611651610ff2565b349190611c54565b9050346010600082825461166d9190612535565b9250508190555080601160008282546116869190612535565b90915550610d5490503334611da2565b336000908152600360205260408120805483919083906116b7908490612522565b90915550506001600160a01b038316600081815260036020526040908190208054850190555133906000805160206126af83398151915290610d489086815260200190565b6001600160a01b0380831660009081526008602052604081205490911680156117985760405163b700961360e01b81526001600160a01b0382169063b70096139061174f9088908890889060040161258a565b602060405180830381865afa15801561176c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061179091906125b7565b915050610f2b565b6001600160e01b031983166000908152600a602052604090205460ff16806117f157506001600160e01b031983166000908152600b60209081526040808320546001600160a01b03891684526009909252909120541615155b95945050505050565b6000808361180886856125d4565b61181291906125eb565b90508060000361183557604051632160733960e01b815260040160405180910390fd5b949350505050565b4284101561188d5760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610b76565b60006001611899610f97565b6001600160a01b038a811660008181526005602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938d166060840152608083018c905260a083019390935260c08083018b90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600084529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa1580156119a5573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116158015906119db5750876001600160a01b0316816001600160a01b0316145b611a185760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610b76565b6001600160a01b0390811660009081526004602090815260408083208a8516808552908352928190208990555188815291928a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b611a97336000356001600160e01b031916611bab565b611ab35760405162461bcd60e51b8152600401610b76906124e6565b600680546001600160a01b0319166001600160a01b03831690811790915560405133907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a350565b6001600160a01b038116600090815260036020526040812054610f2b611b2460115490565b611b2c610ff2565b839190611c54565b60405162461bcd60e51b815260206004820152601b60248201527f6465706f7369744554483a204e6f7420496d706c656d656e74656400000000006044820152606401610b76565b60608060006060806000611b9e611b91610ff2565b6011546002549190611c54565b9296919550919350915050565b6007546000906001600160a01b03168015801590611c35575060405163b700961360e01b81526001600160a01b0382169063b700961390611bf49087903090889060040161258a565b602060405180830381865afa158015611c11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c3591906125b7565b8061183557506006546001600160a01b03858116911614949350505050565b6000826000190484118302158202611c6b57600080fd5b5091020490565b6000611c7c611d3d565b90508015611c9c578060106000828254611c969190612535565b90915550505b5042600f55565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051611cd5919061260d565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b6000600e54600003611d4f5750600090565b600f54421015611d5f5750600090565b6000611d7d6301e13380600f5442611d779190612522565b90611e5e565b90506000610f2b611d9983600e54611e7390919063ffffffff16565b60105490611e73565b8060026000828254611db49190612535565b90915550506001600160a01b0382166000818152600360209081526040808320805486019055518481526000805160206126af83398151915291015b60405180910390a35050565b6001600160a01b03821660009081526003602052604081208054839290611e24908490612522565b90915550506002805482900390556040518181526000906001600160a01b038416906000805160206126af83398151915290602001611df0565b6000610f2b83670de0b6b3a764000084611c54565b6000610f2b8383670de0b6b3a7640000611c54565b6001600160a01b038116811461110a57600080fd5b60008060408385031215611eb057600080fd5b8235611ebb81611e88565b946020939093013593505050565b801515811461110a57600080fd5b60008060408385031215611eea57600080fd5b8235611ef581611e88565b91506020830135611f0581611ec9565b809150509250929050565b600060208284031215611f2257600080fd5b8135610f2b81611e88565b60006020808352835180602085015260005b81811015611f5b57858101830151858201604001528201611f3f565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215611f8e57600080fd5b5035919050565b80356001600160e01b031981168114611fad57600080fd5b919050565b600060208284031215611fc457600080fd5b610f2b82611f95565b803560ff81168114611fad57600080fd5b600080600060608486031215611ff357600080fd5b611ffc84611fcd565b925061200a60208501611f95565b9150604084013561201a81611ec9565b809150509250925092565b60008060006060848603121561203a57600080fd5b833561204581611e88565b9250602084013561205581611e88565b929592945050506040919091013590565b6000806040838503121561207957600080fd5b611ef583611f95565b60008060006060848603121561209757600080fd5b83356120a281611e88565b925061200a60208501611fcd565b600080604083850312156120c357600080fd5b82356120ce81611e88565b91506020830135611f0581611e88565b6000806000606084860312156120f357600080fd5b505081359360208301359350604090920135919050565b60008060006060848603121561211f57600080fd5b833561212a81611e88565b9250602084013561213a81611e88565b915061214860408501611f95565b90509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561219057612190612151565b604052919050565b600067ffffffffffffffff8211156121b2576121b2612151565b5060051b60200190565b600082601f8301126121cd57600080fd5b813560206121e26121dd83612198565b612167565b8083825260208201915060208460051b87010193508684111561220457600080fd5b602086015b848110156122205780358352918301918301612209565b509695505050505050565b6000806040838503121561223e57600080fd5b823567ffffffffffffffff8082111561225657600080fd5b818501915085601f83011261226a57600080fd5b8135602061227a6121dd83612198565b82815260059290921b8401810191818101908984111561229957600080fd5b948201945b838610156122c05785356122b181611e88565b8252948201949082019061229e565b965050860135925050808211156122d657600080fd5b506122e3858286016121bc565b9150509250929050565b600080600080600080600060e0888a03121561230857600080fd5b873561231381611e88565b9650602088013561232381611e88565b9550604088013594506060880135935061233f60808901611fcd565b925060a0880135915060c0880135905092959891949750929550565b6000806040838503121561236e57600080fd5b61237783611fcd565b915061238560208401611f95565b90509250929050565b600080604083850312156123a157600080fd5b82356123ac81611e88565b915061238560208401611fcd565b60008151808452602080850194506020840160005b838110156123eb578151875295820195908201906001016123cf565b509495945050505050565b6000606082016060835280865180835260808501915060808160051b8601019250602080890160005b8381101561244d57607f1988870301855261243b8683516123ba565b9550938201939082019060010161241f565b5050505050828103602084015261246481866123ba565b915050826040830152949350505050565b6020808252601d908201527f45524332304d696e7461626c653a206e6f7420617574686f72697a6564000000604082015260600190565b600181811c908216806124c057607f821691505b6020821081036124e057634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b81810381811115610d5457610d5461250c565b80820180821115610d5457610d5461250c565b60208082526022908201527f45524332304d696e7461626c653a20496e76616c6964206d696e7420616d6f756040820152611b9d60f21b606082015260800190565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b6000602082840312156125c957600080fd5b8151610f2b81611ec9565b8082028115828204841417610d5457610d5461250c565b60008261260857634e487b7160e01b600052601260045260246000fd5b500490565b60008083548160018260011c9150600183168061262b57607f831692505b6020808410820361264a57634e487b7160e01b86526022600452602486fd5b81801561265e5760018114612673576126a0565b60ff19861689528415158502890196506126a0565b60008a81526020902060005b868110156126985781548b82015290850190830161267f565b505084890196505b50949897505050505050505056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa264697066735822122056d7320485ab7f03b81d23ed7357a566f095208ec99cd15d6836d5f11552549664736f6c63430008160033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = MockEzEthPoolContractFunctions(mockezethpool_abi, self.w3, address)  # type: ignore
        self.events = MockEzEthPoolContractEvents(mockezethpool_abi, self.w3, address)  # type: ignore
        self.errors = MockEzEthPoolContractErrors()

    events: MockEzEthPoolContractEvents

    errors: MockEzEthPoolContractErrors = MockEzEthPoolContractErrors()

    functions: MockEzEthPoolContractFunctions

    class ConstructorArgs(NamedTuple):
        """Arguments to pass the contract's constructor function."""

        initialRate: int

        admin: str

        isCompetitionMode: bool

        maxMintAmount: int

    @classmethod
    def constructor(cls, initialRate: int, admin: str, isCompetitionMode: bool, maxMintAmount: int) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor(
            dataclass_to_tuple(initialRate),
            dataclass_to_tuple(admin),
            dataclass_to_tuple(isCompetitionMode),
            dataclass_to_tuple(maxMintAmount),
        )

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        constructor_args: ConstructorArgs,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(
            *constructor_args,
        )

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = MockEzEthPoolContractFunctions(
            mockezethpool_abi, w3, None
        )
        contract.errors = MockEzEthPoolContractErrors()

        return contract
