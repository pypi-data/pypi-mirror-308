{"version":3,"file":"index.Trgl1nBJ.js","sources":["../../../../lib/src/components/elements/Video/Video.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement, useEffect, useMemo, useRef } from \"react\"\n\nimport { ISubtitleTrack, Video as VideoProto } from \"@streamlit/lib/src/proto\"\nimport { StreamlitEndpoints } from \"@streamlit/lib/src/StreamlitEndpoints\"\nimport { IS_DEV_ENV } from \"@streamlit/lib/src/baseconsts\"\nimport { WidgetStateManager as ElementStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\n\nconst DEFAULT_HEIGHT = 528\n\nexport interface VideoProps {\n  endpoints: StreamlitEndpoints\n  width: number\n  element: VideoProto\n  elementMgr: ElementStateManager\n}\n\nexport interface Subtitle {\n  label: string\n  url: string\n}\n\nexport default function Video({\n  element,\n  width,\n  endpoints,\n  elementMgr,\n}: Readonly<VideoProps>): ReactElement {\n  const videoRef = useRef<HTMLVideoElement>(null)\n\n  /* Element may contain \"url\" or \"data\" property. */\n  const { type, url, startTime, subtitles, endTime, loop, autoplay, muted } =\n    element\n\n  const preventAutoplay = useMemo<boolean>(() => {\n    if (!element.id) {\n      // Elements without an ID should never autoplay\n      return true\n    }\n\n    // Recover the state in case this component got unmounted\n    // and mounted again for the same element.\n    const preventAutoplay = elementMgr.getElementState(\n      element.id,\n      \"preventAutoplay\"\n    )\n\n    if (!preventAutoplay) {\n      // Set the state to prevent autoplay in case there is an unmount + mount\n      // for the same element.\n      elementMgr.setElementState(element.id, \"preventAutoplay\", true)\n    }\n    return preventAutoplay ?? false\n  }, [element.id, elementMgr])\n\n  // Handle startTime changes\n  useEffect(() => {\n    if (videoRef.current) {\n      videoRef.current.currentTime = startTime\n    }\n  }, [startTime])\n\n  useEffect(() => {\n    const videoNode = videoRef.current\n\n    const setStartTime: () => void = () => {\n      if (videoNode) {\n        videoNode.currentTime = element.startTime\n      }\n    }\n\n    if (videoNode) {\n      videoNode.addEventListener(\"loadedmetadata\", setStartTime)\n    }\n\n    return () => {\n      if (videoNode) {\n        videoNode.removeEventListener(\"loadedmetadata\", setStartTime)\n      }\n    }\n  }, [element])\n\n  // Stop the video at 'endTime' and handle loop\n  useEffect(() => {\n    const videoNode = videoRef.current\n    if (!videoNode) {\n      return\n    }\n\n    // Flag to avoid calling 'videoNode.pause()' multiple times\n    let stoppedByEndTime = false\n\n    const handleTimeUpdate = (): void => {\n      if (endTime > 0 && videoNode.currentTime >= endTime) {\n        if (loop) {\n          // If loop is true and we reached 'endTime', reset to 'startTime'\n          videoNode.currentTime = startTime || 0\n          videoNode.play()\n        } else if (!stoppedByEndTime) {\n          stoppedByEndTime = true\n          videoNode.pause()\n        }\n      }\n    }\n\n    if (endTime > 0) {\n      videoNode.addEventListener(\"timeupdate\", handleTimeUpdate)\n    }\n\n    return () => {\n      if (videoNode && endTime > 0) {\n        videoNode.removeEventListener(\"timeupdate\", handleTimeUpdate)\n      }\n    }\n  }, [endTime, loop, startTime])\n\n  // Handle looping the video\n  useEffect(() => {\n    const videoNode = videoRef.current\n    if (!videoNode) {\n      return\n    }\n\n    // Loop the video when it has ended\n    const handleVideoEnd = (): void => {\n      if (loop) {\n        videoNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified\n        videoNode.play()\n      }\n    }\n\n    videoNode.addEventListener(\"ended\", handleVideoEnd)\n\n    return () => {\n      if (videoNode) {\n        videoNode.removeEventListener(\"ended\", handleVideoEnd)\n      }\n    }\n  }, [loop, startTime])\n\n  const getYoutubeSrc = (url: string): string => {\n    const { startTime, endTime, loop, autoplay, muted } = element\n    const youtubeUrl = new URL(url)\n\n    if (startTime && !isNaN(startTime)) {\n      youtubeUrl.searchParams.append(\"start\", startTime.toString())\n    }\n\n    if (endTime && !isNaN(endTime)) {\n      youtubeUrl.searchParams.append(\"end\", endTime.toString())\n    }\n\n    if (loop) {\n      youtubeUrl.searchParams.append(\"loop\", \"1\")\n      // When using the loop parameter, YouTube requires the playlist parameter to be set to the same video ID\n      const videoId = youtubeUrl.pathname.split(\"/\").pop()\n\n      if (videoId) {\n        youtubeUrl.searchParams.append(\"playlist\", videoId)\n      }\n    }\n\n    if (autoplay) {\n      youtubeUrl.searchParams.append(\"autoplay\", \"1\")\n    }\n\n    if (muted) {\n      youtubeUrl.searchParams.append(\"mute\", \"1\")\n    }\n\n    return youtubeUrl.toString()\n  }\n\n  /* Is this a YouTube link? If so we need a fancier tag.\n       NOTE: This part assumes the URL is already an \"embed\" link.\n    */\n  if (type === VideoProto.Type.YOUTUBE_IFRAME) {\n    // At some point the width 0 will be passed to this component\n    // which is caused by the AutoSizer of the VerticalLayout\n    // Width 0 will result in height being 0, which results in issue\n    // https://github.com/streamlit/streamlit/issues/5069\n    // To avoid this, when we detect width is 0, we set height to 528,\n    // which is default height based on the default streamlit width\n    const height = width !== 0 ? width * 0.75 : DEFAULT_HEIGHT\n\n    return (\n      <iframe\n        className=\"stVideo\"\n        data-testid=\"stVideo\"\n        title={url}\n        src={getYoutubeSrc(url)}\n        width={width}\n        height={height}\n        style={{ colorScheme: \"normal\" }}\n        frameBorder=\"0\"\n        allow=\"autoplay; encrypted-media\"\n        allowFullScreen\n      />\n    )\n  }\n\n  // Only in dev mode we set crossOrigin to \"anonymous\" to avoid CORS issues\n  // when streamlit frontend and backend are running on different ports\n  return (\n    <video\n      className=\"stVideo\"\n      data-testid=\"stVideo\"\n      ref={videoRef}\n      controls\n      muted={muted}\n      autoPlay={autoplay && !preventAutoplay}\n      src={endpoints.buildMediaURL(url)}\n      style={{ width, height: width === 0 ? DEFAULT_HEIGHT : undefined }}\n      crossOrigin={\n        IS_DEV_ENV && subtitles.length > 0 ? \"anonymous\" : undefined\n      }\n    >\n      {subtitles &&\n        subtitles.map((subtitle: ISubtitleTrack, idx: number) => (\n          <track\n            key={idx}\n            kind=\"captions\"\n            src={endpoints.buildMediaURL(`${subtitle.url}`)}\n            label={`${subtitle.label}`}\n            default={idx === 0}\n          />\n        ))}\n    </video>\n  )\n}\n"],"names":["DEFAULT_HEIGHT","Video","element","width","endpoints","elementMgr","videoRef","useRef","type","url","startTime","subtitles","endTime","loop","autoplay","muted","preventAutoplay","useMemo","id","getElementState","setElementState","useEffect","current","currentTime","videoNode","setStartTime","addEventListener","removeEventListener","stoppedByEndTime","handleTimeUpdate","play","pause","handleVideoEnd","getYoutubeSrc","youtubeUrl","URL","isNaN","searchParams","append","toString","videoId","pathname","split","pop","VideoProto","Type","YOUTUBE_IFRAME","height","iframe","className","data-testid","title","src","style","colorScheme","frameBorder","allow","allowFullScreen","video","ref","controls","autoPlay","buildMediaURL","undefined","crossOrigin","map","subtitle","idx","track","kind","label","default"],"mappings":"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"}