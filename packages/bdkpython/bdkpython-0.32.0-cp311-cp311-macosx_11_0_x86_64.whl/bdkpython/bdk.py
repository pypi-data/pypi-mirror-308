

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("bdkffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_bdkffi_checksum_method_address_as_string() != 26179:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 10350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_network() != 33317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_payload() != 29657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_script_pubkey() != 10722:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_to_qr_uri() != 48141:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_blockchain_broadcast() != 34917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_blockchain_estimate_fee() != 15613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_blockchain_get_block_hash() != 11615:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_blockchain_get_height() != 34657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_blockchain_get_tx() != 29310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_shrinking() != 57772:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf() != 30060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence() != 3682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 63571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptor_as_string() != 23756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptor_as_string_private() != 64930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string() != 37256:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 37338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 46199:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 56954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string() != 28335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 44428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 46796:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 40876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_feerate_as_sat_per_vb() != 60213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_mnemonic_as_string() != 3181:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_combine() != 22013:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_extract_tx() != 10768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_amount() != 51074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_rate() != 53236:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_json_serialize() != 42145:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_serialize() != 39126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_txid() != 60285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_script_to_bytes() != 31368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_input() != 5374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_coin_base() != 42930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 32682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 48885:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_lock_time() != 49321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_output() != 30237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_serialize() != 62862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_size() != 63453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_txid() != 29904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_version() != 15271:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_vsize() != 3804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_weight() != 21879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_data() != 7385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 52335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 33319:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 43637:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_utxos() != 34089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 51770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 58882:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 5081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf() != 38825:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence() != 26979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 3622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 62655:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_finish() != 17491:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 12623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 18757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 20461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 49004:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_address() != 52401:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_balance() != 10566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_internal_address() != 5308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_is_mine() != 10955:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_transactions() != 18014:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_unspent() != 42342:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_network() != 32197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sign() != 53268:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sync() != 52330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_address_from_script() != 51133:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_address_new() != 33853:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_blockchain_new() != 36607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 52889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_derivationpath_new() != 57618:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new() != 57144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 44216:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 55284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 10038:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 14422:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 4773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 45733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 42468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 60819:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 26782:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 53598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 61342:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb() != 6833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 49208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 40755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_new() != 51578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_partiallysignedtransaction_new() != 51370:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_script_new() != 43552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_transaction_new() != 56229:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_txbuilder_new() != 6280:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_wallet_new() != 23901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_progress_update() != 64474:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_PROGRESS_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_float,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceProgress(ctypes.Structure):
    _fields_ = [
        ("update", _UNIFFI_CALLBACK_INTERFACE_PROGRESS_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_bdkffi_fn_clone_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_address.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_address_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_network.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_payload.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_payload.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_blockchain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_blockchain.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_blockchain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_blockchain.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_blockchain_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_blockchain_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_broadcast.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_broadcast.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_estimate_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_estimate_fee.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_block_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_block_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_height.restype = ctypes.c_uint32
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_tx.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_tx.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_float,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_shrinking.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_shrinking.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_feerate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_feerate.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb.argtypes = (
    ctypes.c_float,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_feerate_as_sat_per_vb.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_feerate_as_sat_per_vb.restype = ctypes.c_float
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_partiallysignedtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_partiallysignedtransaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_partiallysignedtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_partiallysignedtransaction.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_partiallysignedtransaction_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_partiallysignedtransaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_combine.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_combine.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_extract_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_extract_tx.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_amount.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_rate.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_json_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_json_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_txid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_txid.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_script.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_script.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_script_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_script_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_transaction.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coin_base.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coin_base.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.restype = ctypes.c_uint32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.restype = ctypes.c_int32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_data.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxos.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxos.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_float,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_wallet.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_internal_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_internal_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sync.restype = None
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_progress.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceProgress),
)
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_progress.restype = None
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_free.restype = None
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_bdkffi_checksum_method_address_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_payload.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_payload.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_broadcast.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_estimate_fee.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_estimate_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_block_hash.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_block_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_height.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_height.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_blockchain_get_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_shrinking.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_shrinking.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string_private.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string_private.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_as_sat_per_vb.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_as_sat_per_vb.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_mnemonic_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_mnemonic_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_combine.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_combine.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_extract_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_extract_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_amount.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_json_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_json_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_txid.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_partiallysignedtransaction_txid.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_script_to_bytes.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_script_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coin_base.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coin_base.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_size.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_txid.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_txid.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_data.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxos.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxos.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_balance.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_internal_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_internal_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_transactions.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sync.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_from_script.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_from_script.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_blockchain_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_blockchain_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_partiallysignedtransaction_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_partiallysignedtransaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_script_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_script_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_progress_update.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_progress_update.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_bdkffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterFloat(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_float()

    @staticmethod
    def write(value, buf):
        buf.write_float(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class AddressProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def is_valid_for_network(self, network: "Network"):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def payload(self, ):
        raise NotImplementedError
    def script_pubkey(self, ):
        raise NotImplementedError
    def to_qr_uri(self, ):
        raise NotImplementedError


class Address:
    _pointer: ctypes.c_void_p
    def __init__(self, address: "str",network: "Network"):
        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_address_new,
        _UniffiConverterString.lower(address),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_address, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_address, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_script(cls, script: "Script",network: "Network"):
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script,
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_as_string,self._uniffi_clone_pointer(),)
        )





    def is_valid_for_network(self, network: "Network") -> "bool":
        _UniffiConverterTypeNetwork.check_lower(network)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNetwork.lower(network))
        )





    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_network,self._uniffi_clone_pointer(),)
        )





    def payload(self, ) -> "Payload":
        return _UniffiConverterTypePayload.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_payload,self._uniffi_clone_pointer(),)
        )





    def script_pubkey(self, ) -> "Script":
        return _UniffiConverterTypeScript.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey,self._uniffi_clone_pointer(),)
        )





    def to_qr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAddress:

    @staticmethod
    def lift(value: int):
        return Address._make_instance_(value)

    @staticmethod
    def check_lower(value: Address):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AddressProtocol):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlockchainProtocol(typing.Protocol):
    def broadcast(self, transaction: "Transaction"):
        raise NotImplementedError
    def estimate_fee(self, target: "int"):
        raise NotImplementedError
    def get_block_hash(self, height: "int"):
        raise NotImplementedError
    def get_height(self, ):
        raise NotImplementedError
    def get_tx(self, txid: "str"):
        raise NotImplementedError


class Blockchain:
    _pointer: ctypes.c_void_p
    def __init__(self, config: "BlockchainConfig"):
        _UniffiConverterTypeBlockchainConfig.check_lower(config)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_blockchain_new,
        _UniffiConverterTypeBlockchainConfig.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_blockchain, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_blockchain, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def broadcast(self, transaction: "Transaction") -> None:
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_blockchain_broadcast,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))






    def estimate_fee(self, target: "int") -> "FeeRate":
        _UniffiConverterUInt64.check_lower(target)
        
        return _UniffiConverterTypeFeeRate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_blockchain_estimate_fee,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(target))
        )





    def get_block_hash(self, height: "int") -> "str":
        _UniffiConverterUInt32.check_lower(height)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_block_hash,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(height))
        )





    def get_height(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_height,self._uniffi_clone_pointer(),)
        )





    def get_tx(self, txid: "str") -> "typing.Optional[Transaction]":
        _UniffiConverterString.check_lower(txid)
        
        return _UniffiConverterOptionalTypeTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_blockchain_get_tx,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(txid))
        )






class _UniffiConverterTypeBlockchain:

    @staticmethod
    def lift(value: int):
        return Blockchain._make_instance_(value)

    @staticmethod
    def check_lower(value: Blockchain):
        if not isinstance(value, Blockchain):
            raise TypeError("Expected Blockchain instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlockchainProtocol):
        if not isinstance(value, Blockchain):
            raise TypeError("Expected Blockchain instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlockchainProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BumpFeeTxBuilderProtocol(typing.Protocol):
    def allow_shrinking(self, script_pubkey: "Script"):
        raise NotImplementedError
    def enable_rbf(self, ):
        raise NotImplementedError
    def enable_rbf_with_sequence(self, nsequence: "int"):
        raise NotImplementedError
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError


class BumpFeeTxBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, txid: "str",new_fee_rate: "float"):
        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterFloat.check_lower(new_fee_rate)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new,
        _UniffiConverterString.lower(txid),
        _UniffiConverterFloat.lower(new_fee_rate))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def allow_shrinking(self, script_pubkey: "Script") -> "BumpFeeTxBuilder":
        _UniffiConverterTypeScript.check_lower(script_pubkey)
        
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_shrinking,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script_pubkey))
        )





    def enable_rbf(self, ) -> "BumpFeeTxBuilder":
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf,self._uniffi_clone_pointer(),)
        )





    def enable_rbf_with_sequence(self, nsequence: "int") -> "BumpFeeTxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )





    def finish(self, wallet: "Wallet") -> "PartiallySignedTransaction":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypePartiallySignedTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )






class _UniffiConverterTypeBumpFeeTxBuilder:

    @staticmethod
    def lift(value: int):
        return BumpFeeTxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: BumpFeeTxBuilder):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BumpFeeTxBuilderProtocol):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BumpFeeTxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DerivationPathProtocol(typing.Protocol):
    pass


class DerivationPath:
    _pointer: ctypes.c_void_p
    def __init__(self, path: "str"):
        _UniffiConverterString.check_lower(path)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new,
        _UniffiConverterString.lower(path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_derivationpath, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeDerivationPath:

    @staticmethod
    def lift(value: int):
        return DerivationPath._make_instance_(value)

    @staticmethod
    def check_lower(value: DerivationPath):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DerivationPathProtocol):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DerivationPathProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def as_string_private(self, ):
        raise NotImplementedError


class Descriptor:
    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "str",network: "Network"):
        _UniffiConverterString.check_lower(descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new,
        _UniffiConverterString.lower(descriptor),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptor, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptor, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_bip44(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip44_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string,self._uniffi_clone_pointer(),)
        )





    def as_string_private(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDescriptor:

    @staticmethod
    def lift(value: int):
        return Descriptor._make_instance_(value)

    @staticmethod
    def check_lower(value: Descriptor):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorProtocol):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorPublicKeyProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError


class DescriptorPublicKey:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, public_key: "str"):
        _UniffiConverterString.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string,
        _UniffiConverterString.lower(public_key))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string,self._uniffi_clone_pointer(),)
        )





    def derive(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def extend(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )






class _UniffiConverterTypeDescriptorPublicKey:

    @staticmethod
    def lift(value: int):
        return DescriptorPublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorPublicKey):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorPublicKeyProtocol):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorPublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorSecretKeyProtocol(typing.Protocol):
    def as_public(self, ):
        raise NotImplementedError
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError
    def secret_bytes(self, ):
        raise NotImplementedError


class DescriptorSecretKey:
    _pointer: ctypes.c_void_p
    def __init__(self, network: "Network",mnemonic: "Mnemonic",password: "typing.Optional[str]"):
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _UniffiConverterTypeMnemonic.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(password)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new,
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterTypeMnemonic.lower(mnemonic),
        _UniffiConverterOptionalString.lower(password))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, secret_key: "str"):
        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def as_public(self, ) -> "DescriptorPublicKey":
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public,self._uniffi_clone_pointer(),)
        )





    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string,self._uniffi_clone_pointer(),)
        )





    def derive(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def extend(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def secret_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDescriptorSecretKey:

    @staticmethod
    def lift(value: int):
        return DescriptorSecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorSecretKey):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorSecretKeyProtocol):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorSecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FeeRateProtocol(typing.Protocol):
    def as_sat_per_vb(self, ):
        raise NotImplementedError


class FeeRate:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_feerate, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_feerate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_sat_per_vb(cls, sat_per_vb: "float"):
        _UniffiConverterFloat.check_lower(sat_per_vb)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb,
        _UniffiConverterFloat.lower(sat_per_vb))
        return cls._make_instance_(pointer)



    def as_sat_per_vb(self, ) -> "float":
        return _UniffiConverterFloat.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_feerate_as_sat_per_vb,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFeeRate:

    @staticmethod
    def lift(value: int):
        return FeeRate._make_instance_(value)

    @staticmethod
    def check_lower(value: FeeRate):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FeeRateProtocol):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FeeRateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MnemonicProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError


class Mnemonic:
    _pointer: ctypes.c_void_p
    def __init__(self, word_count: "WordCount"):
        _UniffiConverterTypeWordCount.check_lower(word_count)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new,
        _UniffiConverterTypeWordCount.lower(word_count))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_mnemonic, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_entropy(cls, entropy: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(entropy)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy,
        _UniffiConverterSequenceUInt8.lower(entropy))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, mnemonic: "str"):
        _UniffiConverterString.check_lower(mnemonic)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string,
        _UniffiConverterString.lower(mnemonic))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMnemonic:

    @staticmethod
    def lift(value: int):
        return Mnemonic._make_instance_(value)

    @staticmethod
    def check_lower(value: Mnemonic):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MnemonicProtocol):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MnemonicProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PartiallySignedTransactionProtocol(typing.Protocol):
    def combine(self, other: "PartiallySignedTransaction"):
        raise NotImplementedError
    def extract_tx(self, ):
        raise NotImplementedError
    def fee_amount(self, ):
        raise NotImplementedError
    def fee_rate(self, ):
        raise NotImplementedError
    def json_serialize(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError
    def txid(self, ):
        raise NotImplementedError


class PartiallySignedTransaction:
    _pointer: ctypes.c_void_p
    def __init__(self, psbt_base64: "str"):
        _UniffiConverterString.check_lower(psbt_base64)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_partiallysignedtransaction_new,
        _UniffiConverterString.lower(psbt_base64))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_partiallysignedtransaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_partiallysignedtransaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def combine(self, other: "PartiallySignedTransaction") -> "PartiallySignedTransaction":
        _UniffiConverterTypePartiallySignedTransaction.check_lower(other)
        
        return _UniffiConverterTypePartiallySignedTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_combine,self._uniffi_clone_pointer(),
        _UniffiConverterTypePartiallySignedTransaction.lower(other))
        )





    def extract_tx(self, ) -> "Transaction":
        return _UniffiConverterTypeTransaction.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_extract_tx,self._uniffi_clone_pointer(),)
        )





    def fee_amount(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_amount,self._uniffi_clone_pointer(),)
        )





    def fee_rate(self, ) -> "typing.Optional[FeeRate]":
        return _UniffiConverterOptionalTypeFeeRate.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_rate,self._uniffi_clone_pointer(),)
        )





    def json_serialize(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_json_serialize,self._uniffi_clone_pointer(),)
        )





    def serialize(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_serialize,self._uniffi_clone_pointer(),)
        )





    def txid(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_partiallysignedtransaction_txid,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePartiallySignedTransaction:

    @staticmethod
    def lift(value: int):
        return PartiallySignedTransaction._make_instance_(value)

    @staticmethod
    def check_lower(value: PartiallySignedTransaction):
        if not isinstance(value, PartiallySignedTransaction):
            raise TypeError("Expected PartiallySignedTransaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PartiallySignedTransactionProtocol):
        if not isinstance(value, PartiallySignedTransaction):
            raise TypeError("Expected PartiallySignedTransaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PartiallySignedTransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ScriptProtocol(typing.Protocol):
    def to_bytes(self, ):
        raise NotImplementedError


class Script:
    _pointer: ctypes.c_void_p
    def __init__(self, raw_output_script: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(raw_output_script)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_script_new,
        _UniffiConverterSequenceUInt8.lower(raw_output_script))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_script, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_script, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def to_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeScript:

    @staticmethod
    def lift(value: int):
        return Script._make_instance_(value)

    @staticmethod
    def check_lower(value: Script):
        if not isinstance(value, Script):
            raise TypeError("Expected Script instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ScriptProtocol):
        if not isinstance(value, Script):
            raise TypeError("Expected Script instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ScriptProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TransactionProtocol(typing.Protocol):
    def input(self, ):
        raise NotImplementedError
    def is_coin_base(self, ):
        raise NotImplementedError
    def is_explicitly_rbf(self, ):
        raise NotImplementedError
    def is_lock_time_enabled(self, ):
        raise NotImplementedError
    def lock_time(self, ):
        raise NotImplementedError
    def output(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError
    def size(self, ):
        raise NotImplementedError
    def txid(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
    def vsize(self, ):
        raise NotImplementedError
    def weight(self, ):
        raise NotImplementedError


class Transaction:
    _pointer: ctypes.c_void_p
    def __init__(self, transaction_bytes: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(transaction_bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new,
        _UniffiConverterSequenceUInt8.lower(transaction_bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_transaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_transaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def input(self, ) -> "typing.List[TxIn]":
        return _UniffiConverterSequenceTypeTxIn.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_input,self._uniffi_clone_pointer(),)
        )





    def is_coin_base(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coin_base,self._uniffi_clone_pointer(),)
        )





    def is_explicitly_rbf(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf,self._uniffi_clone_pointer(),)
        )





    def is_lock_time_enabled(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled,self._uniffi_clone_pointer(),)
        )





    def lock_time(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time,self._uniffi_clone_pointer(),)
        )





    def output(self, ) -> "typing.List[TxOut]":
        return _UniffiConverterSequenceTypeTxOut.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_output,self._uniffi_clone_pointer(),)
        )





    def serialize(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize,self._uniffi_clone_pointer(),)
        )





    def size(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_size,self._uniffi_clone_pointer(),)
        )





    def txid(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_version,self._uniffi_clone_pointer(),)
        )





    def vsize(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize,self._uniffi_clone_pointer(),)
        )





    def weight(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransaction:

    @staticmethod
    def lift(value: int):
        return Transaction._make_instance_(value)

    @staticmethod
    def check_lower(value: Transaction):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionProtocol):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TxBuilderProtocol(typing.Protocol):
    def add_data(self, data: "typing.List[int]"):
        raise NotImplementedError
    def add_recipient(self, script: "Script",amount: "int"):
        raise NotImplementedError
    def add_unspendable(self, unspendable: "OutPoint"):
        raise NotImplementedError
    def add_utxo(self, outpoint: "OutPoint"):
        raise NotImplementedError
    def add_utxos(self, outpoints: "typing.List[OutPoint]"):
        raise NotImplementedError
    def do_not_spend_change(self, ):
        raise NotImplementedError
    def drain_to(self, script: "Script"):
        raise NotImplementedError
    def drain_wallet(self, ):
        raise NotImplementedError
    def enable_rbf(self, ):
        raise NotImplementedError
    def enable_rbf_with_sequence(self, nsequence: "int"):
        raise NotImplementedError
    def fee_absolute(self, fee_amount: "int"):
        raise NotImplementedError
    def fee_rate(self, sat_per_vbyte: "float"):
        raise NotImplementedError
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError
    def manually_selected_only(self, ):
        raise NotImplementedError
    def only_spend_change(self, ):
        raise NotImplementedError
    def set_recipients(self, recipients: "typing.List[ScriptAmount]"):
        raise NotImplementedError
    def unspendable(self, unspendable: "typing.List[OutPoint]"):
        raise NotImplementedError


class TxBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_txbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_data(self, data: "typing.List[int]") -> "TxBuilder":
        _UniffiConverterSequenceUInt8.check_lower(data)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_data,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt8.lower(data))
        )





    def add_recipient(self, script: "Script",amount: "int") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterUInt64.check_lower(amount)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterUInt64.lower(amount))
        )





    def add_unspendable(self, unspendable: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(unspendable))
        )





    def add_utxo(self, outpoint: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(outpoint)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(outpoint))
        )





    def add_utxos(self, outpoints: "typing.List[OutPoint]") -> "TxBuilder":
        _UniffiConverterSequenceTypeOutPoint.check_lower(outpoints)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxos,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeOutPoint.lower(outpoints))
        )





    def do_not_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change,self._uniffi_clone_pointer(),)
        )





    def drain_to(self, script: "Script") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )





    def drain_wallet(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet,self._uniffi_clone_pointer(),)
        )





    def enable_rbf(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf,self._uniffi_clone_pointer(),)
        )





    def enable_rbf_with_sequence(self, nsequence: "int") -> "TxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )





    def fee_absolute(self, fee_amount: "int") -> "TxBuilder":
        _UniffiConverterUInt64.check_lower(fee_amount)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(fee_amount))
        )





    def fee_rate(self, sat_per_vbyte: "float") -> "TxBuilder":
        _UniffiConverterFloat.check_lower(sat_per_vbyte)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterFloat.lower(sat_per_vbyte))
        )





    def finish(self, wallet: "Wallet") -> "TxBuilderResult":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypeTxBuilderResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )





    def manually_selected_only(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only,self._uniffi_clone_pointer(),)
        )





    def only_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change,self._uniffi_clone_pointer(),)
        )





    def set_recipients(self, recipients: "typing.List[ScriptAmount]") -> "TxBuilder":
        _UniffiConverterSequenceTypeScriptAmount.check_lower(recipients)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeScriptAmount.lower(recipients))
        )





    def unspendable(self, unspendable: "typing.List[OutPoint]") -> "TxBuilder":
        _UniffiConverterSequenceTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeOutPoint.lower(unspendable))
        )






class _UniffiConverterTypeTxBuilder:

    @staticmethod
    def lift(value: int):
        return TxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: TxBuilder):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TxBuilderProtocol):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class WalletProtocol(typing.Protocol):
    def get_address(self, address_index: "AddressIndex"):
        raise NotImplementedError
    def get_balance(self, ):
        raise NotImplementedError
    def get_internal_address(self, address_index: "AddressIndex"):
        raise NotImplementedError
    def is_mine(self, script: "Script"):
        raise NotImplementedError
    def list_transactions(self, include_raw: "bool"):
        raise NotImplementedError
    def list_unspent(self, ):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def sign(self, psbt: "PartiallySignedTransaction",sign_options: "typing.Optional[SignOptions]"):
        raise NotImplementedError
    def sync(self, blockchain: "Blockchain",progress: "typing.Optional[Progress]"):
        raise NotImplementedError


class Wallet:
    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "Descriptor",change_descriptor: "typing.Optional[Descriptor]",network: "Network",database_config: "DatabaseConfig"):
        _UniffiConverterTypeDescriptor.check_lower(descriptor)
        
        _UniffiConverterOptionalTypeDescriptor.check_lower(change_descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _UniffiConverterTypeDatabaseConfig.check_lower(database_config)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new,
        _UniffiConverterTypeDescriptor.lower(descriptor),
        _UniffiConverterOptionalTypeDescriptor.lower(change_descriptor),
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterTypeDatabaseConfig.lower(database_config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_wallet, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_wallet, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_address(self, address_index: "AddressIndex") -> "AddressInfo":
        _UniffiConverterTypeAddressIndex.check_lower(address_index)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddressIndex.lower(address_index))
        )





    def get_balance(self, ) -> "Balance":
        return _UniffiConverterTypeBalance.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance,self._uniffi_clone_pointer(),)
        )





    def get_internal_address(self, address_index: "AddressIndex") -> "AddressInfo":
        _UniffiConverterTypeAddressIndex.check_lower(address_index)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_internal_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddressIndex.lower(address_index))
        )





    def is_mine(self, script: "Script") -> "bool":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )





    def list_transactions(self, include_raw: "bool") -> "typing.List[TransactionDetails]":
        _UniffiConverterBool.check_lower(include_raw)
        
        return _UniffiConverterSequenceTypeTransactionDetails.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_transactions,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(include_raw))
        )





    def list_unspent(self, ) -> "typing.List[LocalUtxo]":
        return _UniffiConverterSequenceTypeLocalUtxo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent,self._uniffi_clone_pointer(),)
        )





    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_network,self._uniffi_clone_pointer(),)
        )





    def sign(self, psbt: "PartiallySignedTransaction",sign_options: "typing.Optional[SignOptions]") -> "bool":
        _UniffiConverterTypePartiallySignedTransaction.check_lower(psbt)
        
        _UniffiConverterOptionalTypeSignOptions.check_lower(sign_options)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign,self._uniffi_clone_pointer(),
        _UniffiConverterTypePartiallySignedTransaction.lower(psbt),
        _UniffiConverterOptionalTypeSignOptions.lower(sign_options))
        )





    def sync(self, blockchain: "Blockchain",progress: "typing.Optional[Progress]") -> None:
        _UniffiConverterTypeBlockchain.check_lower(blockchain)
        
        _UniffiConverterOptionalCallbackInterfaceProgress.check_lower(progress)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBdkError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_sync,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBlockchain.lower(blockchain),
        _UniffiConverterOptionalCallbackInterfaceProgress.lower(progress))







class _UniffiConverterTypeWallet:

    @staticmethod
    def lift(value: int):
        return Wallet._make_instance_(value)

    @staticmethod
    def check_lower(value: Wallet):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: WalletProtocol):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WalletProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AddressInfo:
    index: "int"
    address: "Address"
    keychain: "KeychainKind"
    def __init__(self, *, index: "int", address: "Address", keychain: "KeychainKind"):
        self.index = index
        self.address = address
        self.keychain = keychain

    def __str__(self):
        return "AddressInfo(index={}, address={}, keychain={})".format(self.index, self.address, self.keychain)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.address != other.address:
            return False
        if self.keychain != other.keychain:
            return False
        return True

class _UniffiConverterTypeAddressInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddressInfo(
            index=_UniffiConverterUInt32.read(buf),
            address=_UniffiConverterTypeAddress.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.index)
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.index, buf)
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)


class Balance:
    immature: "int"
    trusted_pending: "int"
    untrusted_pending: "int"
    confirmed: "int"
    spendable: "int"
    total: "int"
    def __init__(self, *, immature: "int", trusted_pending: "int", untrusted_pending: "int", confirmed: "int", spendable: "int", total: "int"):
        self.immature = immature
        self.trusted_pending = trusted_pending
        self.untrusted_pending = untrusted_pending
        self.confirmed = confirmed
        self.spendable = spendable
        self.total = total

    def __str__(self):
        return "Balance(immature={}, trusted_pending={}, untrusted_pending={}, confirmed={}, spendable={}, total={})".format(self.immature, self.trusted_pending, self.untrusted_pending, self.confirmed, self.spendable, self.total)

    def __eq__(self, other):
        if self.immature != other.immature:
            return False
        if self.trusted_pending != other.trusted_pending:
            return False
        if self.untrusted_pending != other.untrusted_pending:
            return False
        if self.confirmed != other.confirmed:
            return False
        if self.spendable != other.spendable:
            return False
        if self.total != other.total:
            return False
        return True

class _UniffiConverterTypeBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balance(
            immature=_UniffiConverterUInt64.read(buf),
            trusted_pending=_UniffiConverterUInt64.read(buf),
            untrusted_pending=_UniffiConverterUInt64.read(buf),
            confirmed=_UniffiConverterUInt64.read(buf),
            spendable=_UniffiConverterUInt64.read(buf),
            total=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.immature)
        _UniffiConverterUInt64.check_lower(value.trusted_pending)
        _UniffiConverterUInt64.check_lower(value.untrusted_pending)
        _UniffiConverterUInt64.check_lower(value.confirmed)
        _UniffiConverterUInt64.check_lower(value.spendable)
        _UniffiConverterUInt64.check_lower(value.total)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.immature, buf)
        _UniffiConverterUInt64.write(value.trusted_pending, buf)
        _UniffiConverterUInt64.write(value.untrusted_pending, buf)
        _UniffiConverterUInt64.write(value.confirmed, buf)
        _UniffiConverterUInt64.write(value.spendable, buf)
        _UniffiConverterUInt64.write(value.total, buf)


class BlockTime:
    height: "int"
    timestamp: "int"
    def __init__(self, *, height: "int", timestamp: "int"):
        self.height = height
        self.timestamp = timestamp

    def __str__(self):
        return "BlockTime(height={}, timestamp={})".format(self.height, self.timestamp)

    def __eq__(self, other):
        if self.height != other.height:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class _UniffiConverterTypeBlockTime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlockTime(
            height=_UniffiConverterUInt32.read(buf),
            timestamp=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.height)
        _UniffiConverterUInt64.check_lower(value.timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.height, buf)
        _UniffiConverterUInt64.write(value.timestamp, buf)


class ElectrumConfig:
    url: "str"
    socks5: "typing.Optional[str]"
    retry: "int"
    timeout: "typing.Optional[int]"
    stop_gap: "int"
    validate_domain: "bool"
    def __init__(self, *, url: "str", socks5: "typing.Optional[str]", retry: "int", timeout: "typing.Optional[int]", stop_gap: "int", validate_domain: "bool"):
        self.url = url
        self.socks5 = socks5
        self.retry = retry
        self.timeout = timeout
        self.stop_gap = stop_gap
        self.validate_domain = validate_domain

    def __str__(self):
        return "ElectrumConfig(url={}, socks5={}, retry={}, timeout={}, stop_gap={}, validate_domain={})".format(self.url, self.socks5, self.retry, self.timeout, self.stop_gap, self.validate_domain)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.socks5 != other.socks5:
            return False
        if self.retry != other.retry:
            return False
        if self.timeout != other.timeout:
            return False
        if self.stop_gap != other.stop_gap:
            return False
        if self.validate_domain != other.validate_domain:
            return False
        return True

class _UniffiConverterTypeElectrumConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ElectrumConfig(
            url=_UniffiConverterString.read(buf),
            socks5=_UniffiConverterOptionalString.read(buf),
            retry=_UniffiConverterUInt8.read(buf),
            timeout=_UniffiConverterOptionalUInt8.read(buf),
            stop_gap=_UniffiConverterUInt64.read(buf),
            validate_domain=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalString.check_lower(value.socks5)
        _UniffiConverterUInt8.check_lower(value.retry)
        _UniffiConverterOptionalUInt8.check_lower(value.timeout)
        _UniffiConverterUInt64.check_lower(value.stop_gap)
        _UniffiConverterBool.check_lower(value.validate_domain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalString.write(value.socks5, buf)
        _UniffiConverterUInt8.write(value.retry, buf)
        _UniffiConverterOptionalUInt8.write(value.timeout, buf)
        _UniffiConverterUInt64.write(value.stop_gap, buf)
        _UniffiConverterBool.write(value.validate_domain, buf)


class EsploraConfig:
    base_url: "str"
    proxy: "typing.Optional[str]"
    concurrency: "typing.Optional[int]"
    stop_gap: "int"
    timeout: "typing.Optional[int]"
    def __init__(self, *, base_url: "str", proxy: "typing.Optional[str]", concurrency: "typing.Optional[int]", stop_gap: "int", timeout: "typing.Optional[int]"):
        self.base_url = base_url
        self.proxy = proxy
        self.concurrency = concurrency
        self.stop_gap = stop_gap
        self.timeout = timeout

    def __str__(self):
        return "EsploraConfig(base_url={}, proxy={}, concurrency={}, stop_gap={}, timeout={})".format(self.base_url, self.proxy, self.concurrency, self.stop_gap, self.timeout)

    def __eq__(self, other):
        if self.base_url != other.base_url:
            return False
        if self.proxy != other.proxy:
            return False
        if self.concurrency != other.concurrency:
            return False
        if self.stop_gap != other.stop_gap:
            return False
        if self.timeout != other.timeout:
            return False
        return True

class _UniffiConverterTypeEsploraConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EsploraConfig(
            base_url=_UniffiConverterString.read(buf),
            proxy=_UniffiConverterOptionalString.read(buf),
            concurrency=_UniffiConverterOptionalUInt8.read(buf),
            stop_gap=_UniffiConverterUInt64.read(buf),
            timeout=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.base_url)
        _UniffiConverterOptionalString.check_lower(value.proxy)
        _UniffiConverterOptionalUInt8.check_lower(value.concurrency)
        _UniffiConverterUInt64.check_lower(value.stop_gap)
        _UniffiConverterOptionalUInt64.check_lower(value.timeout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.base_url, buf)
        _UniffiConverterOptionalString.write(value.proxy, buf)
        _UniffiConverterOptionalUInt8.write(value.concurrency, buf)
        _UniffiConverterUInt64.write(value.stop_gap, buf)
        _UniffiConverterOptionalUInt64.write(value.timeout, buf)


class LocalUtxo:
    outpoint: "OutPoint"
    txout: "TxOut"
    keychain: "KeychainKind"
    is_spent: "bool"
    def __init__(self, *, outpoint: "OutPoint", txout: "TxOut", keychain: "KeychainKind", is_spent: "bool"):
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.is_spent = is_spent

    def __str__(self):
        return "LocalUtxo(outpoint={}, txout={}, keychain={}, is_spent={})".format(self.outpoint, self.txout, self.keychain, self.is_spent)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.txout != other.txout:
            return False
        if self.keychain != other.keychain:
            return False
        if self.is_spent != other.is_spent:
            return False
        return True

class _UniffiConverterTypeLocalUtxo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalUtxo(
            outpoint=_UniffiConverterTypeOutPoint.read(buf),
            txout=_UniffiConverterTypeTxOut.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
            is_spent=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.outpoint)
        _UniffiConverterTypeTxOut.check_lower(value.txout)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)
        _UniffiConverterBool.check_lower(value.is_spent)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.outpoint, buf)
        _UniffiConverterTypeTxOut.write(value.txout, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)
        _UniffiConverterBool.write(value.is_spent, buf)


class OutPoint:
    txid: "str"
    vout: "int"
    def __init__(self, *, txid: "str", vout: "int"):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class _UniffiConverterTypeOutPoint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)


class RpcConfig:
    url: "str"
    auth: "Auth"
    network: "Network"
    wallet_name: "str"
    sync_params: "typing.Optional[RpcSyncParams]"
    def __init__(self, *, url: "str", auth: "Auth", network: "Network", wallet_name: "str", sync_params: "typing.Optional[RpcSyncParams]"):
        self.url = url
        self.auth = auth
        self.network = network
        self.wallet_name = wallet_name
        self.sync_params = sync_params

    def __str__(self):
        return "RpcConfig(url={}, auth={}, network={}, wallet_name={}, sync_params={})".format(self.url, self.auth, self.network, self.wallet_name, self.sync_params)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.auth != other.auth:
            return False
        if self.network != other.network:
            return False
        if self.wallet_name != other.wallet_name:
            return False
        if self.sync_params != other.sync_params:
            return False
        return True

class _UniffiConverterTypeRpcConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RpcConfig(
            url=_UniffiConverterString.read(buf),
            auth=_UniffiConverterTypeAuth.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            wallet_name=_UniffiConverterString.read(buf),
            sync_params=_UniffiConverterOptionalTypeRpcSyncParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterTypeAuth.check_lower(value.auth)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterString.check_lower(value.wallet_name)
        _UniffiConverterOptionalTypeRpcSyncParams.check_lower(value.sync_params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterTypeAuth.write(value.auth, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterString.write(value.wallet_name, buf)
        _UniffiConverterOptionalTypeRpcSyncParams.write(value.sync_params, buf)


class RpcSyncParams:
    start_script_count: "int"
    start_time: "int"
    force_start_time: "bool"
    poll_rate_sec: "int"
    def __init__(self, *, start_script_count: "int", start_time: "int", force_start_time: "bool", poll_rate_sec: "int"):
        self.start_script_count = start_script_count
        self.start_time = start_time
        self.force_start_time = force_start_time
        self.poll_rate_sec = poll_rate_sec

    def __str__(self):
        return "RpcSyncParams(start_script_count={}, start_time={}, force_start_time={}, poll_rate_sec={})".format(self.start_script_count, self.start_time, self.force_start_time, self.poll_rate_sec)

    def __eq__(self, other):
        if self.start_script_count != other.start_script_count:
            return False
        if self.start_time != other.start_time:
            return False
        if self.force_start_time != other.force_start_time:
            return False
        if self.poll_rate_sec != other.poll_rate_sec:
            return False
        return True

class _UniffiConverterTypeRpcSyncParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RpcSyncParams(
            start_script_count=_UniffiConverterUInt64.read(buf),
            start_time=_UniffiConverterUInt64.read(buf),
            force_start_time=_UniffiConverterBool.read(buf),
            poll_rate_sec=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.start_script_count)
        _UniffiConverterUInt64.check_lower(value.start_time)
        _UniffiConverterBool.check_lower(value.force_start_time)
        _UniffiConverterUInt64.check_lower(value.poll_rate_sec)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.start_script_count, buf)
        _UniffiConverterUInt64.write(value.start_time, buf)
        _UniffiConverterBool.write(value.force_start_time, buf)
        _UniffiConverterUInt64.write(value.poll_rate_sec, buf)


class ScriptAmount:
    script: "Script"
    amount: "int"
    def __init__(self, *, script: "Script", amount: "int"):
        self.script = script
        self.amount = amount

    def __str__(self):
        return "ScriptAmount(script={}, amount={})".format(self.script, self.amount)

    def __eq__(self, other):
        if self.script != other.script:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeScriptAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptAmount(
            script=_UniffiConverterTypeScript.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeScript.check_lower(value.script)
        _UniffiConverterUInt64.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeScript.write(value.script, buf)
        _UniffiConverterUInt64.write(value.amount, buf)


class SignOptions:
    trust_witness_utxo: "bool"
    assume_height: "typing.Optional[int]"
    allow_all_sighashes: "bool"
    remove_partial_sigs: "bool"
    try_finalize: "bool"
    sign_with_tap_internal_key: "bool"
    allow_grinding: "bool"
    def __init__(self, *, trust_witness_utxo: "bool", assume_height: "typing.Optional[int]", allow_all_sighashes: "bool", remove_partial_sigs: "bool", try_finalize: "bool", sign_with_tap_internal_key: "bool", allow_grinding: "bool"):
        self.trust_witness_utxo = trust_witness_utxo
        self.assume_height = assume_height
        self.allow_all_sighashes = allow_all_sighashes
        self.remove_partial_sigs = remove_partial_sigs
        self.try_finalize = try_finalize
        self.sign_with_tap_internal_key = sign_with_tap_internal_key
        self.allow_grinding = allow_grinding

    def __str__(self):
        return "SignOptions(trust_witness_utxo={}, assume_height={}, allow_all_sighashes={}, remove_partial_sigs={}, try_finalize={}, sign_with_tap_internal_key={}, allow_grinding={})".format(self.trust_witness_utxo, self.assume_height, self.allow_all_sighashes, self.remove_partial_sigs, self.try_finalize, self.sign_with_tap_internal_key, self.allow_grinding)

    def __eq__(self, other):
        if self.trust_witness_utxo != other.trust_witness_utxo:
            return False
        if self.assume_height != other.assume_height:
            return False
        if self.allow_all_sighashes != other.allow_all_sighashes:
            return False
        if self.remove_partial_sigs != other.remove_partial_sigs:
            return False
        if self.try_finalize != other.try_finalize:
            return False
        if self.sign_with_tap_internal_key != other.sign_with_tap_internal_key:
            return False
        if self.allow_grinding != other.allow_grinding:
            return False
        return True

class _UniffiConverterTypeSignOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignOptions(
            trust_witness_utxo=_UniffiConverterBool.read(buf),
            assume_height=_UniffiConverterOptionalUInt32.read(buf),
            allow_all_sighashes=_UniffiConverterBool.read(buf),
            remove_partial_sigs=_UniffiConverterBool.read(buf),
            try_finalize=_UniffiConverterBool.read(buf),
            sign_with_tap_internal_key=_UniffiConverterBool.read(buf),
            allow_grinding=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.trust_witness_utxo)
        _UniffiConverterOptionalUInt32.check_lower(value.assume_height)
        _UniffiConverterBool.check_lower(value.allow_all_sighashes)
        _UniffiConverterBool.check_lower(value.remove_partial_sigs)
        _UniffiConverterBool.check_lower(value.try_finalize)
        _UniffiConverterBool.check_lower(value.sign_with_tap_internal_key)
        _UniffiConverterBool.check_lower(value.allow_grinding)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.trust_witness_utxo, buf)
        _UniffiConverterOptionalUInt32.write(value.assume_height, buf)
        _UniffiConverterBool.write(value.allow_all_sighashes, buf)
        _UniffiConverterBool.write(value.remove_partial_sigs, buf)
        _UniffiConverterBool.write(value.try_finalize, buf)
        _UniffiConverterBool.write(value.sign_with_tap_internal_key, buf)
        _UniffiConverterBool.write(value.allow_grinding, buf)


class SledDbConfiguration:
    path: "str"
    tree_name: "str"
    def __init__(self, *, path: "str", tree_name: "str"):
        self.path = path
        self.tree_name = tree_name

    def __str__(self):
        return "SledDbConfiguration(path={}, tree_name={})".format(self.path, self.tree_name)

    def __eq__(self, other):
        if self.path != other.path:
            return False
        if self.tree_name != other.tree_name:
            return False
        return True

class _UniffiConverterTypeSledDbConfiguration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SledDbConfiguration(
            path=_UniffiConverterString.read(buf),
            tree_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.path)
        _UniffiConverterString.check_lower(value.tree_name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.path, buf)
        _UniffiConverterString.write(value.tree_name, buf)


class SqliteDbConfiguration:
    path: "str"
    def __init__(self, *, path: "str"):
        self.path = path

    def __str__(self):
        return "SqliteDbConfiguration(path={})".format(self.path)

    def __eq__(self, other):
        if self.path != other.path:
            return False
        return True

class _UniffiConverterTypeSqliteDbConfiguration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SqliteDbConfiguration(
            path=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.path)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.path, buf)


class TransactionDetails:
    transaction: "typing.Optional[Transaction]"
    fee: "typing.Optional[int]"
    received: "int"
    sent: "int"
    txid: "str"
    confirmation_time: "typing.Optional[BlockTime]"
    def __init__(self, *, transaction: "typing.Optional[Transaction]", fee: "typing.Optional[int]", received: "int", sent: "int", txid: "str", confirmation_time: "typing.Optional[BlockTime]"):
        self.transaction = transaction
        self.fee = fee
        self.received = received
        self.sent = sent
        self.txid = txid
        self.confirmation_time = confirmation_time

    def __str__(self):
        return "TransactionDetails(transaction={}, fee={}, received={}, sent={}, txid={}, confirmation_time={})".format(self.transaction, self.fee, self.received, self.sent, self.txid, self.confirmation_time)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.fee != other.fee:
            return False
        if self.received != other.received:
            return False
        if self.sent != other.sent:
            return False
        if self.txid != other.txid:
            return False
        if self.confirmation_time != other.confirmation_time:
            return False
        return True

class _UniffiConverterTypeTransactionDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionDetails(
            transaction=_UniffiConverterOptionalTypeTransaction.read(buf),
            fee=_UniffiConverterOptionalUInt64.read(buf),
            received=_UniffiConverterUInt64.read(buf),
            sent=_UniffiConverterUInt64.read(buf),
            txid=_UniffiConverterString.read(buf),
            confirmation_time=_UniffiConverterOptionalTypeBlockTime.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeTransaction.check_lower(value.transaction)
        _UniffiConverterOptionalUInt64.check_lower(value.fee)
        _UniffiConverterUInt64.check_lower(value.received)
        _UniffiConverterUInt64.check_lower(value.sent)
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterOptionalTypeBlockTime.check_lower(value.confirmation_time)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeTransaction.write(value.transaction, buf)
        _UniffiConverterOptionalUInt64.write(value.fee, buf)
        _UniffiConverterUInt64.write(value.received, buf)
        _UniffiConverterUInt64.write(value.sent, buf)
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterOptionalTypeBlockTime.write(value.confirmation_time, buf)


class TxBuilderResult:
    psbt: "PartiallySignedTransaction"
    transaction_details: "TransactionDetails"
    def __init__(self, *, psbt: "PartiallySignedTransaction", transaction_details: "TransactionDetails"):
        self.psbt = psbt
        self.transaction_details = transaction_details

    def __str__(self):
        return "TxBuilderResult(psbt={}, transaction_details={})".format(self.psbt, self.transaction_details)

    def __eq__(self, other):
        if self.psbt != other.psbt:
            return False
        if self.transaction_details != other.transaction_details:
            return False
        return True

class _UniffiConverterTypeTxBuilderResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxBuilderResult(
            psbt=_UniffiConverterTypePartiallySignedTransaction.read(buf),
            transaction_details=_UniffiConverterTypeTransactionDetails.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePartiallySignedTransaction.check_lower(value.psbt)
        _UniffiConverterTypeTransactionDetails.check_lower(value.transaction_details)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePartiallySignedTransaction.write(value.psbt, buf)
        _UniffiConverterTypeTransactionDetails.write(value.transaction_details, buf)


class TxIn:
    previous_output: "OutPoint"
    script_sig: "Script"
    sequence: "int"
    witness: "typing.List[typing.List[int]]"
    def __init__(self, *, previous_output: "OutPoint", script_sig: "Script", sequence: "int", witness: "typing.List[typing.List[int]]"):
        self.previous_output = previous_output
        self.script_sig = script_sig
        self.sequence = sequence
        self.witness = witness

    def __str__(self):
        return "TxIn(previous_output={}, script_sig={}, sequence={}, witness={})".format(self.previous_output, self.script_sig, self.sequence, self.witness)

    def __eq__(self, other):
        if self.previous_output != other.previous_output:
            return False
        if self.script_sig != other.script_sig:
            return False
        if self.sequence != other.sequence:
            return False
        if self.witness != other.witness:
            return False
        return True

class _UniffiConverterTypeTxIn(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxIn(
            previous_output=_UniffiConverterTypeOutPoint.read(buf),
            script_sig=_UniffiConverterTypeScript.read(buf),
            sequence=_UniffiConverterUInt32.read(buf),
            witness=_UniffiConverterSequenceSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.previous_output)
        _UniffiConverterTypeScript.check_lower(value.script_sig)
        _UniffiConverterUInt32.check_lower(value.sequence)
        _UniffiConverterSequenceSequenceUInt8.check_lower(value.witness)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.previous_output, buf)
        _UniffiConverterTypeScript.write(value.script_sig, buf)
        _UniffiConverterUInt32.write(value.sequence, buf)
        _UniffiConverterSequenceSequenceUInt8.write(value.witness, buf)


class TxOut:
    value: "int"
    script_pubkey: "Script"
    def __init__(self, *, value: "int", script_pubkey: "Script"):
        self.value = value
        self.script_pubkey = script_pubkey

    def __str__(self):
        return "TxOut(value={}, script_pubkey={})".format(self.value, self.script_pubkey)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.script_pubkey != other.script_pubkey:
            return False
        return True

class _UniffiConverterTypeTxOut(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxOut(
            value=_UniffiConverterUInt64.read(buf),
            script_pubkey=_UniffiConverterTypeScript.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.value)
        _UniffiConverterTypeScript.check_lower(value.script_pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.value, buf)
        _UniffiConverterTypeScript.write(value.script_pubkey, buf)





class AddressIndex:
    def __init__(self):
        raise RuntimeError("AddressIndex cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NEW:

        def __init__(self,):
            pass

        def __str__(self):
            return "AddressIndex.NEW()".format()

        def __eq__(self, other):
            if not other.is_new():
                return False
            return True
    
    class LAST_UNUSED:

        def __init__(self,):
            pass

        def __str__(self):
            return "AddressIndex.LAST_UNUSED()".format()

        def __eq__(self, other):
            if not other.is_last_unused():
                return False
            return True
    
    class PEEK:
        index: "int"

        def __init__(self,index: "int"):
            self.index = index

        def __str__(self):
            return "AddressIndex.PEEK(index={})".format(self.index)

        def __eq__(self, other):
            if not other.is_peek():
                return False
            if self.index != other.index:
                return False
            return True
    
    class RESET:
        index: "int"

        def __init__(self,index: "int"):
            self.index = index

        def __str__(self):
            return "AddressIndex.RESET(index={})".format(self.index)

        def __eq__(self, other):
            if not other.is_reset():
                return False
            if self.index != other.index:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_new(self) -> bool:
        return isinstance(self, AddressIndex.NEW)
    def is_last_unused(self) -> bool:
        return isinstance(self, AddressIndex.LAST_UNUSED)
    def is_peek(self) -> bool:
        return isinstance(self, AddressIndex.PEEK)
    def is_reset(self) -> bool:
        return isinstance(self, AddressIndex.RESET)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AddressIndex.NEW = type("AddressIndex.NEW", (AddressIndex.NEW, AddressIndex,), {})  # type: ignore
AddressIndex.LAST_UNUSED = type("AddressIndex.LAST_UNUSED", (AddressIndex.LAST_UNUSED, AddressIndex,), {})  # type: ignore
AddressIndex.PEEK = type("AddressIndex.PEEK", (AddressIndex.PEEK, AddressIndex,), {})  # type: ignore
AddressIndex.RESET = type("AddressIndex.RESET", (AddressIndex.RESET, AddressIndex,), {})  # type: ignore




class _UniffiConverterTypeAddressIndex(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddressIndex.NEW(
            )
        if variant == 2:
            return AddressIndex.LAST_UNUSED(
            )
        if variant == 3:
            return AddressIndex.PEEK(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 4:
            return AddressIndex.RESET(
                _UniffiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_new():
            return
        if value.is_last_unused():
            return
        if value.is_peek():
            _UniffiConverterUInt32.check_lower(value.index)
            return
        if value.is_reset():
            _UniffiConverterUInt32.check_lower(value.index)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_new():
            buf.write_i32(1)
        if value.is_last_unused():
            buf.write_i32(2)
        if value.is_peek():
            buf.write_i32(3)
            _UniffiConverterUInt32.write(value.index, buf)
        if value.is_reset():
            buf.write_i32(4)
            _UniffiConverterUInt32.write(value.index, buf)







class Auth:
    def __init__(self):
        raise RuntimeError("Auth cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:

        def __init__(self,):
            pass

        def __str__(self):
            return "Auth.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    class USER_PASS:
        username: "str"
        password: "str"

        def __init__(self,username: "str", password: "str"):
            self.username = username
            self.password = password

        def __str__(self):
            return "Auth.USER_PASS(username={}, password={})".format(self.username, self.password)

        def __eq__(self, other):
            if not other.is_user_pass():
                return False
            if self.username != other.username:
                return False
            if self.password != other.password:
                return False
            return True
    
    class COOKIE:
        file: "str"

        def __init__(self,file: "str"):
            self.file = file

        def __str__(self):
            return "Auth.COOKIE(file={})".format(self.file)

        def __eq__(self, other):
            if not other.is_cookie():
                return False
            if self.file != other.file:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_none(self) -> bool:
        return isinstance(self, Auth.NONE)
    def is_user_pass(self) -> bool:
        return isinstance(self, Auth.USER_PASS)
    def is_cookie(self) -> bool:
        return isinstance(self, Auth.COOKIE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Auth.NONE = type("Auth.NONE", (Auth.NONE, Auth,), {})  # type: ignore
Auth.USER_PASS = type("Auth.USER_PASS", (Auth.USER_PASS, Auth,), {})  # type: ignore
Auth.COOKIE = type("Auth.COOKIE", (Auth.COOKIE, Auth,), {})  # type: ignore




class _UniffiConverterTypeAuth(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Auth.NONE(
            )
        if variant == 2:
            return Auth.USER_PASS(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Auth.COOKIE(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_none():
            return
        if value.is_user_pass():
            _UniffiConverterString.check_lower(value.username)
            _UniffiConverterString.check_lower(value.password)
            return
        if value.is_cookie():
            _UniffiConverterString.check_lower(value.file)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_none():
            buf.write_i32(1)
        if value.is_user_pass():
            buf.write_i32(2)
            _UniffiConverterString.write(value.username, buf)
            _UniffiConverterString.write(value.password, buf)
        if value.is_cookie():
            buf.write_i32(3)
            _UniffiConverterString.write(value.file, buf)




# BdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class BdkError(Exception):
    pass

_UniffiTempBdkError = BdkError

class BdkError:  # type: ignore
    class InvalidU32Bytes(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InvalidU32Bytes({})".format(repr(str(self)))
    _UniffiTempBdkError.InvalidU32Bytes = InvalidU32Bytes # type: ignore
    class Generic(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Generic({})".format(repr(str(self)))
    _UniffiTempBdkError.Generic = Generic # type: ignore
    class MissingCachedScripts(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.MissingCachedScripts({})".format(repr(str(self)))
    _UniffiTempBdkError.MissingCachedScripts = MissingCachedScripts # type: ignore
    class ScriptDoesntHaveAddressForm(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.ScriptDoesntHaveAddressForm({})".format(repr(str(self)))
    _UniffiTempBdkError.ScriptDoesntHaveAddressForm = ScriptDoesntHaveAddressForm # type: ignore
    class NoRecipients(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.NoRecipients({})".format(repr(str(self)))
    _UniffiTempBdkError.NoRecipients = NoRecipients # type: ignore
    class NoUtxosSelected(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.NoUtxosSelected({})".format(repr(str(self)))
    _UniffiTempBdkError.NoUtxosSelected = NoUtxosSelected # type: ignore
    class OutputBelowDustLimit(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.OutputBelowDustLimit({})".format(repr(str(self)))
    _UniffiTempBdkError.OutputBelowDustLimit = OutputBelowDustLimit # type: ignore
    class InsufficientFunds(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InsufficientFunds({})".format(repr(str(self)))
    _UniffiTempBdkError.InsufficientFunds = InsufficientFunds # type: ignore
    class BnBTotalTriesExceeded(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.BnBTotalTriesExceeded({})".format(repr(str(self)))
    _UniffiTempBdkError.BnBTotalTriesExceeded = BnBTotalTriesExceeded # type: ignore
    class BnBNoExactMatch(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.BnBNoExactMatch({})".format(repr(str(self)))
    _UniffiTempBdkError.BnBNoExactMatch = BnBNoExactMatch # type: ignore
    class UnknownUtxo(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.UnknownUtxo({})".format(repr(str(self)))
    _UniffiTempBdkError.UnknownUtxo = UnknownUtxo # type: ignore
    class TransactionNotFound(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.TransactionNotFound({})".format(repr(str(self)))
    _UniffiTempBdkError.TransactionNotFound = TransactionNotFound # type: ignore
    class TransactionConfirmed(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.TransactionConfirmed({})".format(repr(str(self)))
    _UniffiTempBdkError.TransactionConfirmed = TransactionConfirmed # type: ignore
    class IrreplaceableTransaction(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.IrreplaceableTransaction({})".format(repr(str(self)))
    _UniffiTempBdkError.IrreplaceableTransaction = IrreplaceableTransaction # type: ignore
    class FeeRateTooLow(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.FeeRateTooLow({})".format(repr(str(self)))
    _UniffiTempBdkError.FeeRateTooLow = FeeRateTooLow # type: ignore
    class FeeTooLow(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.FeeTooLow({})".format(repr(str(self)))
    _UniffiTempBdkError.FeeTooLow = FeeTooLow # type: ignore
    class FeeRateUnavailable(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.FeeRateUnavailable({})".format(repr(str(self)))
    _UniffiTempBdkError.FeeRateUnavailable = FeeRateUnavailable # type: ignore
    class MissingKeyOrigin(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.MissingKeyOrigin({})".format(repr(str(self)))
    _UniffiTempBdkError.MissingKeyOrigin = MissingKeyOrigin # type: ignore
    class Key(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Key({})".format(repr(str(self)))
    _UniffiTempBdkError.Key = Key # type: ignore
    class ChecksumMismatch(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.ChecksumMismatch({})".format(repr(str(self)))
    _UniffiTempBdkError.ChecksumMismatch = ChecksumMismatch # type: ignore
    class SpendingPolicyRequired(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.SpendingPolicyRequired({})".format(repr(str(self)))
    _UniffiTempBdkError.SpendingPolicyRequired = SpendingPolicyRequired # type: ignore
    class InvalidPolicyPathError(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InvalidPolicyPathError({})".format(repr(str(self)))
    _UniffiTempBdkError.InvalidPolicyPathError = InvalidPolicyPathError # type: ignore
    class Signer(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Signer({})".format(repr(str(self)))
    _UniffiTempBdkError.Signer = Signer # type: ignore
    class InvalidNetwork(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InvalidNetwork({})".format(repr(str(self)))
    _UniffiTempBdkError.InvalidNetwork = InvalidNetwork # type: ignore
    class InvalidProgressValue(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InvalidProgressValue({})".format(repr(str(self)))
    _UniffiTempBdkError.InvalidProgressValue = InvalidProgressValue # type: ignore
    class ProgressUpdateError(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.ProgressUpdateError({})".format(repr(str(self)))
    _UniffiTempBdkError.ProgressUpdateError = ProgressUpdateError # type: ignore
    class InvalidOutpoint(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.InvalidOutpoint({})".format(repr(str(self)))
    _UniffiTempBdkError.InvalidOutpoint = InvalidOutpoint # type: ignore
    class Descriptor(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Descriptor({})".format(repr(str(self)))
    _UniffiTempBdkError.Descriptor = Descriptor # type: ignore
    class Encode(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Encode({})".format(repr(str(self)))
    _UniffiTempBdkError.Encode = Encode # type: ignore
    class Miniscript(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Miniscript({})".format(repr(str(self)))
    _UniffiTempBdkError.Miniscript = Miniscript # type: ignore
    class MiniscriptPsbt(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.MiniscriptPsbt({})".format(repr(str(self)))
    _UniffiTempBdkError.MiniscriptPsbt = MiniscriptPsbt # type: ignore
    class Bip32(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Bip32({})".format(repr(str(self)))
    _UniffiTempBdkError.Bip32 = Bip32 # type: ignore
    class Secp256k1(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Secp256k1({})".format(repr(str(self)))
    _UniffiTempBdkError.Secp256k1 = Secp256k1 # type: ignore
    class Json(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Json({})".format(repr(str(self)))
    _UniffiTempBdkError.Json = Json # type: ignore
    class Hex(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Hex({})".format(repr(str(self)))
    _UniffiTempBdkError.Hex = Hex # type: ignore
    class Psbt(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Psbt({})".format(repr(str(self)))
    _UniffiTempBdkError.Psbt = Psbt # type: ignore
    class PsbtParse(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.PsbtParse({})".format(repr(str(self)))
    _UniffiTempBdkError.PsbtParse = PsbtParse # type: ignore
    class Electrum(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Electrum({})".format(repr(str(self)))
    _UniffiTempBdkError.Electrum = Electrum # type: ignore
    class Esplora(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Esplora({})".format(repr(str(self)))
    _UniffiTempBdkError.Esplora = Esplora # type: ignore
    class Sled(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Sled({})".format(repr(str(self)))
    _UniffiTempBdkError.Sled = Sled # type: ignore
    class Rusqlite(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Rusqlite({})".format(repr(str(self)))
    _UniffiTempBdkError.Rusqlite = Rusqlite # type: ignore
    class Rpc(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.Rpc({})".format(repr(str(self)))
    _UniffiTempBdkError.Rpc = Rpc # type: ignore
    class HardenedIndex(_UniffiTempBdkError):

        def __repr__(self):
            return "BdkError.HardenedIndex({})".format(repr(str(self)))
    _UniffiTempBdkError.HardenedIndex = HardenedIndex # type: ignore

BdkError = _UniffiTempBdkError # type: ignore
del _UniffiTempBdkError


class _UniffiConverterTypeBdkError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BdkError.InvalidU32Bytes(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return BdkError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return BdkError.MissingCachedScripts(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return BdkError.ScriptDoesntHaveAddressForm(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return BdkError.NoRecipients(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return BdkError.NoUtxosSelected(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return BdkError.OutputBelowDustLimit(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return BdkError.InsufficientFunds(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return BdkError.BnBTotalTriesExceeded(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return BdkError.BnBNoExactMatch(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return BdkError.UnknownUtxo(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return BdkError.TransactionNotFound(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return BdkError.TransactionConfirmed(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return BdkError.IrreplaceableTransaction(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return BdkError.FeeRateTooLow(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return BdkError.FeeTooLow(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return BdkError.FeeRateUnavailable(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return BdkError.MissingKeyOrigin(
                _UniffiConverterString.read(buf),
            )
        if variant == 19:
            return BdkError.Key(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return BdkError.ChecksumMismatch(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return BdkError.SpendingPolicyRequired(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return BdkError.InvalidPolicyPathError(
                _UniffiConverterString.read(buf),
            )
        if variant == 23:
            return BdkError.Signer(
                _UniffiConverterString.read(buf),
            )
        if variant == 24:
            return BdkError.InvalidNetwork(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return BdkError.InvalidProgressValue(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return BdkError.ProgressUpdateError(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return BdkError.InvalidOutpoint(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return BdkError.Descriptor(
                _UniffiConverterString.read(buf),
            )
        if variant == 29:
            return BdkError.Encode(
                _UniffiConverterString.read(buf),
            )
        if variant == 30:
            return BdkError.Miniscript(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return BdkError.MiniscriptPsbt(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return BdkError.Bip32(
                _UniffiConverterString.read(buf),
            )
        if variant == 33:
            return BdkError.Secp256k1(
                _UniffiConverterString.read(buf),
            )
        if variant == 34:
            return BdkError.Json(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return BdkError.Hex(
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return BdkError.Psbt(
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return BdkError.PsbtParse(
                _UniffiConverterString.read(buf),
            )
        if variant == 38:
            return BdkError.Electrum(
                _UniffiConverterString.read(buf),
            )
        if variant == 39:
            return BdkError.Esplora(
                _UniffiConverterString.read(buf),
            )
        if variant == 40:
            return BdkError.Sled(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return BdkError.Rusqlite(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return BdkError.Rpc(
                _UniffiConverterString.read(buf),
            )
        if variant == 43:
            return BdkError.HardenedIndex(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, BdkError.InvalidU32Bytes):
            return
        if isinstance(value, BdkError.Generic):
            return
        if isinstance(value, BdkError.MissingCachedScripts):
            return
        if isinstance(value, BdkError.ScriptDoesntHaveAddressForm):
            return
        if isinstance(value, BdkError.NoRecipients):
            return
        if isinstance(value, BdkError.NoUtxosSelected):
            return
        if isinstance(value, BdkError.OutputBelowDustLimit):
            return
        if isinstance(value, BdkError.InsufficientFunds):
            return
        if isinstance(value, BdkError.BnBTotalTriesExceeded):
            return
        if isinstance(value, BdkError.BnBNoExactMatch):
            return
        if isinstance(value, BdkError.UnknownUtxo):
            return
        if isinstance(value, BdkError.TransactionNotFound):
            return
        if isinstance(value, BdkError.TransactionConfirmed):
            return
        if isinstance(value, BdkError.IrreplaceableTransaction):
            return
        if isinstance(value, BdkError.FeeRateTooLow):
            return
        if isinstance(value, BdkError.FeeTooLow):
            return
        if isinstance(value, BdkError.FeeRateUnavailable):
            return
        if isinstance(value, BdkError.MissingKeyOrigin):
            return
        if isinstance(value, BdkError.Key):
            return
        if isinstance(value, BdkError.ChecksumMismatch):
            return
        if isinstance(value, BdkError.SpendingPolicyRequired):
            return
        if isinstance(value, BdkError.InvalidPolicyPathError):
            return
        if isinstance(value, BdkError.Signer):
            return
        if isinstance(value, BdkError.InvalidNetwork):
            return
        if isinstance(value, BdkError.InvalidProgressValue):
            return
        if isinstance(value, BdkError.ProgressUpdateError):
            return
        if isinstance(value, BdkError.InvalidOutpoint):
            return
        if isinstance(value, BdkError.Descriptor):
            return
        if isinstance(value, BdkError.Encode):
            return
        if isinstance(value, BdkError.Miniscript):
            return
        if isinstance(value, BdkError.MiniscriptPsbt):
            return
        if isinstance(value, BdkError.Bip32):
            return
        if isinstance(value, BdkError.Secp256k1):
            return
        if isinstance(value, BdkError.Json):
            return
        if isinstance(value, BdkError.Hex):
            return
        if isinstance(value, BdkError.Psbt):
            return
        if isinstance(value, BdkError.PsbtParse):
            return
        if isinstance(value, BdkError.Electrum):
            return
        if isinstance(value, BdkError.Esplora):
            return
        if isinstance(value, BdkError.Sled):
            return
        if isinstance(value, BdkError.Rusqlite):
            return
        if isinstance(value, BdkError.Rpc):
            return
        if isinstance(value, BdkError.HardenedIndex):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, BdkError.InvalidU32Bytes):
            buf.write_i32(1)
        if isinstance(value, BdkError.Generic):
            buf.write_i32(2)
        if isinstance(value, BdkError.MissingCachedScripts):
            buf.write_i32(3)
        if isinstance(value, BdkError.ScriptDoesntHaveAddressForm):
            buf.write_i32(4)
        if isinstance(value, BdkError.NoRecipients):
            buf.write_i32(5)
        if isinstance(value, BdkError.NoUtxosSelected):
            buf.write_i32(6)
        if isinstance(value, BdkError.OutputBelowDustLimit):
            buf.write_i32(7)
        if isinstance(value, BdkError.InsufficientFunds):
            buf.write_i32(8)
        if isinstance(value, BdkError.BnBTotalTriesExceeded):
            buf.write_i32(9)
        if isinstance(value, BdkError.BnBNoExactMatch):
            buf.write_i32(10)
        if isinstance(value, BdkError.UnknownUtxo):
            buf.write_i32(11)
        if isinstance(value, BdkError.TransactionNotFound):
            buf.write_i32(12)
        if isinstance(value, BdkError.TransactionConfirmed):
            buf.write_i32(13)
        if isinstance(value, BdkError.IrreplaceableTransaction):
            buf.write_i32(14)
        if isinstance(value, BdkError.FeeRateTooLow):
            buf.write_i32(15)
        if isinstance(value, BdkError.FeeTooLow):
            buf.write_i32(16)
        if isinstance(value, BdkError.FeeRateUnavailable):
            buf.write_i32(17)
        if isinstance(value, BdkError.MissingKeyOrigin):
            buf.write_i32(18)
        if isinstance(value, BdkError.Key):
            buf.write_i32(19)
        if isinstance(value, BdkError.ChecksumMismatch):
            buf.write_i32(20)
        if isinstance(value, BdkError.SpendingPolicyRequired):
            buf.write_i32(21)
        if isinstance(value, BdkError.InvalidPolicyPathError):
            buf.write_i32(22)
        if isinstance(value, BdkError.Signer):
            buf.write_i32(23)
        if isinstance(value, BdkError.InvalidNetwork):
            buf.write_i32(24)
        if isinstance(value, BdkError.InvalidProgressValue):
            buf.write_i32(25)
        if isinstance(value, BdkError.ProgressUpdateError):
            buf.write_i32(26)
        if isinstance(value, BdkError.InvalidOutpoint):
            buf.write_i32(27)
        if isinstance(value, BdkError.Descriptor):
            buf.write_i32(28)
        if isinstance(value, BdkError.Encode):
            buf.write_i32(29)
        if isinstance(value, BdkError.Miniscript):
            buf.write_i32(30)
        if isinstance(value, BdkError.MiniscriptPsbt):
            buf.write_i32(31)
        if isinstance(value, BdkError.Bip32):
            buf.write_i32(32)
        if isinstance(value, BdkError.Secp256k1):
            buf.write_i32(33)
        if isinstance(value, BdkError.Json):
            buf.write_i32(34)
        if isinstance(value, BdkError.Hex):
            buf.write_i32(35)
        if isinstance(value, BdkError.Psbt):
            buf.write_i32(36)
        if isinstance(value, BdkError.PsbtParse):
            buf.write_i32(37)
        if isinstance(value, BdkError.Electrum):
            buf.write_i32(38)
        if isinstance(value, BdkError.Esplora):
            buf.write_i32(39)
        if isinstance(value, BdkError.Sled):
            buf.write_i32(40)
        if isinstance(value, BdkError.Rusqlite):
            buf.write_i32(41)
        if isinstance(value, BdkError.Rpc):
            buf.write_i32(42)
        if isinstance(value, BdkError.HardenedIndex):
            buf.write_i32(43)





class BlockchainConfig:
    def __init__(self):
        raise RuntimeError("BlockchainConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ELECTRUM:
        config: "ElectrumConfig"

        def __init__(self,config: "ElectrumConfig"):
            self.config = config

        def __str__(self):
            return "BlockchainConfig.ELECTRUM(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_electrum():
                return False
            if self.config != other.config:
                return False
            return True
    
    class ESPLORA:
        config: "EsploraConfig"

        def __init__(self,config: "EsploraConfig"):
            self.config = config

        def __str__(self):
            return "BlockchainConfig.ESPLORA(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_esplora():
                return False
            if self.config != other.config:
                return False
            return True
    
    class RPC:
        config: "RpcConfig"

        def __init__(self,config: "RpcConfig"):
            self.config = config

        def __str__(self):
            return "BlockchainConfig.RPC(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_rpc():
                return False
            if self.config != other.config:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_electrum(self) -> bool:
        return isinstance(self, BlockchainConfig.ELECTRUM)
    def is_esplora(self) -> bool:
        return isinstance(self, BlockchainConfig.ESPLORA)
    def is_rpc(self) -> bool:
        return isinstance(self, BlockchainConfig.RPC)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
BlockchainConfig.ELECTRUM = type("BlockchainConfig.ELECTRUM", (BlockchainConfig.ELECTRUM, BlockchainConfig,), {})  # type: ignore
BlockchainConfig.ESPLORA = type("BlockchainConfig.ESPLORA", (BlockchainConfig.ESPLORA, BlockchainConfig,), {})  # type: ignore
BlockchainConfig.RPC = type("BlockchainConfig.RPC", (BlockchainConfig.RPC, BlockchainConfig,), {})  # type: ignore




class _UniffiConverterTypeBlockchainConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlockchainConfig.ELECTRUM(
                _UniffiConverterTypeElectrumConfig.read(buf),
            )
        if variant == 2:
            return BlockchainConfig.ESPLORA(
                _UniffiConverterTypeEsploraConfig.read(buf),
            )
        if variant == 3:
            return BlockchainConfig.RPC(
                _UniffiConverterTypeRpcConfig.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_electrum():
            _UniffiConverterTypeElectrumConfig.check_lower(value.config)
            return
        if value.is_esplora():
            _UniffiConverterTypeEsploraConfig.check_lower(value.config)
            return
        if value.is_rpc():
            _UniffiConverterTypeRpcConfig.check_lower(value.config)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_electrum():
            buf.write_i32(1)
            _UniffiConverterTypeElectrumConfig.write(value.config, buf)
        if value.is_esplora():
            buf.write_i32(2)
            _UniffiConverterTypeEsploraConfig.write(value.config, buf)
        if value.is_rpc():
            buf.write_i32(3)
            _UniffiConverterTypeRpcConfig.write(value.config, buf)







class DatabaseConfig:
    def __init__(self):
        raise RuntimeError("DatabaseConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MEMORY:

        def __init__(self,):
            pass

        def __str__(self):
            return "DatabaseConfig.MEMORY()".format()

        def __eq__(self, other):
            if not other.is_memory():
                return False
            return True
    
    class SLED:
        config: "SledDbConfiguration"

        def __init__(self,config: "SledDbConfiguration"):
            self.config = config

        def __str__(self):
            return "DatabaseConfig.SLED(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_sled():
                return False
            if self.config != other.config:
                return False
            return True
    
    class SQLITE:
        config: "SqliteDbConfiguration"

        def __init__(self,config: "SqliteDbConfiguration"):
            self.config = config

        def __str__(self):
            return "DatabaseConfig.SQLITE(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_sqlite():
                return False
            if self.config != other.config:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_memory(self) -> bool:
        return isinstance(self, DatabaseConfig.MEMORY)
    def is_sled(self) -> bool:
        return isinstance(self, DatabaseConfig.SLED)
    def is_sqlite(self) -> bool:
        return isinstance(self, DatabaseConfig.SQLITE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DatabaseConfig.MEMORY = type("DatabaseConfig.MEMORY", (DatabaseConfig.MEMORY, DatabaseConfig,), {})  # type: ignore
DatabaseConfig.SLED = type("DatabaseConfig.SLED", (DatabaseConfig.SLED, DatabaseConfig,), {})  # type: ignore
DatabaseConfig.SQLITE = type("DatabaseConfig.SQLITE", (DatabaseConfig.SQLITE, DatabaseConfig,), {})  # type: ignore




class _UniffiConverterTypeDatabaseConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DatabaseConfig.MEMORY(
            )
        if variant == 2:
            return DatabaseConfig.SLED(
                _UniffiConverterTypeSledDbConfiguration.read(buf),
            )
        if variant == 3:
            return DatabaseConfig.SQLITE(
                _UniffiConverterTypeSqliteDbConfiguration.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_memory():
            return
        if value.is_sled():
            _UniffiConverterTypeSledDbConfiguration.check_lower(value.config)
            return
        if value.is_sqlite():
            _UniffiConverterTypeSqliteDbConfiguration.check_lower(value.config)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_memory():
            buf.write_i32(1)
        if value.is_sled():
            buf.write_i32(2)
            _UniffiConverterTypeSledDbConfiguration.write(value.config, buf)
        if value.is_sqlite():
            buf.write_i32(3)
            _UniffiConverterTypeSqliteDbConfiguration.write(value.config, buf)







class KeychainKind(enum.Enum):
    EXTERNAL = 0
    
    INTERNAL = 1
    


class _UniffiConverterTypeKeychainKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeychainKind.EXTERNAL
        if variant == 2:
            return KeychainKind.INTERNAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeychainKind.EXTERNAL:
            return
        if value == KeychainKind.INTERNAL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KeychainKind.EXTERNAL:
            buf.write_i32(1)
        if value == KeychainKind.INTERNAL:
            buf.write_i32(2)







class Network(enum.Enum):
    BITCOIN = 0
    
    TESTNET = 1
    
    SIGNET = 2
    
    REGTEST = 3
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.BITCOIN:
            return
        if value == Network.TESTNET:
            return
        if value == Network.SIGNET:
            return
        if value == Network.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Network.BITCOIN:
            buf.write_i32(1)
        if value == Network.TESTNET:
            buf.write_i32(2)
        if value == Network.SIGNET:
            buf.write_i32(3)
        if value == Network.REGTEST:
            buf.write_i32(4)







class Payload:
    def __init__(self):
        raise RuntimeError("Payload cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PUBKEY_HASH:
        pubkey_hash: "str"

        def __init__(self,pubkey_hash: "str"):
            self.pubkey_hash = pubkey_hash

        def __str__(self):
            return "Payload.PUBKEY_HASH(pubkey_hash={})".format(self.pubkey_hash)

        def __eq__(self, other):
            if not other.is_pubkey_hash():
                return False
            if self.pubkey_hash != other.pubkey_hash:
                return False
            return True
    
    class SCRIPT_HASH:
        script_hash: "str"

        def __init__(self,script_hash: "str"):
            self.script_hash = script_hash

        def __str__(self):
            return "Payload.SCRIPT_HASH(script_hash={})".format(self.script_hash)

        def __eq__(self, other):
            if not other.is_script_hash():
                return False
            if self.script_hash != other.script_hash:
                return False
            return True
    
    class WITNESS_PROGRAM:
        version: "WitnessVersion"
        program: "typing.List[int]"

        def __init__(self,version: "WitnessVersion", program: "typing.List[int]"):
            self.version = version
            self.program = program

        def __str__(self):
            return "Payload.WITNESS_PROGRAM(version={}, program={})".format(self.version, self.program)

        def __eq__(self, other):
            if not other.is_witness_program():
                return False
            if self.version != other.version:
                return False
            if self.program != other.program:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pubkey_hash(self) -> bool:
        return isinstance(self, Payload.PUBKEY_HASH)
    def is_script_hash(self) -> bool:
        return isinstance(self, Payload.SCRIPT_HASH)
    def is_witness_program(self) -> bool:
        return isinstance(self, Payload.WITNESS_PROGRAM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Payload.PUBKEY_HASH = type("Payload.PUBKEY_HASH", (Payload.PUBKEY_HASH, Payload,), {})  # type: ignore
Payload.SCRIPT_HASH = type("Payload.SCRIPT_HASH", (Payload.SCRIPT_HASH, Payload,), {})  # type: ignore
Payload.WITNESS_PROGRAM = type("Payload.WITNESS_PROGRAM", (Payload.WITNESS_PROGRAM, Payload,), {})  # type: ignore




class _UniffiConverterTypePayload(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Payload.PUBKEY_HASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Payload.SCRIPT_HASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Payload.WITNESS_PROGRAM(
                _UniffiConverterTypeWitnessVersion.read(buf),
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pubkey_hash():
            _UniffiConverterString.check_lower(value.pubkey_hash)
            return
        if value.is_script_hash():
            _UniffiConverterString.check_lower(value.script_hash)
            return
        if value.is_witness_program():
            _UniffiConverterTypeWitnessVersion.check_lower(value.version)
            _UniffiConverterSequenceUInt8.check_lower(value.program)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_pubkey_hash():
            buf.write_i32(1)
            _UniffiConverterString.write(value.pubkey_hash, buf)
        if value.is_script_hash():
            buf.write_i32(2)
            _UniffiConverterString.write(value.script_hash, buf)
        if value.is_witness_program():
            buf.write_i32(3)
            _UniffiConverterTypeWitnessVersion.write(value.version, buf)
            _UniffiConverterSequenceUInt8.write(value.program, buf)







class WitnessVersion(enum.Enum):
    V0 = 0
    
    V1 = 1
    
    V2 = 2
    
    V3 = 3
    
    V4 = 4
    
    V5 = 5
    
    V6 = 6
    
    V7 = 7
    
    V8 = 8
    
    V9 = 9
    
    V10 = 10
    
    V11 = 11
    
    V12 = 12
    
    V13 = 13
    
    V14 = 14
    
    V15 = 15
    
    V16 = 16
    


class _UniffiConverterTypeWitnessVersion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WitnessVersion.V0
        if variant == 2:
            return WitnessVersion.V1
        if variant == 3:
            return WitnessVersion.V2
        if variant == 4:
            return WitnessVersion.V3
        if variant == 5:
            return WitnessVersion.V4
        if variant == 6:
            return WitnessVersion.V5
        if variant == 7:
            return WitnessVersion.V6
        if variant == 8:
            return WitnessVersion.V7
        if variant == 9:
            return WitnessVersion.V8
        if variant == 10:
            return WitnessVersion.V9
        if variant == 11:
            return WitnessVersion.V10
        if variant == 12:
            return WitnessVersion.V11
        if variant == 13:
            return WitnessVersion.V12
        if variant == 14:
            return WitnessVersion.V13
        if variant == 15:
            return WitnessVersion.V14
        if variant == 16:
            return WitnessVersion.V15
        if variant == 17:
            return WitnessVersion.V16
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WitnessVersion.V0:
            return
        if value == WitnessVersion.V1:
            return
        if value == WitnessVersion.V2:
            return
        if value == WitnessVersion.V3:
            return
        if value == WitnessVersion.V4:
            return
        if value == WitnessVersion.V5:
            return
        if value == WitnessVersion.V6:
            return
        if value == WitnessVersion.V7:
            return
        if value == WitnessVersion.V8:
            return
        if value == WitnessVersion.V9:
            return
        if value == WitnessVersion.V10:
            return
        if value == WitnessVersion.V11:
            return
        if value == WitnessVersion.V12:
            return
        if value == WitnessVersion.V13:
            return
        if value == WitnessVersion.V14:
            return
        if value == WitnessVersion.V15:
            return
        if value == WitnessVersion.V16:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == WitnessVersion.V0:
            buf.write_i32(1)
        if value == WitnessVersion.V1:
            buf.write_i32(2)
        if value == WitnessVersion.V2:
            buf.write_i32(3)
        if value == WitnessVersion.V3:
            buf.write_i32(4)
        if value == WitnessVersion.V4:
            buf.write_i32(5)
        if value == WitnessVersion.V5:
            buf.write_i32(6)
        if value == WitnessVersion.V6:
            buf.write_i32(7)
        if value == WitnessVersion.V7:
            buf.write_i32(8)
        if value == WitnessVersion.V8:
            buf.write_i32(9)
        if value == WitnessVersion.V9:
            buf.write_i32(10)
        if value == WitnessVersion.V10:
            buf.write_i32(11)
        if value == WitnessVersion.V11:
            buf.write_i32(12)
        if value == WitnessVersion.V12:
            buf.write_i32(13)
        if value == WitnessVersion.V13:
            buf.write_i32(14)
        if value == WitnessVersion.V14:
            buf.write_i32(15)
        if value == WitnessVersion.V15:
            buf.write_i32(16)
        if value == WitnessVersion.V16:
            buf.write_i32(17)







class WordCount(enum.Enum):
    WORDS12 = 0
    
    WORDS15 = 1
    
    WORDS18 = 2
    
    WORDS21 = 3
    
    WORDS24 = 4
    


class _UniffiConverterTypeWordCount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WordCount.WORDS12
        if variant == 2:
            return WordCount.WORDS15
        if variant == 3:
            return WordCount.WORDS18
        if variant == 4:
            return WordCount.WORDS21
        if variant == 5:
            return WordCount.WORDS24
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WordCount.WORDS12:
            return
        if value == WordCount.WORDS15:
            return
        if value == WordCount.WORDS18:
            return
        if value == WordCount.WORDS21:
            return
        if value == WordCount.WORDS24:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == WordCount.WORDS12:
            buf.write_i32(1)
        if value == WordCount.WORDS15:
            buf.write_i32(2)
        if value == WordCount.WORDS18:
            buf.write_i32(3)
        if value == WordCount.WORDS21:
            buf.write_i32(4)
        if value == WordCount.WORDS24:
            buf.write_i32(5)





class Progress(typing.Protocol):
    def update(self, progress: "float",message: "typing.Optional[str]"):
        raise NotImplementedError
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplProgress:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_PROGRESS_METHOD0
    def update(
            uniffi_handle,
            progress,
            message,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterCallbackInterfaceProgress._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterFloat.lift(progress), _UniffiConverterOptionalString.lift(message), )
            method = uniffi_obj.update
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterCallbackInterfaceProgress._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceProgress(
        update,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_progress(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceProgress = _UniffiCallbackInterfaceFfiConverter()



class _UniffiConverterOptionalUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDescriptor(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDescriptor.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDescriptor.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDescriptor.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFeeRate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFeeRate.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFeeRate.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFeeRate.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransaction.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransaction.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransaction.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBlockTime(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBlockTime.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBlockTime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBlockTime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRpcSyncParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRpcSyncParams.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRpcSyncParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRpcSyncParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSignOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSignOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSignOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSignOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalCallbackInterfaceProgress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterCallbackInterfaceProgress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterCallbackInterfaceProgress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterCallbackInterfaceProgress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocalUtxo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocalUtxo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocalUtxo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocalUtxo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOutPoint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOutPoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOutPoint.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeScriptAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeScriptAmount.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeScriptAmount.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeScriptAmount.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTransactionDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTransactionDetails.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTransactionDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTransactionDetails.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxIn(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxIn.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxIn.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxIn.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxOut(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxOut.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxOut.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxOut.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceUInt8.read(buf) for i in range(count)
        ]

# Async support

__all__ = [
    "InternalError",
    "AddressIndex",
    "Auth",
    "BdkError",
    "BlockchainConfig",
    "DatabaseConfig",
    "KeychainKind",
    "Network",
    "Payload",
    "WitnessVersion",
    "WordCount",
    "AddressInfo",
    "Balance",
    "BlockTime",
    "ElectrumConfig",
    "EsploraConfig",
    "LocalUtxo",
    "OutPoint",
    "RpcConfig",
    "RpcSyncParams",
    "ScriptAmount",
    "SignOptions",
    "SledDbConfiguration",
    "SqliteDbConfiguration",
    "TransactionDetails",
    "TxBuilderResult",
    "TxIn",
    "TxOut",
    "Address",
    "Blockchain",
    "BumpFeeTxBuilder",
    "DerivationPath",
    "Descriptor",
    "DescriptorPublicKey",
    "DescriptorSecretKey",
    "FeeRate",
    "Mnemonic",
    "PartiallySignedTransaction",
    "Script",
    "Transaction",
    "TxBuilder",
    "Wallet",
    "Progress",
]

