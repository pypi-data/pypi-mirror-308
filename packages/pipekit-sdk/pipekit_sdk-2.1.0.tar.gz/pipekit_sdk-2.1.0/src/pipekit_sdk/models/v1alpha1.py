# generated by datamodel-codegen

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import Field, RootModel
from typing_extensions import Annotated

from pipekit_sdk.models._config import BaseModel

from . import intstr, v1


class Amount(RootModel[Any]):
    root: Any


class ArtGCStatus(BaseModel):
    not_specified: Annotated[Optional[bool], Field(alias="notSpecified")] = None
    pods_recouped: Annotated[Optional[Dict[str, bool]], Field(alias="podsRecouped")] = None
    strategies_processed: Annotated[Optional[Dict[str, bool]], Field(alias="strategiesProcessed")] = None


class ArtifactRepositoryRef(BaseModel):
    config_map: Annotated[Optional[str], Field(alias="configMap")] = None
    key: Optional[str] = None


class ArtifactoryArtifact(BaseModel):
    password_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="passwordSecret")] = None
    url: str
    username_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="usernameSecret")] = None


class ArtifactoryArtifactRepository(BaseModel):
    key_format: Annotated[Optional[str], Field(alias="keyFormat")] = None
    password_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="passwordSecret")] = None
    repo_url: Annotated[Optional[str], Field(alias="repoURL")] = None
    username_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="usernameSecret")] = None


class AzureArtifact(BaseModel):
    account_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accountKeySecret")] = None
    blob: str
    container: str
    endpoint: str
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class AzureArtifactRepository(BaseModel):
    account_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accountKeySecret")] = None
    blob_name_format: Annotated[Optional[str], Field(alias="blobNameFormat")] = None
    container: str
    endpoint: str
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class Backoff(BaseModel):
    duration: Optional[str] = None
    factor: Optional[intstr.IntOrString] = None
    max_duration: Annotated[Optional[str], Field(alias="maxDuration")] = None


class BasicAuth(BaseModel):
    password_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="passwordSecret")] = None
    username_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="usernameSecret")] = None


class Cache(BaseModel):
    config_map: Annotated[v1.ConfigMapKeySelector, Field(alias="configMap")]


class ClientCertAuth(BaseModel):
    client_cert_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="clientCertSecret")] = None
    client_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="clientKeySecret")] = None


class Condition(BaseModel):
    message: Optional[str] = None
    status: Optional[str] = None
    type: Optional[str] = None


class ContainerSetRetryStrategy(BaseModel):
    duration: Optional[str] = None
    retries: intstr.IntOrString


class ContinueOn(BaseModel):
    error: Optional[bool] = None
    failed: Optional[bool] = None


class Counter(BaseModel):
    value: str


class CreateS3BucketOptions(BaseModel):
    object_locking: Annotated[Optional[bool], Field(alias="objectLocking")] = None


class CronWorkflowStatus(BaseModel):
    active: List[v1.ObjectReference]
    conditions: List[Condition]
    last_scheduled_time: Annotated[v1.Time, Field(alias="lastScheduledTime")]


class ExecutorConfig(BaseModel):
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None


class GCSArtifact(BaseModel):
    bucket: Optional[str] = None
    key: str
    service_account_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="serviceAccountKeySecret")] = (
        None
    )


class GCSArtifactRepository(BaseModel):
    bucket: Optional[str] = None
    key_format: Annotated[Optional[str], Field(alias="keyFormat")] = None
    service_account_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="serviceAccountKeySecret")] = (
        None
    )


class Gauge(BaseModel):
    operation: Optional[str] = None
    realtime: bool
    value: str


class GitArtifact(BaseModel):
    branch: Optional[str] = None
    depth: Optional[int] = None
    disable_submodules: Annotated[Optional[bool], Field(alias="disableSubmodules")] = None
    fetch: Optional[List[str]] = None
    insecure_ignore_host_key: Annotated[Optional[bool], Field(alias="insecureIgnoreHostKey")] = None
    password_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="passwordSecret")] = None
    repo: str
    revision: Optional[str] = None
    single_branch: Annotated[Optional[bool], Field(alias="singleBranch")] = None
    ssh_private_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="sshPrivateKeySecret")] = None
    username_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="usernameSecret")] = None


class HDFSArtifact(BaseModel):
    addresses: Optional[List[str]] = None
    force: Optional[bool] = None
    hdfs_user: Annotated[Optional[str], Field(alias="hdfsUser")] = None
    krb_c_cache_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="krbCCacheSecret")] = None
    krb_config_config_map: Annotated[Optional[v1.ConfigMapKeySelector], Field(alias="krbConfigConfigMap")] = None
    krb_keytab_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="krbKeytabSecret")] = None
    krb_realm: Annotated[Optional[str], Field(alias="krbRealm")] = None
    krb_service_principal_name: Annotated[Optional[str], Field(alias="krbServicePrincipalName")] = None
    krb_username: Annotated[Optional[str], Field(alias="krbUsername")] = None
    path: str


class HDFSArtifactRepository(BaseModel):
    addresses: Optional[List[str]] = None
    force: Optional[bool] = None
    hdfs_user: Annotated[Optional[str], Field(alias="hdfsUser")] = None
    krb_c_cache_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="krbCCacheSecret")] = None
    krb_config_config_map: Annotated[Optional[v1.ConfigMapKeySelector], Field(alias="krbConfigConfigMap")] = None
    krb_keytab_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="krbKeytabSecret")] = None
    krb_realm: Annotated[Optional[str], Field(alias="krbRealm")] = None
    krb_service_principal_name: Annotated[Optional[str], Field(alias="krbServicePrincipalName")] = None
    krb_username: Annotated[Optional[str], Field(alias="krbUsername")] = None
    path_format: Annotated[Optional[str], Field(alias="pathFormat")] = None


class HTTPBodySource(BaseModel):
    bytes: Optional[str] = None


class HTTPHeaderSource(BaseModel):
    secret_key_ref: Annotated[Optional[v1.SecretKeySelector], Field(alias="secretKeyRef")] = None


class Header(BaseModel):
    name: str
    value: str


class Histogram(BaseModel):
    buckets: List[Amount]
    value: str


class Item(RootModel[Any]):
    root: Any


class LabelValueFrom(BaseModel):
    expression: str


class MemoizationStatus(BaseModel):
    cache_name: Annotated[str, Field(alias="cacheName")]
    hit: bool
    key: str


class Memoize(BaseModel):
    cache: Cache
    key: str
    max_age: Annotated[str, Field(alias="maxAge")]


class Metadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None


class MetricLabel(BaseModel):
    key: str
    value: str


class Mutex(BaseModel):
    name: Optional[str] = None
    namespace: Optional[str] = None


class MutexHolding(BaseModel):
    holder: Optional[str] = None
    mutex: Optional[str] = None


class MutexStatus(BaseModel):
    holding: Optional[List[MutexHolding]] = None
    waiting: Optional[List[MutexHolding]] = None


class NodeFlag(BaseModel):
    hooked: Optional[bool] = None
    retried: Optional[bool] = None


class NodeSynchronizationStatus(BaseModel):
    waiting: Optional[str] = None


class NoneStrategy(RootModel[Any]):
    root: Any


class OAuth2EndpointParam(BaseModel):
    key: str
    value: Optional[str] = None


class OSSLifecycleRule(BaseModel):
    mark_deletion_after_days: Annotated[Optional[int], Field(alias="markDeletionAfterDays")] = None
    mark_infrequent_access_after_days: Annotated[Optional[int], Field(alias="markInfrequentAccessAfterDays")] = None


class ParallelSteps(RootModel[Any]):
    root: Any


class Plugin(RootModel[Any]):
    root: Any


class Prometheus(BaseModel):
    counter: Optional[Counter] = None
    gauge: Optional[Gauge] = None
    help: str
    histogram: Optional[Histogram] = None
    labels: Optional[List[MetricLabel]] = None
    name: str
    when: Optional[str] = None


class RawArtifact(BaseModel):
    data: str


class RetryNodeAntiAffinity(RootModel[Any]):
    root: Any


class S3EncryptionOptions(BaseModel):
    enable_encryption: Annotated[Optional[bool], Field(alias="enableEncryption")] = None
    kms_encryption_context: Annotated[Optional[str], Field(alias="kmsEncryptionContext")] = None
    kms_key_id: Annotated[Optional[str], Field(alias="kmsKeyId")] = None
    server_side_customer_key_secret: Annotated[
        Optional[v1.SecretKeySelector], Field(alias="serverSideCustomerKeySecret")
    ] = None


class SemaphoreHolding(BaseModel):
    holders: Optional[List[str]] = None
    semaphore: Optional[str] = None


class SemaphoreRef(BaseModel):
    config_map_key_ref: Annotated[Optional[v1.ConfigMapKeySelector], Field(alias="configMapKeyRef")] = None
    namespace: Optional[str] = None


class SemaphoreStatus(BaseModel):
    holding: Optional[List[SemaphoreHolding]] = None
    waiting: Optional[List[SemaphoreHolding]] = None


class Sequence(BaseModel):
    count: Optional[intstr.IntOrString] = None
    end: Optional[intstr.IntOrString] = None
    format: Optional[str] = None
    start: Optional[intstr.IntOrString] = None


class SuppliedValueFrom(RootModel[Any]):
    root: Any


class SuspendTemplate(BaseModel):
    duration: Optional[str] = None


class Synchronization(BaseModel):
    mutex: Optional[Mutex] = None
    semaphore: Optional[SemaphoreRef] = None


class SynchronizationStatus(BaseModel):
    mutex: Optional[MutexStatus] = None
    semaphore: Optional[SemaphoreStatus] = None


class TTLStrategy(BaseModel):
    seconds_after_completion: Annotated[Optional[int], Field(alias="secondsAfterCompletion")] = None
    seconds_after_failure: Annotated[Optional[int], Field(alias="secondsAfterFailure")] = None
    seconds_after_success: Annotated[Optional[int], Field(alias="secondsAfterSuccess")] = None


class TarStrategy(BaseModel):
    compression_level: Annotated[Optional[int], Field(alias="compressionLevel")] = None


class TemplateRef(BaseModel):
    cluster_scope: Annotated[Optional[bool], Field(alias="clusterScope")] = None
    name: Optional[str] = None
    template: Optional[str] = None


class TransformationStep(BaseModel):
    expression: str


class ValueFrom(BaseModel):
    config_map_key_ref: Annotated[Optional[v1.ConfigMapKeySelector], Field(alias="configMapKeyRef")] = None
    default: Optional[str] = None
    event: Optional[str] = None
    expression: Optional[str] = None
    jq_filter: Annotated[Optional[str], Field(alias="jqFilter")] = None
    json_path: Annotated[Optional[str], Field(alias="jsonPath")] = None
    parameter: Optional[str] = None
    path: Optional[str] = None
    supplied: Optional[SuppliedValueFrom] = None


class VolumeClaimGC(BaseModel):
    strategy: Optional[str] = None


class WorkflowLevelArtifactGC(BaseModel):
    force_finalizer_removal: Annotated[Optional[bool], Field(alias="forceFinalizerRemoval")] = None
    pod_metadata: Annotated[Optional[Metadata], Field(alias="podMetadata")] = None
    pod_spec_patch: Annotated[Optional[str], Field(alias="podSpecPatch")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    strategy: Optional[str] = None


class WorkflowMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    labels_from: Annotated[Optional[Dict[str, LabelValueFrom]], Field(alias="labelsFrom")] = None


class WorkflowTemplateRef(BaseModel):
    cluster_scope: Annotated[Optional[bool], Field(alias="clusterScope")] = None
    name: Optional[str] = None


class ZipStrategy(RootModel[Any]):
    root: Any


class ArchiveStrategy(BaseModel):
    none: Optional[NoneStrategy] = None
    tar: Optional[TarStrategy] = None
    zip: Optional[ZipStrategy] = None


class ArtifactGC(BaseModel):
    pod_metadata: Annotated[Optional[Metadata], Field(alias="podMetadata")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    strategy: Optional[str] = None


class HTTPHeader(BaseModel):
    name: str
    value: Optional[str] = None
    value_from: Annotated[Optional[HTTPHeaderSource], Field(alias="valueFrom")] = None


class Metrics(BaseModel):
    prometheus: List[Prometheus]


class OAuth2Auth(BaseModel):
    client_id_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="clientIDSecret")] = None
    client_secret_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="clientSecretSecret")] = None
    endpoint_params: Annotated[Optional[List[OAuth2EndpointParam]], Field(alias="endpointParams")] = None
    scopes: Optional[List[str]] = None
    token_url_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="tokenURLSecret")] = None


class OSSArtifact(BaseModel):
    access_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accessKeySecret")] = None
    bucket: Optional[str] = None
    create_bucket_if_not_present: Annotated[Optional[bool], Field(alias="createBucketIfNotPresent")] = None
    endpoint: Optional[str] = None
    key: str
    lifecycle_rule: Annotated[Optional[OSSLifecycleRule], Field(alias="lifecycleRule")] = None
    secret_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="secretKeySecret")] = None
    security_token: Annotated[Optional[str], Field(alias="securityToken")] = None
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class OSSArtifactRepository(BaseModel):
    access_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accessKeySecret")] = None
    bucket: Optional[str] = None
    create_bucket_if_not_present: Annotated[Optional[bool], Field(alias="createBucketIfNotPresent")] = None
    endpoint: Optional[str] = None
    key_format: Annotated[Optional[str], Field(alias="keyFormat")] = None
    lifecycle_rule: Annotated[Optional[OSSLifecycleRule], Field(alias="lifecycleRule")] = None
    secret_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="secretKeySecret")] = None
    security_token: Annotated[Optional[str], Field(alias="securityToken")] = None
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class Parameter(BaseModel):
    default: Optional[str] = None
    description: Optional[str] = None
    enum: Optional[List[str]] = None
    global_name: Annotated[Optional[str], Field(alias="globalName")] = None
    name: str
    value: Optional[str] = None
    value_from: Annotated[Optional[ValueFrom], Field(alias="valueFrom")] = None


class PodGC(BaseModel):
    delete_delay_duration: Annotated[Optional[str], Field(alias="deleteDelayDuration")] = None
    label_selector: Annotated[Optional[v1.LabelSelector], Field(alias="labelSelector")] = None
    strategy: Optional[str] = None


class RetryAffinity(BaseModel):
    node_anti_affinity: Annotated[Optional[RetryNodeAntiAffinity], Field(alias="nodeAntiAffinity")] = None


class RetryStrategy(BaseModel):
    affinity: Optional[RetryAffinity] = None
    backoff: Optional[Backoff] = None
    expression: Optional[str] = None
    limit: Optional[intstr.IntOrString] = None
    retry_policy: Annotated[Optional[str], Field(alias="retryPolicy")] = None


class S3Artifact(BaseModel):
    access_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accessKeySecret")] = None
    bucket: Optional[str] = None
    ca_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="caSecret")] = None
    create_bucket_if_not_present: Annotated[
        Optional[CreateS3BucketOptions], Field(alias="createBucketIfNotPresent")
    ] = None
    encryption_options: Annotated[Optional[S3EncryptionOptions], Field(alias="encryptionOptions")] = None
    endpoint: Optional[str] = None
    insecure: Optional[bool] = None
    key: Optional[str] = None
    region: Optional[str] = None
    role_arn: Annotated[Optional[str], Field(alias="roleARN")] = None
    secret_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="secretKeySecret")] = None
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class S3ArtifactRepository(BaseModel):
    access_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="accessKeySecret")] = None
    bucket: Optional[str] = None
    ca_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="caSecret")] = None
    create_bucket_if_not_present: Annotated[
        Optional[CreateS3BucketOptions], Field(alias="createBucketIfNotPresent")
    ] = None
    encryption_options: Annotated[Optional[S3EncryptionOptions], Field(alias="encryptionOptions")] = None
    endpoint: Optional[str] = None
    insecure: Optional[bool] = None
    key_format: Annotated[Optional[str], Field(alias="keyFormat")] = None
    key_prefix: Annotated[Optional[str], Field(alias="keyPrefix")] = None
    region: Optional[str] = None
    role_arn: Annotated[Optional[str], Field(alias="roleARN")] = None
    secret_key_secret: Annotated[Optional[v1.SecretKeySelector], Field(alias="secretKeySecret")] = None
    use_sdk_creds: Annotated[Optional[bool], Field(alias="useSDKCreds")] = None


class ArtifactRepository(BaseModel):
    archive_logs: Annotated[Optional[bool], Field(alias="archiveLogs")] = None
    artifactory: Optional[ArtifactoryArtifactRepository] = None
    azure: Optional[AzureArtifactRepository] = None
    gcs: Optional[GCSArtifactRepository] = None
    hdfs: Optional[HDFSArtifactRepository] = None
    oss: Optional[OSSArtifactRepository] = None
    s3: Optional[S3ArtifactRepository] = None


class ArtifactRepositoryRefStatus(BaseModel):
    artifact_repository: Annotated[Optional[ArtifactRepository], Field(alias="artifactRepository")] = None
    config_map: Annotated[Optional[str], Field(alias="configMap")] = None
    default: Optional[bool] = None
    key: Optional[str] = None
    namespace: Optional[str] = None


class HTTP(BaseModel):
    body: Optional[str] = None
    body_from: Annotated[Optional[HTTPBodySource], Field(alias="bodyFrom")] = None
    headers: Optional[List[HTTPHeader]] = None
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    method: Optional[str] = None
    success_condition: Annotated[Optional[str], Field(alias="successCondition")] = None
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    url: str


class HTTPAuth(BaseModel):
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    client_cert: Annotated[Optional[ClientCertAuth], Field(alias="clientCert")] = None
    oauth2: Optional[OAuth2Auth] = None


class ContainerNode(BaseModel):
    args: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    dependencies: Optional[List[str]] = None
    env: Annotated[
        Optional[List[v1.EnvVar]],
        Field(description=("List of environment variables to set in the container. Cannot be" " updated.")),
    ] = None
    env_from: Annotated[
        Optional[List[v1.EnvFromSource]],
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        Optional[str],
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        Optional[str],
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        Optional[v1.Lifecycle],
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        Optional[List[v1.ContainerPort]],
        Field(
            description=(
                "List of ports to expose from the container. Exposing a port here gives"
                " the system additional information about the network connections a"
                " container uses, but is primarily informational. Not specifying a port"
                " here DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Cannot be updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resources: Annotated[
        Optional[v1.ResourceRequirements],
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    security_context: Annotated[
        Optional[v1.SecurityContext],
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    startup_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        Optional[bool],
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        Optional[List[v1.VolumeDevice]],
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the" " container."),
        ),
    ] = None
    volume_mounts: Annotated[
        Optional[List[v1.VolumeMount]],
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be" " updated."),
        ),
    ] = None
    working_dir: Annotated[
        Optional[str],
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class ContainerSetTemplate(BaseModel):
    containers: List[ContainerNode]
    retry_strategy: Annotated[Optional[ContainerSetRetryStrategy], Field(alias="retryStrategy")] = None
    volume_mounts: Annotated[Optional[List[v1.VolumeMount]], Field(alias="volumeMounts")] = None


class HTTPArtifact(BaseModel):
    auth: Optional[HTTPAuth] = None
    headers: Optional[List[Header]] = None
    url: str


class ScriptTemplate(BaseModel):
    args: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    env: Annotated[
        Optional[List[v1.EnvVar]],
        Field(description=("List of environment variables to set in the container. Cannot be" " updated.")),
    ] = None
    env_from: Annotated[
        Optional[List[v1.EnvFromSource]],
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        Optional[str],
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        Optional[str],
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        Optional[v1.Lifecycle],
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        Optional[List[v1.ContainerPort]],
        Field(
            description=(
                "List of ports to expose from the container. Exposing a port here gives"
                " the system additional information about the network connections a"
                " container uses, but is primarily informational. Not specifying a port"
                " here DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Cannot be updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resources: Annotated[
        Optional[v1.ResourceRequirements],
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    security_context: Annotated[
        Optional[v1.SecurityContext],
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    source: str
    startup_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        Optional[bool],
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        Optional[List[v1.VolumeDevice]],
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the" " container."),
        ),
    ] = None
    volume_mounts: Annotated[
        Optional[List[v1.VolumeMount]],
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be" " updated."),
        ),
    ] = None
    working_dir: Annotated[
        Optional[str],
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class UserContainer(BaseModel):
    args: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    env: Annotated[
        Optional[List[v1.EnvVar]],
        Field(description=("List of environment variables to set in the container. Cannot be" " updated.")),
    ] = None
    env_from: Annotated[
        Optional[List[v1.EnvFromSource]],
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        Optional[str],
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        Optional[str],
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        Optional[v1.Lifecycle],
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    mirror_volume_mounts: Annotated[Optional[bool], Field(alias="mirrorVolumeMounts")] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        Optional[List[v1.ContainerPort]],
        Field(
            description=(
                "List of ports to expose from the container. Exposing a port here gives"
                " the system additional information about the network connections a"
                " container uses, but is primarily informational. Not specifying a port"
                " here DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Cannot be updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resources: Annotated[
        Optional[v1.ResourceRequirements],
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    security_context: Annotated[
        Optional[v1.SecurityContext],
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    startup_probe: Annotated[
        Optional[v1.Probe],
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        Optional[bool],
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        Optional[List[v1.VolumeDevice]],
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the" " container."),
        ),
    ] = None
    volume_mounts: Annotated[
        Optional[List[v1.VolumeMount]],
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be" " updated."),
        ),
    ] = None
    working_dir: Annotated[
        Optional[str],
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class Artifact(BaseModel):
    archive: Optional[ArchiveStrategy] = None
    archive_logs: Annotated[Optional[bool], Field(alias="archiveLogs")] = None
    artifact_gc: Annotated[Optional[ArtifactGC], Field(alias="artifactGC")] = None
    artifactory: Optional[ArtifactoryArtifact] = None
    azure: Optional[AzureArtifact] = None
    deleted: Optional[bool] = None
    from_: Annotated[Optional[str], Field(alias="from")] = None
    from_expression: Annotated[Optional[str], Field(alias="fromExpression")] = None
    gcs: Optional[GCSArtifact] = None
    git: Optional[GitArtifact] = None
    global_name: Annotated[Optional[str], Field(alias="globalName")] = None
    hdfs: Optional[HDFSArtifact] = None
    http: Optional[HTTPArtifact] = None
    mode: Optional[int] = None
    name: str
    optional: Optional[bool] = None
    oss: Optional[OSSArtifact] = None
    path: Optional[str] = None
    raw: Optional[RawArtifact] = None
    recurse_mode: Annotated[Optional[bool], Field(alias="recurseMode")] = None
    s3: Optional[S3Artifact] = None
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None


class ArtifactLocation(BaseModel):
    archive_logs: Annotated[Optional[bool], Field(alias="archiveLogs")] = None
    artifactory: Optional[ArtifactoryArtifact] = None
    azure: Optional[AzureArtifact] = None
    gcs: Optional[GCSArtifact] = None
    git: Optional[GitArtifact] = None
    hdfs: Optional[HDFSArtifact] = None
    http: Optional[HTTPArtifact] = None
    oss: Optional[OSSArtifact] = None
    raw: Optional[RawArtifact] = None
    s3: Optional[S3Artifact] = None


class ArtifactPaths(BaseModel):
    archive: Optional[ArchiveStrategy] = None
    archive_logs: Annotated[Optional[bool], Field(alias="archiveLogs")] = None
    artifact_gc: Annotated[Optional[ArtifactGC], Field(alias="artifactGC")] = None
    artifactory: Optional[ArtifactoryArtifact] = None
    azure: Optional[AzureArtifact] = None
    deleted: Optional[bool] = None
    from_: Annotated[Optional[str], Field(alias="from")] = None
    from_expression: Annotated[Optional[str], Field(alias="fromExpression")] = None
    gcs: Optional[GCSArtifact] = None
    git: Optional[GitArtifact] = None
    global_name: Annotated[Optional[str], Field(alias="globalName")] = None
    hdfs: Optional[HDFSArtifact] = None
    http: Optional[HTTPArtifact] = None
    mode: Optional[int] = None
    name: str
    optional: Optional[bool] = None
    oss: Optional[OSSArtifact] = None
    path: Optional[str] = None
    raw: Optional[RawArtifact] = None
    recurse_mode: Annotated[Optional[bool], Field(alias="recurseMode")] = None
    s3: Optional[S3Artifact] = None
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None


class DataSource(BaseModel):
    artifact_paths: Annotated[Optional[ArtifactPaths], Field(alias="artifactPaths")] = None


class Inputs(BaseModel):
    artifacts: Optional[List[Artifact]] = None
    parameters: Optional[List[Parameter]] = None


class ManifestFrom(BaseModel):
    artifact: Artifact


class Outputs(BaseModel):
    artifacts: Optional[List[Artifact]] = None
    exit_code: Annotated[Optional[str], Field(alias="exitCode")] = None
    parameters: Optional[List[Parameter]] = None
    result: Optional[str] = None


class ResourceTemplate(BaseModel):
    action: str
    failure_condition: Annotated[Optional[str], Field(alias="failureCondition")] = None
    flags: Optional[List[str]] = None
    manifest: Optional[str] = None
    manifest_from: Annotated[Optional[ManifestFrom], Field(alias="manifestFrom")] = None
    merge_strategy: Annotated[Optional[str], Field(alias="mergeStrategy")] = None
    set_owner_reference: Annotated[Optional[bool], Field(alias="setOwnerReference")] = None
    success_condition: Annotated[Optional[str], Field(alias="successCondition")] = None


class Arguments(BaseModel):
    artifacts: Optional[List[Artifact]] = None
    parameters: Optional[List[Parameter]] = None


class Data(BaseModel):
    source: DataSource
    transformation: List[TransformationStep]


class LifecycleHook(BaseModel):
    arguments: Optional[Arguments] = None
    expression: Optional[str] = None
    template: Optional[str] = None
    template_ref: Annotated[Optional[TemplateRef], Field(alias="templateRef")] = None


class NodeStatus(BaseModel):
    boundary_id: Annotated[Optional[str], Field(alias="boundaryID")] = None
    children: Optional[List[str]] = None
    daemoned: Optional[bool] = None
    display_name: Annotated[Optional[str], Field(alias="displayName")] = None
    estimated_duration: Annotated[Optional[int], Field(alias="estimatedDuration")] = None
    finished_at: Annotated[Optional[v1.Time], Field(alias="finishedAt")] = None
    host_node_name: Annotated[Optional[str], Field(alias="hostNodeName")] = None
    id: str
    inputs: Optional[Inputs] = None
    memoization_status: Annotated[Optional[MemoizationStatus], Field(alias="memoizationStatus")] = None
    message: Optional[str] = None
    name: str
    node_flag: Annotated[Optional[NodeFlag], Field(alias="nodeFlag")] = None
    outbound_nodes: Annotated[Optional[List[str]], Field(alias="outboundNodes")] = None
    outputs: Optional[Outputs] = None
    phase: Optional[str] = None
    pod_ip: Annotated[Optional[str], Field(alias="podIP")] = None
    progress: Optional[str] = None
    resources_duration: Annotated[Optional[Dict[str, int]], Field(alias="resourcesDuration")] = None
    started_at: Annotated[Optional[v1.Time], Field(alias="startedAt")] = None
    synchronization_status: Annotated[Optional[NodeSynchronizationStatus], Field(alias="synchronizationStatus")] = None
    template_name: Annotated[Optional[str], Field(alias="templateName")] = None
    template_ref: Annotated[Optional[TemplateRef], Field(alias="templateRef")] = None
    template_scope: Annotated[Optional[str], Field(alias="templateScope")] = None
    type: str


class CronWorkflow(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1.ObjectMeta
    spec: CronWorkflowSpec
    status: Optional[CronWorkflowStatus] = None


class CronWorkflowSpec(BaseModel):
    concurrency_policy: Annotated[Optional[str], Field(alias="concurrencyPolicy")] = None
    failed_jobs_history_limit: Annotated[Optional[int], Field(alias="failedJobsHistoryLimit")] = None
    schedule: str
    starting_deadline_seconds: Annotated[Optional[int], Field(alias="startingDeadlineSeconds")] = None
    successful_jobs_history_limit: Annotated[Optional[int], Field(alias="successfulJobsHistoryLimit")] = None
    suspend: Optional[bool] = None
    timezone: Optional[str] = None
    workflow_metadata: Annotated[Optional[v1.ObjectMeta], Field(alias="workflowMetadata")] = None
    workflow_spec: Annotated[WorkflowSpec, Field(alias="workflowSpec")]


class DAGTask(BaseModel):
    arguments: Optional[Arguments] = None
    continue_on: Annotated[Optional[ContinueOn], Field(alias="continueOn")] = None
    dependencies: Optional[List[str]] = None
    depends: Optional[str] = None
    hooks: Optional[Dict[str, LifecycleHook]] = None
    inline: Optional[Template] = None
    name: str
    on_exit: Annotated[Optional[str], Field(alias="onExit")] = None
    template: Optional[str] = None
    template_ref: Annotated[Optional[TemplateRef], Field(alias="templateRef")] = None
    when: Optional[str] = None
    with_items: Annotated[Optional[List[Item]], Field(alias="withItems")] = None
    with_param: Annotated[Optional[str], Field(alias="withParam")] = None
    with_sequence: Annotated[Optional[Sequence], Field(alias="withSequence")] = None


class DAGTemplate(BaseModel):
    fail_fast: Annotated[Optional[bool], Field(alias="failFast")] = None
    target: Optional[str] = None
    tasks: List[DAGTask]


class Template(BaseModel):
    active_deadline_seconds: Annotated[Optional[intstr.IntOrString], Field(alias="activeDeadlineSeconds")] = None
    affinity: Optional[v1.Affinity] = None
    archive_location: Annotated[Optional[ArtifactLocation], Field(alias="archiveLocation")] = None
    automount_service_account_token: Annotated[Optional[bool], Field(alias="automountServiceAccountToken")] = None
    container: Optional[v1.Container] = None
    container_set: Annotated[Optional[ContainerSetTemplate], Field(alias="containerSet")] = None
    daemon: Optional[bool] = None
    dag: Optional[DAGTemplate] = None
    data: Optional[Data] = None
    executor: Optional[ExecutorConfig] = None
    fail_fast: Annotated[Optional[bool], Field(alias="failFast")] = None
    host_aliases: Annotated[Optional[List[v1.HostAlias]], Field(alias="hostAliases")] = None
    http: Optional[HTTP] = None
    init_containers: Annotated[Optional[List[UserContainer]], Field(alias="initContainers")] = None
    inputs: Optional[Inputs] = None
    memoize: Optional[Memoize] = None
    metadata: Optional[Metadata] = None
    metrics: Optional[Metrics] = None
    name: Optional[str] = None
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    outputs: Optional[Outputs] = None
    parallelism: Optional[int] = None
    plugin: Optional[Plugin] = None
    pod_spec_patch: Annotated[Optional[str], Field(alias="podSpecPatch")] = None
    priority: Optional[int] = None
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    resource: Optional[ResourceTemplate] = None
    retry_strategy: Annotated[Optional[RetryStrategy], Field(alias="retryStrategy")] = None
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    script: Optional[ScriptTemplate] = None
    security_context: Annotated[Optional[v1.PodSecurityContext], Field(alias="securityContext")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    sidecars: Optional[List[UserContainer]] = None
    steps: Optional[List[ParallelSteps]] = None
    suspend: Optional[SuspendTemplate] = None
    synchronization: Optional[Synchronization] = None
    timeout: Optional[str] = None
    tolerations: Optional[List[v1.Toleration]] = None
    volumes: Optional[List[v1.Volume]] = None


class Workflow(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1.ObjectMeta
    spec: WorkflowSpec
    status: Optional[WorkflowStatus] = None


class WorkflowSpec(BaseModel):
    active_deadline_seconds: Annotated[Optional[int], Field(alias="activeDeadlineSeconds")] = None
    affinity: Optional[v1.Affinity] = None
    archive_logs: Annotated[Optional[bool], Field(alias="archiveLogs")] = None
    arguments: Optional[Arguments] = None
    artifact_gc: Annotated[Optional[WorkflowLevelArtifactGC], Field(alias="artifactGC")] = None
    artifact_repository_ref: Annotated[Optional[ArtifactRepositoryRef], Field(alias="artifactRepositoryRef")] = None
    automount_service_account_token: Annotated[Optional[bool], Field(alias="automountServiceAccountToken")] = None
    dns_config: Annotated[Optional[v1.PodDNSConfig], Field(alias="dnsConfig")] = None
    dns_policy: Annotated[Optional[str], Field(alias="dnsPolicy")] = None
    entrypoint: Optional[str] = None
    executor: Optional[ExecutorConfig] = None
    hooks: Optional[Dict[str, LifecycleHook]] = None
    host_aliases: Annotated[Optional[List[v1.HostAlias]], Field(alias="hostAliases")] = None
    host_network: Annotated[Optional[bool], Field(alias="hostNetwork")] = None
    image_pull_secrets: Annotated[Optional[List[v1.LocalObjectReference]], Field(alias="imagePullSecrets")] = None
    metrics: Optional[Metrics] = None
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    on_exit: Annotated[Optional[str], Field(alias="onExit")] = None
    parallelism: Optional[int] = None
    pod_disruption_budget: Annotated[Optional[v1.PodDisruptionBudgetSpec], Field(alias="podDisruptionBudget")] = None
    pod_gc: Annotated[Optional[PodGC], Field(alias="podGC")] = None
    pod_metadata: Annotated[Optional[Metadata], Field(alias="podMetadata")] = None
    pod_priority: Annotated[Optional[int], Field(alias="podPriority")] = None
    pod_priority_class_name: Annotated[Optional[str], Field(alias="podPriorityClassName")] = None
    pod_spec_patch: Annotated[Optional[str], Field(alias="podSpecPatch")] = None
    priority: Optional[int] = None
    retry_strategy: Annotated[Optional[RetryStrategy], Field(alias="retryStrategy")] = None
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    security_context: Annotated[Optional[v1.PodSecurityContext], Field(alias="securityContext")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    shutdown: Optional[str] = None
    suspend: Optional[bool] = None
    synchronization: Optional[Synchronization] = None
    template_defaults: Annotated[Optional[Template], Field(alias="templateDefaults")] = None
    templates: Optional[List[Template]] = None
    tolerations: Optional[List[v1.Toleration]] = None
    ttl_strategy: Annotated[Optional[TTLStrategy], Field(alias="ttlStrategy")] = None
    volume_claim_gc: Annotated[Optional[VolumeClaimGC], Field(alias="volumeClaimGC")] = None
    volume_claim_templates: Annotated[
        Optional[List[v1.PersistentVolumeClaim]], Field(alias="volumeClaimTemplates")
    ] = None
    volumes: Optional[List[v1.Volume]] = None
    workflow_metadata: Annotated[Optional[WorkflowMetadata], Field(alias="workflowMetadata")] = None
    workflow_template_ref: Annotated[Optional[WorkflowTemplateRef], Field(alias="workflowTemplateRef")] = None


class WorkflowStatus(BaseModel):
    artifact_gc_status: Annotated[Optional[ArtGCStatus], Field(alias="artifactGCStatus")] = None
    artifact_repository_ref: Annotated[Optional[ArtifactRepositoryRefStatus], Field(alias="artifactRepositoryRef")] = (
        None
    )
    compressed_nodes: Annotated[Optional[str], Field(alias="compressedNodes")] = None
    conditions: Optional[List[Condition]] = None
    estimated_duration: Annotated[Optional[int], Field(alias="estimatedDuration")] = None
    finished_at: Annotated[Optional[v1.Time], Field(alias="finishedAt")] = None
    message: Optional[str] = None
    nodes: Optional[Dict[str, NodeStatus]] = None
    offload_node_status_version: Annotated[Optional[str], Field(alias="offloadNodeStatusVersion")] = None
    outputs: Optional[Outputs] = None
    persistent_volume_claims: Annotated[Optional[List[v1.Volume]], Field(alias="persistentVolumeClaims")] = None
    phase: Optional[str] = None
    progress: Optional[str] = None
    resources_duration: Annotated[Optional[Dict[str, int]], Field(alias="resourcesDuration")] = None
    started_at: Annotated[Optional[v1.Time], Field(alias="startedAt")] = None
    stored_templates: Annotated[Optional[Dict[str, Template]], Field(alias="storedTemplates")] = None
    stored_workflow_template_spec: Annotated[Optional[WorkflowSpec], Field(alias="storedWorkflowTemplateSpec")] = None
    synchronization: Optional[SynchronizationStatus] = None
    task_results_completion_status: Annotated[
        Optional[Dict[str, bool]], Field(alias="taskResultsCompletionStatus")
    ] = None


CronWorkflow.model_rebuild()
CronWorkflowSpec.model_rebuild()
DAGTask.model_rebuild()
Workflow.model_rebuild()
