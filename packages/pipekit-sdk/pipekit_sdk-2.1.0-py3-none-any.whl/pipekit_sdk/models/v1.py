# generated by datamodel-codegen

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import AwareDatetime, Field, RootModel
from typing_extensions import Annotated

from pipekit_sdk.models._config import BaseModel

from . import intstr, resource


class AWSElasticBlockStoreVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type of the volume that you want to mount."
                " Tip: Ensure that the filesystem type is supported by the host"
                ' operating system. Examples: "ext4", "xfs", "ntfs". Implicitly'
                ' inferred to be "ext4" if unspecified. More info:'
                " https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
            ),
        ),
    ] = None
    partition: Annotated[
        Optional[int],
        Field(
            description=(
                "partition is the partition in the volume that you want to mount. If"
                " omitted, the default is to mount by volume name. Examples: For volume"
                ' /dev/sda1, you specify the partition as "1". Similarly, the volume'
                ' partition for /dev/sda is "0" (or you can leave the property empty).'
            )
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly value true will force the readOnly setting in VolumeMounts."
                " More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
            ),
        ),
    ] = None
    volume_id: Annotated[
        str,
        Field(
            alias="volumeID",
            description=(
                "volumeID is unique ID of the persistent disk resource in AWS (Amazon"
                " EBS volume). More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
            ),
        ),
    ]


class AzureDiskVolumeSource(BaseModel):
    caching_mode: Annotated[
        Optional[str],
        Field(
            alias="cachingMode",
            description=("cachingMode is the Host Caching mode: None, Read Only, Read Write."),
        ),
    ] = None
    disk_name: Annotated[
        str,
        Field(
            alias="diskName",
            description="diskName is the Name of the data disk in the blob storage",
        ),
    ]
    disk_uri: Annotated[
        str,
        Field(
            alias="diskURI",
            description="diskURI is the URI of data disk in the blob storage",
        ),
    ]
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is Filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description=(
                "kind expected values are Shared: multiple blob disks per storage"
                " account  Dedicated: single blob disk per storage account  Managed:"
                " azure managed data disk (only in managed availability set). defaults"
                " to shared"
            )
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly Defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None


class AzureFileVolumeSource(BaseModel):
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    secret_name: Annotated[
        str,
        Field(
            alias="secretName",
            description=("secretName is the  name of secret that contains Azure Storage Account" " Name and Key"),
        ),
    ]
    share_name: Annotated[str, Field(alias="shareName", description="shareName is the azure share Name")]


class Capabilities(BaseModel):
    add: Annotated[Optional[List[str]], Field(description="Added capabilities")] = None
    drop: Annotated[Optional[List[str]], Field(description="Removed capabilities")] = None


class ConfigMapEnvSource(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description="Specify whether the ConfigMap must be defined"),
    ] = None


class ConfigMapKeySelector(BaseModel):
    key: Annotated[str, Field(description="The key to select.")]
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description="Specify whether the ConfigMap or its key must be defined"),
    ] = None


class ContainerPort(BaseModel):
    container_port: Annotated[
        int,
        Field(
            alias="containerPort",
            description=(
                "Number of port to expose on the pod's IP address. This must be a valid" " port number, 0 < x < 65536."
            ),
        ),
    ]
    host_ip: Annotated[
        Optional[str],
        Field(alias="hostIP", description="What host IP to bind the external port to."),
    ] = None
    host_port: Annotated[
        Optional[int],
        Field(
            alias="hostPort",
            description=(
                "Number of port to expose on the host. If specified, this must be a"
                " valid port number, 0 < x < 65536. If HostNetwork is specified, this"
                " must match ContainerPort. Most containers do not need this."
            ),
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "If specified, this must be an IANA_SVC_NAME and unique within the pod."
                " Each named port in a pod must have a unique name. Name for the port"
                " that can be referred to by services."
            )
        ),
    ] = None
    protocol: Annotated[
        Optional[str],
        Field(description=('Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".')),
    ] = None


class ExecAction(BaseModel):
    command: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Command is the command line to execute inside the container, the"
                " working directory for the command  is root ('/') in the container's"
                " filesystem. The command is simply exec'd, it is not run inside a"
                " shell, so traditional shell instructions ('|', etc) won't work. To"
                " use a shell, you need to explicitly call out to that shell. Exit"
                " status of 0 is treated as live/healthy and non-zero is unhealthy."
            )
        ),
    ] = None


class FCVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    lun: Annotated[Optional[int], Field(description="lun is Optional: FC target lun number")] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly is Optional: Defaults to false (read/write). ReadOnly here"
                " will force the ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    target_ww_ns: Annotated[
        Optional[List[str]],
        Field(
            alias="targetWWNs",
            description="targetWWNs is Optional: FC target worldwide names (WWNs)",
        ),
    ] = None
    wwids: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "wwids Optional: FC volume world wide identifiers (wwids) Either wwids"
                " or combination of targetWWNs and lun must be set, but not both"
                " simultaneously."
            )
        ),
    ] = None


class FieldsV1(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description=(
                "FieldsV1 stores a set of fields in a data structure like a Trie, in"
                " JSON format.\n\nEach key is either a '.' representing the field"
                " itself, and will always map to an empty set, or a string representing"
                " a sub-field or item. The string will follow one of these four"
                " formats: 'f:<name>', where <name> is the name of a field in a struct,"
                " or key in a map 'v:<value>', where <value> is the exact json"
                " formatted value of a list item 'i:<index>', where <index> is position"
                " of a item in a list 'k:<keys>', where <keys> is a map of  a list"
                " item's key fields to their unique values If a key maps to an empty"
                " Fields value, the field that key represents is part of the"
                " set.\n\nThe exact format is defined in"
                " sigs.k8s.io/structured-merge-diff"
            )
        ),
    ]


class FlockerVolumeSource(BaseModel):
    dataset_name: Annotated[
        Optional[str],
        Field(
            alias="datasetName",
            description=(
                "datasetName is Name of the dataset stored as metadata -> name on the"
                " dataset for Flocker should be considered as deprecated"
            ),
        ),
    ] = None
    dataset_uuid: Annotated[
        Optional[str],
        Field(
            alias="datasetUUID",
            description=("datasetUUID is the UUID of the dataset. This is unique identifier of a" " Flocker dataset"),
        ),
    ] = None


class GCEPersistentDiskVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is filesystem type of the volume that you want to mount. Tip:"
                " Ensure that the filesystem type is supported by the host operating"
                ' system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be'
                ' "ext4" if unspecified. More info:'
                " https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
            ),
        ),
    ] = None
    partition: Annotated[
        Optional[int],
        Field(
            description=(
                "partition is the partition in the volume that you want to mount. If"
                " omitted, the default is to mount by volume name. Examples: For volume"
                ' /dev/sda1, you specify the partition as "1". Similarly, the volume'
                ' partition for /dev/sda is "0" (or you can leave the property empty).'
                " More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
            )
        ),
    ] = None
    pd_name: Annotated[
        str,
        Field(
            alias="pdName",
            description=(
                "pdName is unique name of the PD resource in GCE. Used to identify the"
                " disk in GCE. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
            ),
        ),
    ]
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly here will force the ReadOnly setting in VolumeMounts."
                " Defaults to false. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
            ),
        ),
    ] = None


class GRPCAction(BaseModel):
    port: Annotated[
        int,
        Field(description=("Port number of the gRPC service. Number must be in the range 1 to" " 65535.")),
    ]
    service: Annotated[
        str,
        Field(
            description=(
                "Service is the name of the service to place in the gRPC"
                " HealthCheckRequest (see"
                " https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf"
                " this is not specified, the default behavior is defined by gRPC."
            )
        ),
    ]


class GitRepoVolumeSource(BaseModel):
    directory: Annotated[
        Optional[str],
        Field(
            description=(
                "directory is the target directory name. Must not contain or start with"
                " '..'.  If '.' is supplied, the volume directory will be the git"
                " repository.  Otherwise, if specified, the volume will contain the git"
                " repository in the subdirectory with the given name."
            )
        ),
    ] = None
    repository: Annotated[str, Field(description="repository is the URL")]
    revision: Annotated[
        Optional[str],
        Field(description="revision is the commit hash for the specified revision."),
    ] = None


class GlusterfsVolumeSource(BaseModel):
    endpoints: Annotated[
        str,
        Field(
            description=(
                "endpoints is the endpoint name that details Glusterfs topology. More"
                " info:"
                " https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
            )
        ),
    ]
    path: Annotated[
        str,
        Field(
            description=(
                "path is the Glusterfs volume path. More info:"
                " https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
            )
        ),
    ]
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly here will force the Glusterfs volume to be mounted with"
                " read-only permissions. Defaults to false. More info:"
                " https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
            ),
        ),
    ] = None


class HTTPHeader(BaseModel):
    name: Annotated[str, Field(description="The header field name")]
    value: Annotated[str, Field(description="The header field value")]


class HostAlias(BaseModel):
    hostnames: Annotated[Optional[List[str]], Field(description="Hostnames for the above IP address.")] = None
    ip: Annotated[Optional[str], Field(description="IP address of the host file entry.")] = None


class HostPathVolumeSource(BaseModel):
    path: Annotated[
        str,
        Field(
            description=(
                "path of the directory on the host. If the path is a symlink, it will"
                " follow the link to the real path. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#hostpath"
            )
        ),
    ]
    type: Annotated[
        Optional[str],
        Field(
            description=(
                'type for HostPath Volume Defaults to "" More info:'
                " https://kubernetes.io/docs/concepts/storage/volumes#hostpath"
            )
        ),
    ] = None


class KeyToPath(BaseModel):
    key: Annotated[str, Field(description="key is the key to project.")]
    mode: Annotated[
        Optional[int],
        Field(
            description=(
                "mode is Optional: mode bits used to set permissions on this file. Must"
                " be an octal value between 0000 and 0777 or a decimal value between 0"
                " and 511. YAML accepts both octal and decimal values, JSON requires"
                " decimal values for mode bits. If not specified, the volume"
                " defaultMode will be used. This might be in conflict with other"
                " options that affect the file mode, like fsGroup, and the result can"
                " be other mode bits set."
            )
        ),
    ] = None
    path: Annotated[
        str,
        Field(
            description=(
                "path is the relative path of the file to map the key to. May not be an"
                " absolute path. May not contain the path element '..'. May not start"
                " with the string '..'."
            )
        ),
    ]


class LabelSelectorRequirement(BaseModel):
    key: Annotated[str, Field(description="key is the label key that the selector applies to.")]
    operator: Annotated[
        str,
        Field(
            description=(
                "operator represents a key's relationship to a set of values. Valid"
                " operators are In, NotIn, Exists and DoesNotExist."
            )
        ),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "values is an array of string values. If the operator is In or NotIn,"
                " the values array must be non-empty. If the operator is Exists or"
                " DoesNotExist, the values array must be empty. This array is replaced"
                " during a strategic merge patch."
            )
        ),
    ] = None


class LocalObjectReference(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None


class NFSVolumeSource(BaseModel):
    path: Annotated[
        str,
        Field(
            description=(
                "path that is exported by the NFS server. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#nfs"
            )
        ),
    ]
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly here will force the NFS export to be mounted with read-only"
                " permissions. Defaults to false. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#nfs"
            ),
        ),
    ] = None
    server: Annotated[
        str,
        Field(
            description=(
                "server is the hostname or IP address of the NFS server. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#nfs"
            )
        ),
    ]


class NodeSelectorRequirement(BaseModel):
    key: Annotated[str, Field(description="The label key that the selector applies to.")]
    operator: Annotated[
        str,
        Field(
            description=(
                "Represents a key's relationship to a set of values. Valid operators"
                " are In, NotIn, Exists, DoesNotExist. Gt, and Lt."
            )
        ),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "An array of string values. If the operator is In or NotIn, the values"
                " array must be non-empty. If the operator is Exists or DoesNotExist,"
                " the values array must be empty. If the operator is Gt or Lt, the"
                " values array must have a single element, which will be interpreted as"
                " an integer. This array is replaced during a strategic merge patch."
            )
        ),
    ] = None


class NodeSelectorTerm(BaseModel):
    match_expressions: Annotated[
        Optional[List[NodeSelectorRequirement]],
        Field(
            alias="matchExpressions",
            description="A list of node selector requirements by node's labels.",
        ),
    ] = None
    match_fields: Annotated[
        Optional[List[NodeSelectorRequirement]],
        Field(
            alias="matchFields",
            description="A list of node selector requirements by node's fields.",
        ),
    ] = None


class ObjectFieldSelector(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description=("Version of the schema the FieldPath is written in terms of, defaults" ' to "v1".'),
        ),
    ] = None
    field_path: Annotated[
        str,
        Field(
            alias="fieldPath",
            description="Path of the field to select in the specified API version.",
        ),
    ]


class ObjectReference(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent."),
    ] = None
    field_path: Annotated[
        Optional[str],
        Field(
            alias="fieldPath",
            description=(
                "If referring to a piece of an object instead of an entire object, this"
                " string should contain a valid JSON/Go field access statement, such as"
                " desiredState.manifest.containers[2]. For example, if the object"
                " reference is to a container within a pod, this would take on a value"
                ' like: "spec.containers{name}" (where "name" refers to the name of the'
                " container that triggered the event) or if no container name is"
                ' specified "spec.containers[2]" (container with index 2 in this pod).'
                " This syntax is chosen only to have some well-defined way of"
                " referencing a part of an object."
            ),
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description=(
                "Kind of the referent. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    namespace: Annotated[
        Optional[str],
        Field(
            description=(
                "Namespace of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"
            )
        ),
    ] = None
    resource_version: Annotated[
        Optional[str],
        Field(
            alias="resourceVersion",
            description=(
                "Specific resourceVersion to which this reference is made, if any. More"
                " info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
            ),
        ),
    ] = None
    uid: Annotated[
        Optional[str],
        Field(
            description=(
                "UID of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"
            )
        ),
    ] = None


class OwnerReference(BaseModel):
    api_version: Annotated[str, Field(alias="apiVersion", description="API version of the referent.")]
    block_owner_deletion: Annotated[
        Optional[bool],
        Field(
            alias="blockOwnerDeletion",
            description=(
                'If true, AND if the owner has the "foregroundDeletion" finalizer, then'
                " the owner cannot be deleted from the key-value store until this"
                " reference is removed. See"
                " https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion"
                " for how the garbage collector interacts with this field and enforces"
                " the foreground deletion. Defaults to false. To set this field, a user"
                ' needs "delete" permission of the owner, otherwise 422 (Unprocessable'
                " Entity) will be returned."
            ),
        ),
    ] = None
    controller: Annotated[
        Optional[bool],
        Field(description="If true, this reference points to the managing controller."),
    ] = None
    kind: Annotated[
        str,
        Field(
            description=(
                "Kind of the referent. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ]
    name: Annotated[
        str,
        Field(
            description=("Name of the referent. More info:" " http://kubernetes.io/docs/user-guide/identifiers#names")
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description=("UID of the referent. More info:" " http://kubernetes.io/docs/user-guide/identifiers#uids")
        ),
    ]


class PersistentVolumeClaimVolumeSource(BaseModel):
    claim_name: Annotated[
        str,
        Field(
            alias="claimName",
            description=(
                "claimName is the name of a PersistentVolumeClaim in the same namespace"
                " as the pod using this volume. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
            ),
        ),
    ]
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=("readOnly Will force the ReadOnly setting in VolumeMounts. Default" " false."),
        ),
    ] = None


class PhotonPersistentDiskVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    pd_id: Annotated[
        str,
        Field(
            alias="pdID",
            description=("pdID is the ID that identifies Photon Controller persistent disk"),
        ),
    ]


class PodDNSConfigOption(BaseModel):
    name: Annotated[Optional[str], Field(description="Required.")] = None
    value: Optional[str] = None


class PortworxVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fSType represents the filesystem type to mount Must be a filesystem"
                ' type supported by the host operating system. Ex. "ext4", "xfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    volume_id: Annotated[
        str,
        Field(
            alias="volumeID",
            description="volumeID uniquely identifies a Portworx volume",
        ),
    ]


class PreferredSchedulingTerm(BaseModel):
    preference: Annotated[
        NodeSelectorTerm,
        Field(description=("A node selector term, associated with the corresponding weight.")),
    ]
    weight: Annotated[
        int,
        Field(
            description=("Weight associated with matching the corresponding nodeSelectorTerm, in" " the range 1-100.")
        ),
    ]


class QuobyteVolumeSource(BaseModel):
    group: Annotated[
        Optional[str],
        Field(description="group to map volume access to Default is no group"),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly here will force the Quobyte volume to be mounted with"
                " read-only permissions. Defaults to false."
            ),
        ),
    ] = None
    registry: Annotated[
        str,
        Field(
            description=(
                "registry represents a single or multiple Quobyte Registry services"
                " specified as a string as host:port pair (multiple entries are"
                " separated with commas) which acts as the central registry for volumes"
            )
        ),
    ]
    tenant: Annotated[
        Optional[str],
        Field(
            description=(
                "tenant owning the given Quobyte volume in the Backend Used with"
                " dynamically provisioned Quobyte volumes, value is set by the plugin"
            )
        ),
    ] = None
    user: Annotated[
        Optional[str],
        Field(description="user to map volume access to Defaults to serivceaccount user"),
    ] = None
    volume: Annotated[
        str,
        Field(description=("volume is a string that references an already created Quobyte volume" " by name.")),
    ]


class RBDVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type of the volume that you want to mount."
                " Tip: Ensure that the filesystem type is supported by the host"
                ' operating system. Examples: "ext4", "xfs", "ntfs". Implicitly'
                ' inferred to be "ext4" if unspecified. More info:'
                " https://kubernetes.io/docs/concepts/storage/volumes#rbd"
            ),
        ),
    ] = None
    image: Annotated[
        str,
        Field(
            description=(
                "image is the rados image name. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            )
        ),
    ]
    keyring: Annotated[
        Optional[str],
        Field(
            description=(
                "keyring is the path to key ring for RBDUser. Default is"
                " /etc/ceph/keyring. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            )
        ),
    ] = None
    monitors: Annotated[
        List[str],
        Field(
            description=(
                "monitors is a collection of Ceph monitors. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            )
        ),
    ]
    pool: Annotated[
        Optional[str],
        Field(
            description=(
                "pool is the rados pool name. Default is rbd. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            )
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly here will force the ReadOnly setting in VolumeMounts."
                " Defaults to false. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            ),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=(
                "secretRef is name of the authentication secret for RBDUser. If"
                " provided overrides keyring. Default is nil. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            ),
        ),
    ] = None
    user: Annotated[
        Optional[str],
        Field(
            description=(
                "user is the rados user name. Default is admin. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
            )
        ),
    ] = None


class SELinuxOptions(BaseModel):
    level: Annotated[
        Optional[str],
        Field(description="Level is SELinux level label that applies to the container."),
    ] = None
    role: Annotated[
        Optional[str],
        Field(description="Role is a SELinux role label that applies to the container."),
    ] = None
    type: Annotated[
        Optional[str],
        Field(description="Type is a SELinux type label that applies to the container."),
    ] = None
    user: Annotated[
        Optional[str],
        Field(description="User is a SELinux user label that applies to the container."),
    ] = None


class ScaleIOVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Default is "xfs".'
            ),
        ),
    ] = None
    gateway: Annotated[
        str,
        Field(description="gateway is the host address of the ScaleIO API Gateway."),
    ]
    protection_domain: Annotated[
        Optional[str],
        Field(
            alias="protectionDomain",
            description=(
                "protectionDomain is the name of the ScaleIO Protection Domain for the" " configured storage."
            ),
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly Defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    secret_ref: Annotated[
        LocalObjectReference,
        Field(
            alias="secretRef",
            description=(
                "secretRef references to the secret for ScaleIO user and other"
                " sensitive information. If this is not provided, Login operation will"
                " fail."
            ),
        ),
    ]
    ssl_enabled: Annotated[
        Optional[bool],
        Field(
            alias="sslEnabled",
            description=("sslEnabled Flag enable/disable SSL communication with Gateway, default" " false"),
        ),
    ] = None
    storage_mode: Annotated[
        Optional[str],
        Field(
            alias="storageMode",
            description=(
                "storageMode indicates whether the storage for a volume should be"
                " ThickProvisioned or ThinProvisioned. Default is ThinProvisioned."
            ),
        ),
    ] = None
    storage_pool: Annotated[
        Optional[str],
        Field(
            alias="storagePool",
            description=("storagePool is the ScaleIO Storage Pool associated with the protection" " domain."),
        ),
    ] = None
    system: Annotated[
        str,
        Field(description=("system is the name of the storage system as configured in ScaleIO.")),
    ]
    volume_name: Annotated[
        Optional[str],
        Field(
            alias="volumeName",
            description=(
                "volumeName is the name of a volume already created in the ScaleIO"
                " system that is associated with this volume source."
            ),
        ),
    ] = None


class SeccompProfile(BaseModel):
    localhost_profile: Annotated[
        Optional[str],
        Field(
            alias="localhostProfile",
            description=(
                "localhostProfile indicates a profile defined in a file on the node"
                " should be used. The profile must be preconfigured on the node to"
                " work. Must be a descending path, relative to the kubelet's"
                " configured seccomp profile location. Must only be set if type is"
                ' "Localhost".'
            ),
        ),
    ] = None
    type: Annotated[
        str,
        Field(
            description=(
                "type indicates which kind of seccomp profile will be applied. Valid"
                " options are:\n\nLocalhost - a profile defined in a file on the node"
                " should be used. RuntimeDefault - the container runtime default"
                " profile should be used. Unconfined - no profile should be applied."
            )
        ),
    ]


class SecretEnvSource(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[Optional[bool], Field(description="Specify whether the Secret must be defined")] = None


class SecretKeySelector(BaseModel):
    key: Annotated[
        str,
        Field(description=("The key of the secret to select from.  Must be a valid secret key.")),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description="Specify whether the Secret or its key must be defined"),
    ] = None


class SecretProjection(BaseModel):
    items: Annotated[
        Optional[List[KeyToPath]],
        Field(
            description=(
                "items if unspecified, each key-value pair in the Data field of the"
                " referenced Secret will be projected into the volume as a file whose"
                " name is the key and content is the value. If specified, the listed"
                " keys will be projected into the specified paths, and unlisted keys"
                " will not be present. If a key is specified which is not present in"
                " the Secret, the volume setup will error unless it is marked optional."
                " Paths must be relative and may not contain the '..' path or start"
                " with '..'."
            )
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description=("optional field specify whether the Secret or its key must be defined")),
    ] = None


class SecretVolumeSource(BaseModel):
    default_mode: Annotated[
        Optional[int],
        Field(
            alias="defaultMode",
            description=(
                "defaultMode is Optional: mode bits used to set permissions on created"
                " files by default. Must be an octal value between 0000 and 0777 or a"
                " decimal value between 0 and 511. YAML accepts both octal and decimal"
                " values, JSON requires decimal values for mode bits. Defaults to 0644."
                " Directories within the path are not affected by this setting. This"
                " might be in conflict with other options that affect the file mode,"
                " like fsGroup, and the result can be other mode bits set."
            ),
        ),
    ] = None
    items: Annotated[
        Optional[List[KeyToPath]],
        Field(
            description=(
                "items If unspecified, each key-value pair in the Data field of the"
                " referenced Secret will be projected into the volume as a file whose"
                " name is the key and content is the value. If specified, the listed"
                " keys will be projected into the specified paths, and unlisted keys"
                " will not be present. If a key is specified which is not present in"
                " the Secret, the volume setup will error unless it is marked optional."
                " Paths must be relative and may not contain the '..' path or start"
                " with '..'."
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description=("optional field specify whether the Secret or its keys must be defined")),
    ] = None
    secret_name: Annotated[
        Optional[str],
        Field(
            alias="secretName",
            description=(
                "secretName is the name of the secret in the pod's namespace to use."
                " More info: https://kubernetes.io/docs/concepts/storage/volumes#secret"
            ),
        ),
    ] = None


class ServiceAccountTokenProjection(BaseModel):
    audience: Annotated[
        Optional[str],
        Field(
            description=(
                "audience is the intended audience of the token. A recipient of a token"
                " must identify itself with an identifier specified in the audience of"
                " the token, and otherwise should reject the token. The audience"
                " defaults to the identifier of the apiserver."
            )
        ),
    ] = None
    expiration_seconds: Annotated[
        Optional[int],
        Field(
            alias="expirationSeconds",
            description=(
                "expirationSeconds is the requested duration of validity of the service"
                " account token. As the token approaches expiration, the kubelet volume"
                " plugin will proactively rotate the service account token. The kubelet"
                " will start trying to rotate the token if the token is older than 80"
                " percent of its time to live or if the token is older than 24"
                " hours.Defaults to 1 hour and must be at least 10 minutes."
            ),
        ),
    ] = None
    path: Annotated[
        str,
        Field(description=("path is the path relative to the mount point of the file to project" " the token into.")),
    ]


class StorageOSVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=(
                "secretRef specifies the secret to use for obtaining the StorageOS API"
                " credentials.  If not specified, default values will be attempted."
            ),
        ),
    ] = None
    volume_name: Annotated[
        Optional[str],
        Field(
            alias="volumeName",
            description=(
                "volumeName is the human-readable name of the StorageOS volume.  Volume"
                " names are only unique within a namespace."
            ),
        ),
    ] = None
    volume_namespace: Annotated[
        Optional[str],
        Field(
            alias="volumeNamespace",
            description=(
                "volumeNamespace specifies the scope of the volume within StorageOS. "
                " If no namespace is specified then the Pod's namespace will be used. "
                " This allows the Kubernetes name scoping to be mirrored within"
                " StorageOS for tighter integration. Set VolumeName to any name to"
                ' override the default behaviour. Set to "default" if you are not using'
                " namespaces within StorageOS. Namespaces that do not pre-exist within"
                " StorageOS will be created."
            ),
        ),
    ] = None


class Sysctl(BaseModel):
    name: Annotated[str, Field(description="Name of a property to set")]
    value: Annotated[str, Field(description="Value of a property to set")]


class TCPSocketAction(BaseModel):
    host: Annotated[
        Optional[str],
        Field(description="Optional: Host name to connect to, defaults to the pod IP."),
    ] = None
    port: Annotated[
        intstr.IntOrString,
        Field(
            description=(
                "Number or name of the port to access on the container. Number must be"
                " in the range 1 to 65535. Name must be an IANA_SVC_NAME."
            )
        ),
    ]


class Time(BaseModel):
    time: Annotated[AwareDatetime, Field(alias="Time")]


class Toleration(BaseModel):
    effect: Annotated[
        Optional[str],
        Field(
            description=(
                "Effect indicates the taint effect to match. Empty means match all"
                " taint effects. When specified, allowed values are NoSchedule,"
                " PreferNoSchedule and NoExecute."
            )
        ),
    ] = None
    key: Annotated[
        Optional[str],
        Field(
            description=(
                "Key is the taint key that the toleration applies to. Empty means match"
                " all taint keys. If the key is empty, operator must be Exists; this"
                " combination means to match all values and all keys."
            )
        ),
    ] = None
    operator: Annotated[
        Optional[str],
        Field(
            description=(
                "Operator represents a key's relationship to the value. Valid operators"
                " are Exists and Equal. Defaults to Equal. Exists is equivalent to"
                " wildcard for value, so that a pod can tolerate all taints of a"
                " particular category."
            )
        ),
    ] = None
    toleration_seconds: Annotated[
        Optional[int],
        Field(
            alias="tolerationSeconds",
            description=(
                "TolerationSeconds represents the period of time the toleration (which"
                " must be of effect NoExecute, otherwise this field is ignored)"
                " tolerates the taint. By default, it is not set, which means tolerate"
                " the taint forever (do not evict). Zero and negative values will be"
                " treated as 0 (evict immediately) by the system."
            ),
        ),
    ] = None
    value: Annotated[
        Optional[str],
        Field(
            description=(
                "Value is the taint value the toleration matches to. If the operator is"
                " Exists, the value should be empty, otherwise just a regular string."
            )
        ),
    ] = None


class TypedLocalObjectReference(BaseModel):
    api_group: Annotated[
        str,
        Field(
            alias="apiGroup",
            description=(
                "APIGroup is the group for the resource being referenced. If APIGroup"
                " is not specified, the specified Kind must be in the core API group."
                " For any other third-party types, APIGroup is required."
            ),
        ),
    ]
    kind: Annotated[str, Field(description="Kind is the type of resource being referenced")]
    name: Annotated[str, Field(description="Name is the name of resource being referenced")]


class VolumeDevice(BaseModel):
    device_path: Annotated[
        str,
        Field(
            alias="devicePath",
            description=("devicePath is the path inside of the container that the device will be" " mapped to."),
        ),
    ]
    name: Annotated[
        str,
        Field(description="name must match the name of a persistentVolumeClaim in the pod"),
    ]


class VolumeMount(BaseModel):
    mount_path: Annotated[
        str,
        Field(
            alias="mountPath",
            description=("Path within the container at which the volume should be mounted.  Must" " not contain ':'."),
        ),
    ]
    mount_propagation: Annotated[
        Optional[str],
        Field(
            alias="mountPropagation",
            description=(
                "mountPropagation determines how mounts are propagated from the host to"
                " container and the other way around. When not set,"
                " MountPropagationNone is used. This field is beta in 1.10."
            ),
        ),
    ] = None
    name: Annotated[str, Field(description="This must match the Name of a Volume.")]
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "Mounted read-only if true, read-write otherwise (false or" " unspecified). Defaults to false."
            ),
        ),
    ] = None
    sub_path: Annotated[
        Optional[str],
        Field(
            alias="subPath",
            description=(
                "Path within the volume from which the container's volume should be"
                ' mounted. Defaults to "" (volume\'s root).'
            ),
        ),
    ] = None
    sub_path_expr: Annotated[
        Optional[str],
        Field(
            alias="subPathExpr",
            description=(
                "Expanded path within the volume from which the container's volume"
                " should be mounted. Behaves similarly to SubPath but environment"
                " variable references $(VAR_NAME) are expanded using the container's"
                ' environment. Defaults to "" (volume\'s root). SubPathExpr and SubPath'
                " are mutually exclusive."
            ),
        ),
    ] = None


class VsphereVirtualDiskVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                ' Implicitly inferred to be "ext4" if unspecified.'
            ),
        ),
    ] = None
    storage_policy_id: Annotated[
        Optional[str],
        Field(
            alias="storagePolicyID",
            description=(
                "storagePolicyID is the storage Policy Based Management (SPBM) profile"
                " ID associated with the StoragePolicyName."
            ),
        ),
    ] = None
    storage_policy_name: Annotated[
        Optional[str],
        Field(
            alias="storagePolicyName",
            description=("storagePolicyName is the storage Policy Based Management (SPBM)" " profile name."),
        ),
    ] = None
    volume_path: Annotated[
        str,
        Field(
            alias="volumePath",
            description="volumePath is the path that identifies vSphere volume vmdk",
        ),
    ]


class WindowsSecurityContextOptions(BaseModel):
    gmsa_credential_spec: Annotated[
        Optional[str],
        Field(
            alias="gmsaCredentialSpec",
            description=(
                "GMSACredentialSpec is where the GMSA admission webhook"
                " (https://github.com/kubernetes-sigs/windows-gmsa) inlines the"
                " contents of the GMSA credential spec named by the"
                " GMSACredentialSpecName field."
            ),
        ),
    ] = None
    gmsa_credential_spec_name: Annotated[
        Optional[str],
        Field(
            alias="gmsaCredentialSpecName",
            description=("GMSACredentialSpecName is the name of the GMSA credential spec to use."),
        ),
    ] = None
    host_process: Annotated[
        Optional[bool],
        Field(
            alias="hostProcess",
            description=(
                "HostProcess determines if a container should be run as a 'Host"
                " Process' container. This field is alpha-level and will only be"
                " honored by components that enable the WindowsHostProcessContainers"
                " feature flag. Setting this field without the feature flag will result"
                " in errors when validating the Pod. All of a Pod's containers must"
                " have the same effective HostProcess value (it is not allowed to have"
                " a mix of HostProcess containers and non-HostProcess containers).  In"
                " addition, if HostProcess is true then HostNetwork must also be set to"
                " true."
            ),
        ),
    ] = None
    run_as_user_name: Annotated[
        Optional[str],
        Field(
            alias="runAsUserName",
            description=(
                "The UserName in Windows to run the entrypoint of the container"
                " process. Defaults to the user specified in image metadata if"
                " unspecified. May also be set in PodSecurityContext. If set in both"
                " SecurityContext and PodSecurityContext, the value specified in"
                " SecurityContext takes precedence."
            ),
        ),
    ] = None


class CSIVolumeSource(BaseModel):
    driver: Annotated[
        str,
        Field(
            description=(
                "driver is the name of the CSI driver that handles this volume. Consult"
                " with your admin for the correct name as registered in the cluster."
            )
        ),
    ]
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                'fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty'
                " value is passed to the associated CSI driver which will determine the"
                " default filesystem to apply."
            ),
        ),
    ] = None
    node_publish_secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="nodePublishSecretRef",
            description=(
                "nodePublishSecretRef is a reference to the secret object containing"
                " sensitive information to pass to the CSI driver to complete the CSI"
                " NodePublishVolume and NodeUnpublishVolume calls. This field is"
                " optional, and  may be empty if no secret is required. If the secret"
                " object contains more than one secret, all secret references are"
                " passed."
            ),
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly specifies a read-only configuration for the volume. Defaults" " to false (read/write)."
            ),
        ),
    ] = None
    volume_attributes: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="volumeAttributes",
            description=(
                "volumeAttributes stores driver-specific properties that are passed to"
                " the CSI driver. Consult your driver's documentation for supported"
                " values."
            ),
        ),
    ] = None


class CephFSVolumeSource(BaseModel):
    monitors: Annotated[
        List[str],
        Field(
            description=(
                "monitors is Required: Monitors is a collection of Ceph monitors More"
                " info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
            )
        ),
    ]
    path: Annotated[
        Optional[str],
        Field(
            description=("path is Optional: Used as the mounted root, rather than the full Ceph" " tree, default is /")
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly is Optional: Defaults to false (read/write). ReadOnly here"
                " will force the ReadOnly setting in VolumeMounts. More info:"
                " https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
            ),
        ),
    ] = None
    secret_file: Annotated[
        Optional[str],
        Field(
            alias="secretFile",
            description=(
                "secretFile is Optional: SecretFile is the path to key ring for User,"
                " default is /etc/ceph/user.secret More info:"
                " https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
            ),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=(
                "secretRef is Optional: SecretRef is reference to the authentication"
                " secret for User, default is empty. More info:"
                " https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
            ),
        ),
    ] = None
    user: Annotated[
        Optional[str],
        Field(
            description=(
                "user is optional: User is the rados user name, default is admin More"
                " info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
            )
        ),
    ] = None


class CinderVolumeSource(BaseModel):
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Examples: "ext4", "xfs",'
                ' "ntfs". Implicitly inferred to be "ext4" if unspecified. More info:'
                " https://examples.k8s.io/mysql-cinder-pd/README.md"
            ),
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly defaults to false (read/write). ReadOnly here will force the"
                " ReadOnly setting in VolumeMounts. More info:"
                " https://examples.k8s.io/mysql-cinder-pd/README.md"
            ),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=(
                "secretRef is optional: points to a secret object containing parameters"
                " used to connect to OpenStack."
            ),
        ),
    ] = None
    volume_id: Annotated[
        str,
        Field(
            alias="volumeID",
            description=(
                "volumeID used to identify the volume in cinder. More info:"
                " https://examples.k8s.io/mysql-cinder-pd/README.md"
            ),
        ),
    ]


class ConfigMapProjection(BaseModel):
    items: Annotated[
        Optional[List[KeyToPath]],
        Field(
            description=(
                "items if unspecified, each key-value pair in the Data field of the"
                " referenced ConfigMap will be projected into the volume as a file"
                " whose name is the key and content is the value. If specified, the"
                " listed keys will be projected into the specified paths, and unlisted"
                " keys will not be present. If a key is specified which is not present"
                " in the ConfigMap, the volume setup will error unless it is marked"
                " optional. Paths must be relative and may not contain the '..' path or"
                " start with '..'."
            )
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description=("optional specify whether the ConfigMap or its keys must be defined")),
    ] = None


class ConfigMapVolumeSource(BaseModel):
    default_mode: Annotated[
        Optional[int],
        Field(
            alias="defaultMode",
            description=(
                "defaultMode is optional: mode bits used to set permissions on created"
                " files by default. Must be an octal value between 0000 and 0777 or a"
                " decimal value between 0 and 511. YAML accepts both octal and decimal"
                " values, JSON requires decimal values for mode bits. Defaults to 0644."
                " Directories within the path are not affected by this setting. This"
                " might be in conflict with other options that affect the file mode,"
                " like fsGroup, and the result can be other mode bits set."
            ),
        ),
    ] = None
    items: Annotated[
        Optional[List[KeyToPath]],
        Field(
            description=(
                "items if unspecified, each key-value pair in the Data field of the"
                " referenced ConfigMap will be projected into the volume as a file"
                " whose name is the key and content is the value. If specified, the"
                " listed keys will be projected into the specified paths, and unlisted"
                " keys will not be present. If a key is specified which is not present"
                " in the ConfigMap, the volume setup will error unless it is marked"
                " optional. Paths must be relative and may not contain the '..' path or"
                " start with '..'."
            )
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name of the referent. More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ] = None
    optional: Annotated[
        Optional[bool],
        Field(description=("optional specify whether the ConfigMap or its keys must be defined")),
    ] = None


class EmptyDirVolumeSource(BaseModel):
    medium: Annotated[
        Optional[str],
        Field(
            description=(
                "medium represents what type of storage medium should back this"
                ' directory. The default is "" which means to use the node\'s default'
                " medium. Must be an empty string (default) or Memory. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#emptydir"
            )
        ),
    ] = None
    size_limit: Annotated[
        Optional[resource.Quantity],
        Field(
            alias="sizeLimit",
            description=(
                "sizeLimit is the total amount of local storage required for this"
                " EmptyDir volume. The size limit is also applicable for memory medium."
                " The maximum usage on memory medium EmptyDir would be the minimum"
                " value between the SizeLimit specified here and the sum of memory"
                " limits of all containers in a pod. The default is nil which means"
                " that the limit is undefined. More info:"
                " http://kubernetes.io/docs/user-guide/volumes#emptydir"
            ),
        ),
    ] = None


class EnvFromSource(BaseModel):
    config_map_ref: Annotated[
        Optional[ConfigMapEnvSource],
        Field(alias="configMapRef", description="The ConfigMap to select from"),
    ] = None
    prefix: Annotated[
        Optional[str],
        Field(
            description=("An optional identifier to prepend to each key in the ConfigMap. Must" " be a C_IDENTIFIER.")
        ),
    ] = None
    secret_ref: Annotated[
        Optional[SecretEnvSource],
        Field(alias="secretRef", description="The Secret to select from"),
    ] = None


class FlexVolumeSource(BaseModel):
    driver: Annotated[
        str,
        Field(description="driver is the name of the driver to use for this volume."),
    ]
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type to mount. Must be a filesystem type"
                ' supported by the host operating system. Ex. "ext4", "xfs", "ntfs".'
                " The default filesystem depends on FlexVolume script."
            ),
        ),
    ] = None
    options: Annotated[
        Optional[Dict[str, str]],
        Field(description=("options is Optional: this field holds extra command options if any.")),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=(
                "readOnly is Optional: defaults to false (read/write). ReadOnly here"
                " will force the ReadOnly setting in VolumeMounts."
            ),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=(
                "secretRef is Optional: secretRef is reference to the secret object"
                " containing sensitive information to pass to the plugin scripts. This"
                " may be empty if no secret object is specified. If the secret object"
                " contains more than one secret, all secrets are passed to the plugin"
                " scripts."
            ),
        ),
    ] = None


class HTTPGetAction(BaseModel):
    host: Annotated[
        Optional[str],
        Field(
            description=(
                "Host name to connect to, defaults to the pod IP. You probably want to"
                ' set "Host" in httpHeaders instead.'
            )
        ),
    ] = None
    http_headers: Annotated[
        Optional[List[HTTPHeader]],
        Field(
            alias="httpHeaders",
            description=("Custom headers to set in the request. HTTP allows repeated headers."),
        ),
    ] = None
    path: Annotated[Optional[str], Field(description="Path to access on the HTTP server.")] = None
    port: Annotated[
        intstr.IntOrString,
        Field(
            description=(
                "Name or number of the port to access on the container. Number must be"
                " in the range 1 to 65535. Name must be an IANA_SVC_NAME."
            )
        ),
    ]
    scheme: Annotated[
        Optional[str],
        Field(description="Scheme to use for connecting to the host. Defaults to HTTP."),
    ] = None


class ISCSIVolumeSource(BaseModel):
    chap_auth_discovery: Annotated[
        Optional[bool],
        Field(
            alias="chapAuthDiscovery",
            description=("chapAuthDiscovery defines whether support iSCSI Discovery CHAP" " authentication"),
        ),
    ] = None
    chap_auth_session: Annotated[
        Optional[bool],
        Field(
            alias="chapAuthSession",
            description=("chapAuthSession defines whether support iSCSI Session CHAP" " authentication"),
        ),
    ] = None
    fs_type: Annotated[
        Optional[str],
        Field(
            alias="fsType",
            description=(
                "fsType is the filesystem type of the volume that you want to mount."
                " Tip: Ensure that the filesystem type is supported by the host"
                ' operating system. Examples: "ext4", "xfs", "ntfs". Implicitly'
                ' inferred to be "ext4" if unspecified. More info:'
                " https://kubernetes.io/docs/concepts/storage/volumes#iscsi"
            ),
        ),
    ] = None
    initiator_name: Annotated[
        Optional[str],
        Field(
            alias="initiatorName",
            description=(
                "initiatorName is the custom iSCSI Initiator Name. If initiatorName is"
                " specified with iscsiInterface simultaneously, new iSCSI interface"
                " <target portal>:<volume name> will be created for the connection."
            ),
        ),
    ] = None
    iqn: Annotated[str, Field(description="iqn is the target iSCSI Qualified Name.")]
    iscsi_interface: Annotated[
        Optional[str],
        Field(
            alias="iscsiInterface",
            description=(
                "iscsiInterface is the interface Name that uses an iSCSI transport." " Defaults to 'default' (tcp)."
            ),
        ),
    ] = None
    lun: Annotated[int, Field(description="lun represents iSCSI Target Lun number.")]
    portals: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "portals is the iSCSI Target Portal List. The portal is either an IP or"
                " ip_addr:port if the port is other than default (typically TCP ports"
                " 860 and 3260)."
            )
        ),
    ] = None
    read_only: Annotated[
        Optional[bool],
        Field(
            alias="readOnly",
            description=("readOnly here will force the ReadOnly setting in VolumeMounts." " Defaults to false."),
        ),
    ] = None
    secret_ref: Annotated[
        Optional[LocalObjectReference],
        Field(
            alias="secretRef",
            description=("secretRef is the CHAP Secret for iSCSI target and initiator" " authentication"),
        ),
    ] = None
    target_portal: Annotated[
        str,
        Field(
            alias="targetPortal",
            description=(
                "targetPortal is iSCSI Target Portal. The Portal is either an IP or"
                " ip_addr:port if the port is other than default (typically TCP ports"
                " 860 and 3260)."
            ),
        ),
    ]


class LabelSelector(BaseModel):
    match_expressions: Annotated[
        Optional[List[LabelSelectorRequirement]],
        Field(
            alias="matchExpressions",
            description=("matchExpressions is a list of label selector requirements. The" " requirements are ANDed."),
        ),
    ] = None
    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description=(
                "matchLabels is a map of {key,value} pairs. A single {key,value} in the"
                " matchLabels map is equivalent to an element of matchExpressions,"
                ' whose key field is "key", the operator is "In", and the values array'
                ' contains only "value". The requirements are ANDed.'
            ),
        ),
    ] = None


class LifecycleHandler(BaseModel):
    exec: Annotated[Optional[ExecAction], Field(description="Exec specifies the action to take.")] = None
    http_get: Annotated[
        Optional[HTTPGetAction],
        Field(
            alias="httpGet",
            description="HTTPGet specifies the http request to perform.",
        ),
    ] = None
    tcp_socket: Annotated[
        Optional[TCPSocketAction],
        Field(
            alias="tcpSocket",
            description=(
                "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept"
                " for the backward compatibility. There are no validation of this field"
                " and lifecycle hooks will fail in runtime when tcp handler is"
                " specified."
            ),
        ),
    ] = None


class ManagedFieldsEntry(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the version of this resource that this field set"
                ' applies to. The format is "group/version" just like the top-level'
                " APIVersion field. It is necessary to track the version of a field set"
                " because it cannot be automatically converted."
            ),
        ),
    ] = None
    fields_type: Annotated[
        Optional[str],
        Field(
            alias="fieldsType",
            description=(
                "FieldsType is the discriminator for the different fields format and"
                ' version. There is currently only one possible value: "FieldsV1"'
            ),
        ),
    ] = None
    fields_v1: Annotated[
        Optional[FieldsV1],
        Field(
            alias="fieldsV1",
            description=("FieldsV1 holds the first JSON version format as described in the" ' "FieldsV1" type.'),
        ),
    ] = None
    manager: Annotated[
        Optional[str],
        Field(description=("Manager is an identifier of the workflow managing these fields.")),
    ] = None
    operation: Annotated[
        Optional[str],
        Field(
            description=(
                "Operation is the type of operation which lead to this"
                " ManagedFieldsEntry being created. The only valid values for this"
                " field are 'Apply' and 'Update'."
            )
        ),
    ] = None
    subresource: Annotated[
        Optional[str],
        Field(
            description=(
                "Subresource is the name of the subresource used to update that object,"
                " or empty string if the object was updated through the main resource."
                " The value of this field is used to distinguish between managers, even"
                " if they share the same name. For example, a status update will be"
                " distinct from a regular update using the same manager name. Note that"
                " the APIVersion field is not related to the Subresource field and it"
                " always corresponds to the version of the main resource."
            )
        ),
    ] = None
    time: Annotated[
        Optional[Time],
        Field(
            description=(
                "Time is the timestamp of when the ManagedFields entry was added. The"
                " timestamp will also be updated if a field is added, the manager"
                " changes any of the owned fields value or removes a field. The"
                " timestamp does not update when a field is removed from the entry"
                " because another manager took it over."
            )
        ),
    ] = None


class NodeSelector(BaseModel):
    node_selector_terms: Annotated[
        List[NodeSelectorTerm],
        Field(
            alias="nodeSelectorTerms",
            description="Required. A list of node selector terms. The terms are ORed.",
        ),
    ]


class ObjectMeta(BaseModel):
    annotations: Annotated[
        Optional[Dict[str, str]],
        Field(
            description=(
                "Annotations is an unstructured key value map stored with a resource"
                " that may be set by external tools to store and retrieve arbitrary"
                " metadata. They are not queryable and should be preserved when"
                " modifying objects. More info:"
                " http://kubernetes.io/docs/user-guide/annotations"
            )
        ),
    ] = None
    cluster_name: Annotated[
        Optional[str],
        Field(
            alias="clusterName",
            description=(
                "Deprecated: ClusterName is a legacy field that was always cleared by"
                " the system and never used; it will be removed completely in"
                " 1.25.\n\nThe name in the go struct is changed to help clients detect"
                " accidental use."
            ),
        ),
    ] = None
    creation_timestamp: Annotated[
        Optional[Time],
        Field(
            alias="creationTimestamp",
            description=(
                "CreationTimestamp is a timestamp representing the server time when"
                " this object was created. It is not guaranteed to be set in"
                " happens-before order across separate operations. Clients may not set"
                " this value. It is represented in RFC3339 form and is in"
                " UTC.\n\nPopulated by the system. Read-only. Null for lists. More"
                " info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"
            ),
        ),
    ] = None
    deletion_grace_period_seconds: Annotated[
        Optional[int],
        Field(
            alias="deletionGracePeriodSeconds",
            description=(
                "Number of seconds allowed for this object to gracefully terminate"
                " before it will be removed from the system. Only set when"
                " deletionTimestamp is also set. May only be shortened. Read-only."
            ),
        ),
    ] = None
    deletion_timestamp: Annotated[
        Optional[Time],
        Field(
            alias="deletionTimestamp",
            description=(
                "DeletionTimestamp is RFC 3339 date and time at which this resource"
                " will be deleted. This field is set by the server when a graceful"
                " deletion is requested by the user, and is not directly settable by a"
                " client. The resource is expected to be deleted (no longer visible"
                " from resource lists, and not reachable by name) after the time in"
                " this field, once the finalizers list is empty. As long as the"
                " finalizers list contains items, deletion is blocked. Once the"
                " deletionTimestamp is set, this value may not be unset or be set"
                " further into the future, although it may be shortened or the resource"
                " may be deleted prior to this time. For example, a user may request"
                " that a pod is deleted in 30 seconds. The Kubelet will react by"
                " sending a graceful termination signal to the containers in the pod."
                " After that 30 seconds, the Kubelet will send a hard termination"
                " signal (SIGKILL) to the container and after cleanup, remove the pod"
                " from the API. In the presence of network partitions, this object may"
                " still exist after this timestamp, until an administrator or automated"
                " process can determine the resource is fully terminated. If not set,"
                " graceful deletion of the object has not been requested.\n\nPopulated"
                " by the system when a graceful deletion is requested. Read-only. More"
                " info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"
            ),
        ),
    ] = None
    finalizers: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Must be empty before the object is deleted from the registry. Each"
                " entry is an identifier for the responsible component that will remove"
                " the entry from the list. If the deletionTimestamp of the object is"
                " non-nil, entries in this list can only be removed. Finalizers may be"
                " processed and removed in any order.  Order is NOT enforced because it"
                " introduces significant risk of stuck finalizers. finalizers is a"
                " shared field, any actor with permission can reorder it. If the"
                " finalizer list is processed in order, then this can lead to a"
                " situation in which the component responsible for the first finalizer"
                " in the list is waiting for a signal (field value, external system, or"
                " other) produced by a component responsible for a finalizer later in"
                " the list, resulting in a deadlock. Without enforced ordering"
                " finalizers are free to order amongst themselves and are not"
                " vulnerable to ordering changes in the list."
            )
        ),
    ] = None
    generate_name: Annotated[
        Optional[str],
        Field(
            alias="generateName",
            description=(
                "GenerateName is an optional prefix, used by the server, to generate a"
                " unique name ONLY IF the Name field has not been provided. If this"
                " field is used, the name returned to the client will be different than"
                " the name passed. This value will also be combined with a unique"
                " suffix. The provided value has the same validation rules as the Name"
                " field, and may be truncated by the length of the suffix required to"
                " make the value unique on the server.\n\nIf this field is specified"
                " and the generated name exists, the server will return a"
                " 409.\n\nApplied only if Name is not specified. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"
            ),
        ),
    ] = None
    generation: Annotated[
        Optional[int],
        Field(
            description=(
                "A sequence number representing a specific generation of the desired"
                " state. Populated by the system. Read-only."
            )
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            description=(
                "Map of string keys and values that can be used to organize and"
                " categorize (scope and select) objects. May match selectors of"
                " replication controllers and services. More info:"
                " http://kubernetes.io/docs/user-guide/labels"
            )
        ),
    ] = None
    managed_fields: Annotated[
        Optional[List[ManagedFieldsEntry]],
        Field(
            alias="managedFields",
            description=(
                "ManagedFields maps workflow-id and version to the set of fields that"
                " are managed by that workflow. This is mostly for internal"
                " housekeeping, and users typically shouldn't need to set or"
                " understand this field. A workflow can be the user's name, a"
                " controller's name, or the name of a specific apply path like"
                ' "ci-cd". The set of fields is always in the version that the workflow'
                " used when modifying the object."
            ),
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description=(
                "Name must be unique within a namespace. Is required when creating"
                " resources, although some resources may allow a client to request the"
                " generation of an appropriate name automatically. Name is primarily"
                " intended for creation idempotence and configuration definition."
                " Cannot be updated. More info:"
                " http://kubernetes.io/docs/user-guide/identifiers#names"
            )
        ),
    ] = None
    namespace: Annotated[
        Optional[str],
        Field(
            description=(
                "Namespace defines the space within which each name must be unique. An"
                ' empty namespace is equivalent to the "default" namespace, but'
                ' "default" is the canonical representation. Not all objects are'
                " required to be scoped to a namespace - the value of this field for"
                " those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be"
                " updated. More info: http://kubernetes.io/docs/user-guide/namespaces"
            )
        ),
    ] = None
    owner_references: Annotated[
        Optional[List[OwnerReference]],
        Field(
            alias="ownerReferences",
            description=(
                "List of objects depended by this object. If ALL objects in the list"
                " have been deleted, this object will be garbage collected. If this"
                " object is managed by a controller, then an entry in this list will"
                " point to this controller, with the controller field set to true."
                " There cannot be more than one managing controller."
            ),
        ),
    ] = None
    resource_version: Annotated[
        Optional[str],
        Field(
            alias="resourceVersion",
            description=(
                "An opaque value that represents the internal version of this object"
                " that can be used by clients to determine when objects have changed."
                " May be used for optimistic concurrency, change detection, and the"
                " watch operation on a resource or set of resources. Clients must treat"
                " these values as opaque and passed unmodified back to the server. They"
                " may only be valid for a particular resource or set of"
                " resources.\n\nPopulated by the system. Read-only. Value must be"
                " treated as opaque by clients and . More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
            ),
        ),
    ] = None
    self_link: Annotated[
        Optional[str],
        Field(
            alias="selfLink",
            description=(
                "Deprecated: selfLink is a legacy read-only field that is no longer" " populated by the system."
            ),
        ),
    ] = None
    uid: Annotated[
        Optional[str],
        Field(
            description=(
                "UID is the unique in time and space value for this object. It is"
                " typically generated by the server on successful creation of a"
                " resource and is not allowed to change on PUT operations.\n\nPopulated"
                " by the system. Read-only. More info:"
                " http://kubernetes.io/docs/user-guide/identifiers#uids"
            )
        ),
    ] = None


class PersistentVolumeClaimCondition(BaseModel):
    last_probe_time: Annotated[
        Optional[Time],
        Field(
            alias="lastProbeTime",
            description="lastProbeTime is the time we probed the condition.",
        ),
    ] = None
    last_transition_time: Annotated[
        Optional[Time],
        Field(
            alias="lastTransitionTime",
            description=("lastTransitionTime is the time the condition transitioned from one" " status to another."),
        ),
    ] = None
    message: Annotated[
        Optional[str],
        Field(description=("message is the human-readable message indicating details about last" " transition.")),
    ] = None
    reason: Annotated[
        Optional[str],
        Field(
            description=(
                "reason is a unique, this should be a short, machine understandable"
                " string that gives the reason for condition's last transition. If it"
                ' reports "ResizeStarted" that means the underlying persistent volume'
                " is being resized."
            )
        ),
    ] = None
    status: str
    type: str


class PersistentVolumeClaimStatus(BaseModel):
    access_modes: Annotated[
        Optional[List[str]],
        Field(
            alias="accessModes",
            description=(
                "accessModes contains the actual access modes the volume backing the"
                " PVC has. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1"
            ),
        ),
    ] = None
    allocated_resources: Annotated[
        Optional[Dict[str, resource.Quantity]],
        Field(
            alias="allocatedResources",
            description=(
                "allocatedResources is the storage resource within AllocatedResources"
                " tracks the capacity allocated to a PVC. It may be larger than the"
                " actual capacity when a volume expansion operation is requested. For"
                " storage quota, the larger value from allocatedResources and"
                " PVC.spec.resources is used. If allocatedResources is not set,"
                " PVC.spec.resources alone is used for quota calculation. If a volume"
                " expansion capacity request is lowered, allocatedResources is only"
                " lowered if there are no expansion operations in progress and if the"
                " actual volume capacity is equal or lower than the requested capacity."
                " This is an alpha field and requires enabling"
                " RecoverVolumeExpansionFailure feature."
            ),
        ),
    ] = None
    capacity: Annotated[
        Optional[Dict[str, resource.Quantity]],
        Field(description=("capacity represents the actual resources of the underlying volume.")),
    ] = None
    conditions: Annotated[
        Optional[List[PersistentVolumeClaimCondition]],
        Field(
            description=(
                "conditions is the current Condition of persistent volume claim. If"
                " underlying persistent volume is being resized then the Condition will"
                " be set to 'ResizeStarted'."
            )
        ),
    ] = None
    phase: Annotated[
        Optional[str],
        Field(description="phase represents the current phase of PersistentVolumeClaim."),
    ] = None
    resize_status: Annotated[
        Optional[str],
        Field(
            alias="resizeStatus",
            description=(
                "resizeStatus stores status of resize operation. ResizeStatus is not"
                " set by default but when expansion is complete resizeStatus is set to"
                " empty string by resize controller or kubelet. This is an alpha field"
                " and requires enabling RecoverVolumeExpansionFailure feature."
            ),
        ),
    ] = None


class PodAffinityTerm(BaseModel):
    label_selector: Annotated[
        Optional[LabelSelector],
        Field(
            alias="labelSelector",
            description="A label query over a set of resources, in this case pods.",
        ),
    ] = None
    namespace_selector: Annotated[
        Optional[LabelSelector],
        Field(
            alias="namespaceSelector",
            description=(
                "A label query over the set of namespaces that the term applies to. The"
                " term is applied to the union of the namespaces selected by this field"
                " and the ones listed in the namespaces field. null selector and null"
                ' or empty namespaces list means "this pod\'s namespace". An empty'
                " selector ({}) matches all namespaces."
            ),
        ),
    ] = None
    namespaces: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "namespaces specifies a static list of namespace names that the term"
                " applies to. The term is applied to the union of the namespaces listed"
                " in this field and the ones selected by namespaceSelector. null or"
                " empty namespaces list and null namespaceSelector means \"this pod's"
                ' namespace".'
            )
        ),
    ] = None
    topology_key: Annotated[
        str,
        Field(
            alias="topologyKey",
            description=(
                "This pod should be co-located (affinity) or not co-located"
                " (anti-affinity) with the pods matching the labelSelector in the"
                " specified namespaces, where co-located is defined as running on a"
                " node whose value of the label with key topologyKey matches that of"
                " any node on which any of the selected pods is running. Empty"
                " topologyKey is not allowed."
            ),
        ),
    ]


class PodDNSConfig(BaseModel):
    nameservers: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "A list of DNS name server IP addresses. This will be appended to the"
                " base nameservers generated from DNSPolicy. Duplicated nameservers"
                " will be removed."
            )
        ),
    ] = None
    options: Annotated[
        Optional[List[PodDNSConfigOption]],
        Field(
            description=(
                "A list of DNS resolver options. This will be merged with the base"
                " options generated from DNSPolicy. Duplicated entries will be removed."
                " Resolution options given in Options will override those that appear"
                " in the base DNSPolicy."
            )
        ),
    ] = None
    searches: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "A list of DNS search domains for host-name lookup. This will be"
                " appended to the base search paths generated from DNSPolicy."
                " Duplicated search paths will be removed."
            )
        ),
    ] = None


class PodDisruptionBudgetSpec(BaseModel):
    max_unavailable: Annotated[
        Optional[intstr.IntOrString],
        Field(
            alias="maxUnavailable",
            description=(
                'An eviction is allowed if at most "maxUnavailable" pods selected by'
                ' "selector" are unavailable after the eviction, i.e. even in absence'
                " of the evicted pod. For example, one can prevent all voluntary"
                " evictions by specifying 0. This is a mutually exclusive setting with"
                ' "minAvailable".'
            ),
        ),
    ] = None
    min_available: Annotated[
        Optional[intstr.IntOrString],
        Field(
            alias="minAvailable",
            description=(
                'An eviction is allowed if at least "minAvailable" pods selected by'
                ' "selector" will still be available after the eviction, i.e. even in'
                " the absence of the evicted pod.  So for example you can prevent all"
                ' voluntary evictions by specifying "100%".'
            ),
        ),
    ] = None
    selector: Annotated[
        Optional[LabelSelector],
        Field(
            description=(
                "Label query over pods whose evictions are managed by the disruption"
                " budget. A null selector will match no pods, while an empty ({})"
                " selector will select all pods within the namespace."
            )
        ),
    ] = None


class PodSecurityContext(BaseModel):
    fs_group: Annotated[
        Optional[int],
        Field(
            alias="fsGroup",
            description=(
                "A special supplemental group that applies to all containers in a pod."
                " Some volume types allow the Kubelet to change the ownership of that"
                " volume to be owned by the pod:\n\n1. The owning GID will be the"
                " FSGroup 2. The setgid bit is set (new files created in the volume"
                " will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw "
            ),
        ),
    ] = None
    fs_group_change_policy: Annotated[
        Optional[str],
        Field(
            alias="fsGroupChangePolicy",
            description=(
                "fsGroupChangePolicy defines behavior of changing ownership and"
                " permission of the volume before being exposed inside Pod. This field"
                " will only apply to volume types which support fsGroup based"
                " ownership(and permissions). It will have no effect on ephemeral"
                " volume types such as: secret, configmaps and emptydir. Valid values"
                ' are "OnRootMismatch" and "Always". If not specified, "Always" is'
                " used. Note that this field cannot be set when spec.os.name is"
                " windows."
            ),
        ),
    ] = None
    run_as_group: Annotated[
        Optional[int],
        Field(
            alias="runAsGroup",
            description=(
                "The GID to run the entrypoint of the container process. Uses runtime"
                " default if unset. May also be set in SecurityContext.  If set in both"
                " SecurityContext and PodSecurityContext, the value specified in"
                " SecurityContext takes precedence for that container. Note that this"
                " field cannot be set when spec.os.name is windows."
            ),
        ),
    ] = None
    run_as_non_root: Annotated[
        Optional[bool],
        Field(
            alias="runAsNonRoot",
            description=(
                "Indicates that the container must run as a non-root user. If true, the"
                " Kubelet will validate the image at runtime to ensure that it does not"
                " run as UID 0 (root) and fail to start the container if it does. If"
                " unset or false, no such validation will be performed. May also be set"
                " in SecurityContext.  If set in both SecurityContext and"
                " PodSecurityContext, the value specified in SecurityContext takes"
                " precedence."
            ),
        ),
    ] = None
    run_as_user: Annotated[
        Optional[int],
        Field(
            alias="runAsUser",
            description=(
                "The UID to run the entrypoint of the container process. Defaults to"
                " user specified in image metadata if unspecified. May also be set in"
                " SecurityContext.  If set in both SecurityContext and"
                " PodSecurityContext, the value specified in SecurityContext takes"
                " precedence for that container. Note that this field cannot be set"
                " when spec.os.name is windows."
            ),
        ),
    ] = None
    se_linux_options: Annotated[
        Optional[SELinuxOptions],
        Field(
            alias="seLinuxOptions",
            description=(
                "The SELinux context to be applied to all containers. If unspecified,"
                " the container runtime will allocate a random SELinux context for each"
                " container.  May also be set in SecurityContext.  If set in both"
                " SecurityContext and PodSecurityContext, the value specified in"
                " SecurityContext takes precedence for that container. Note that this"
                " field cannot be set when spec.os.name is windows."
            ),
        ),
    ] = None
    seccomp_profile: Annotated[
        Optional[SeccompProfile],
        Field(
            alias="seccompProfile",
            description=(
                "The seccomp options to use by the containers in this pod. Note that"
                " this field cannot be set when spec.os.name is windows."
            ),
        ),
    ] = None
    supplemental_groups: Annotated[
        Optional[List[int]],
        Field(
            alias="supplementalGroups",
            description=(
                "A list of groups applied to the first process run in each container,"
                " in addition to the container's primary GID.  If unspecified, no"
                " groups will be added to any container. Note that this field cannot be"
                " set when spec.os.name is windows."
            ),
        ),
    ] = None
    sysctls: Annotated[
        Optional[List[Sysctl]],
        Field(
            description=(
                "Sysctls hold a list of namespaced sysctls used for the pod. Pods with"
                " unsupported sysctls (by the container runtime) might fail to launch."
                " Note that this field cannot be set when spec.os.name is windows."
            )
        ),
    ] = None
    windows_options: Annotated[
        Optional[WindowsSecurityContextOptions],
        Field(
            alias="windowsOptions",
            description=(
                "The Windows specific settings applied to all containers. If"
                " unspecified, the options within a container's SecurityContext will be"
                " used. If set in both SecurityContext and PodSecurityContext, the"
                " value specified in SecurityContext takes precedence. Note that this"
                " field cannot be set when spec.os.name is linux."
            ),
        ),
    ] = None


class Probe(BaseModel):
    exec: Annotated[Optional[ExecAction], Field(description="Exec specifies the action to take.")] = None
    failure_threshold: Annotated[
        Optional[int],
        Field(
            alias="failureThreshold",
            description=(
                "Minimum consecutive failures for the probe to be considered failed"
                " after having succeeded. Defaults to 3. Minimum value is 1."
            ),
        ),
    ] = None
    grpc: Annotated[
        Optional[GRPCAction],
        Field(
            description=(
                "GRPC specifies an action involving a GRPC port. This is a beta field"
                " and requires enabling GRPCContainerProbe feature gate."
            )
        ),
    ] = None
    http_get: Annotated[
        Optional[HTTPGetAction],
        Field(
            alias="httpGet",
            description="HTTPGet specifies the http request to perform.",
        ),
    ] = None
    initial_delay_seconds: Annotated[
        Optional[int],
        Field(
            alias="initialDelaySeconds",
            description=(
                "Number of seconds after the container has started before liveness"
                " probes are initiated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    period_seconds: Annotated[
        Optional[int],
        Field(
            alias="periodSeconds",
            description=("How often (in seconds) to perform the probe. Default to 10 seconds." " Minimum value is 1."),
        ),
    ] = None
    success_threshold: Annotated[
        Optional[int],
        Field(
            alias="successThreshold",
            description=(
                "Minimum consecutive successes for the probe to be considered"
                " successful after having failed. Defaults to 1. Must be 1 for liveness"
                " and startup. Minimum value is 1."
            ),
        ),
    ] = None
    tcp_socket: Annotated[
        Optional[TCPSocketAction],
        Field(
            alias="tcpSocket",
            description="TCPSocket specifies an action involving a TCP port.",
        ),
    ] = None
    termination_grace_period_seconds: Annotated[
        Optional[int],
        Field(
            alias="terminationGracePeriodSeconds",
            description=(
                "Optional duration in seconds the pod needs to terminate gracefully"
                " upon probe failure. The grace period is the duration in seconds after"
                " the processes running in the pod are sent a termination signal and"
                " the time when the processes are forcibly halted with a kill signal."
                " Set this value longer than the expected cleanup time for your"
                " process. If this value is nil, the pod's"
                " terminationGracePeriodSeconds will be used. Otherwise, this value"
                " overrides the value provided by the pod spec. Value must be"
                " non-negative integer. The value zero indicates stop immediately via"
                " the kill signal (no opportunity to shut down). This is a beta field"
                " and requires enabling ProbeTerminationGracePeriod feature gate."
                " Minimum value is 1. spec.terminationGracePeriodSeconds is used if"
                " unset."
            ),
        ),
    ] = None
    timeout_seconds: Annotated[
        Optional[int],
        Field(
            alias="timeoutSeconds",
            description=(
                "Number of seconds after which the probe times out. Defaults to 1"
                " second. Minimum value is 1. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None


class ResourceFieldSelector(BaseModel):
    container_name: Annotated[
        Optional[str],
        Field(
            alias="containerName",
            description="Container name: required for volumes, optional for env vars",
        ),
    ] = None
    divisor: Annotated[
        Optional[resource.Quantity],
        Field(description=('Specifies the output format of the exposed resources, defaults to "1"')),
    ] = None
    resource: Annotated[str, Field(description="Required: resource to select")]


class ResourceRequirements(BaseModel):
    limits: Annotated[
        Optional[Dict[str, resource.Quantity]],
        Field(
            description=(
                "Limits describes the maximum amount of compute resources allowed. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    requests: Annotated[
        Optional[Dict[str, resource.Quantity]],
        Field(
            description=(
                "Requests describes the minimum amount of compute resources required."
                " If Requests is omitted for a container, it defaults to Limits if that"
                " is explicitly specified, otherwise to an implementation-defined"
                " value. More info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None


class SecurityContext(BaseModel):
    allow_privilege_escalation: Annotated[
        Optional[bool],
        Field(
            alias="allowPrivilegeEscalation",
            description=(
                "AllowPrivilegeEscalation controls whether a process can gain more"
                " privileges than its parent process. This bool directly controls if"
                " the no_new_privs flag will be set on the container process."
                " AllowPrivilegeEscalation is true always when the container is: 1) run"
                " as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set"
                " when spec.os.name is windows."
            ),
        ),
    ] = None
    capabilities: Annotated[
        Optional[Capabilities],
        Field(
            description=(
                "The capabilities to add/drop when running containers. Defaults to the"
                " default set of capabilities granted by the container runtime. Note"
                " that this field cannot be set when spec.os.name is windows."
            )
        ),
    ] = None
    privileged: Annotated[
        Optional[bool],
        Field(
            description=(
                "Run container in privileged mode. Processes in privileged containers"
                " are essentially equivalent to root on the host. Defaults to false."
                " Note that this field cannot be set when spec.os.name is windows."
            )
        ),
    ] = None
    proc_mount: Annotated[
        Optional[str],
        Field(
            alias="procMount",
            description=(
                "procMount denotes the type of proc mount to use for the containers."
                " The default is DefaultProcMount which uses the container runtime"
                " defaults for readonly paths and masked paths. This requires the"
                " ProcMountType feature flag to be enabled. Note that this field cannot"
                " be set when spec.os.name is windows."
            ),
        ),
    ] = None
    read_only_root_filesystem: Annotated[
        Optional[bool],
        Field(
            alias="readOnlyRootFilesystem",
            description=(
                "Whether this container has a read-only root filesystem. Default is"
                " false. Note that this field cannot be set when spec.os.name is"
                " windows."
            ),
        ),
    ] = None
    run_as_group: Annotated[
        Optional[int],
        Field(
            alias="runAsGroup",
            description=(
                "The GID to run the entrypoint of the container process. Uses runtime"
                " default if unset. May also be set in PodSecurityContext.  If set in"
                " both SecurityContext and PodSecurityContext, the value specified in"
                " SecurityContext takes precedence. Note that this field cannot be set"
                " when spec.os.name is windows."
            ),
        ),
    ] = None
    run_as_non_root: Annotated[
        Optional[bool],
        Field(
            alias="runAsNonRoot",
            description=(
                "Indicates that the container must run as a non-root user. If true, the"
                " Kubelet will validate the image at runtime to ensure that it does not"
                " run as UID 0 (root) and fail to start the container if it does. If"
                " unset or false, no such validation will be performed. May also be set"
                " in PodSecurityContext.  If set in both SecurityContext and"
                " PodSecurityContext, the value specified in SecurityContext takes"
                " precedence."
            ),
        ),
    ] = None
    run_as_user: Annotated[
        Optional[int],
        Field(
            alias="runAsUser",
            description=(
                "The UID to run the entrypoint of the container process. Defaults to"
                " user specified in image metadata if unspecified. May also be set in"
                " PodSecurityContext.  If set in both SecurityContext and"
                " PodSecurityContext, the value specified in SecurityContext takes"
                " precedence. Note that this field cannot be set when spec.os.name is"
                " windows."
            ),
        ),
    ] = None
    se_linux_options: Annotated[
        Optional[SELinuxOptions],
        Field(
            alias="seLinuxOptions",
            description=(
                "The SELinux context to be applied to the container. If unspecified,"
                " the container runtime will allocate a random SELinux context for each"
                " container.  May also be set in PodSecurityContext.  If set in both"
                " SecurityContext and PodSecurityContext, the value specified in"
                " SecurityContext takes precedence. Note that this field cannot be set"
                " when spec.os.name is windows."
            ),
        ),
    ] = None
    seccomp_profile: Annotated[
        Optional[SeccompProfile],
        Field(
            alias="seccompProfile",
            description=(
                "The seccomp options to use by this container. If seccomp options are"
                " provided at both the pod & container level, the container options"
                " override the pod options. Note that this field cannot be set when"
                " spec.os.name is windows."
            ),
        ),
    ] = None
    windows_options: Annotated[
        Optional[WindowsSecurityContextOptions],
        Field(
            alias="windowsOptions",
            description=(
                "The Windows specific settings applied to all containers. If"
                " unspecified, the options from the PodSecurityContext will be used. If"
                " set in both SecurityContext and PodSecurityContext, the value"
                " specified in SecurityContext takes precedence. Note that this field"
                " cannot be set when spec.os.name is linux."
            ),
        ),
    ] = None


class WeightedPodAffinityTerm(BaseModel):
    pod_affinity_term: Annotated[
        PodAffinityTerm,
        Field(
            alias="podAffinityTerm",
            description=("Required. A pod affinity term, associated with the corresponding" " weight."),
        ),
    ]
    weight: Annotated[
        int,
        Field(
            description=("weight associated with matching the corresponding podAffinityTerm, in" " the range 1-100.")
        ),
    ]


class DownwardAPIVolumeFile(BaseModel):
    field_ref: Annotated[
        Optional[ObjectFieldSelector],
        Field(
            alias="fieldRef",
            description=(
                "Required: Selects a field of the pod: only annotations, labels, name" " and namespace are supported."
            ),
        ),
    ] = None
    mode: Annotated[
        Optional[int],
        Field(
            description=(
                "Optional: mode bits used to set permissions on this file, must be an"
                " octal value between 0000 and 0777 or a decimal value between 0 and"
                " 511. YAML accepts both octal and decimal values, JSON requires"
                " decimal values for mode bits. If not specified, the volume"
                " defaultMode will be used. This might be in conflict with other"
                " options that affect the file mode, like fsGroup, and the result can"
                " be other mode bits set."
            )
        ),
    ] = None
    path: Annotated[
        str,
        Field(
            description=(
                "Required: Path is  the relative path name of the file to be created."
                " Must not be absolute or contain the '..' path. Must be utf-8 encoded."
                " The first item of the relative path must not start with '..'"
            )
        ),
    ]
    resource_field_ref: Annotated[
        Optional[ResourceFieldSelector],
        Field(
            alias="resourceFieldRef",
            description=(
                "Selects a resource of the container: only resources limits and"
                " requests (limits.cpu, limits.memory, requests.cpu and"
                " requests.memory) are currently supported."
            ),
        ),
    ] = None


class DownwardAPIVolumeSource(BaseModel):
    default_mode: Annotated[
        Optional[int],
        Field(
            alias="defaultMode",
            description=(
                "Optional: mode bits to use on created files by default. Must be a"
                " Optional: mode bits used to set permissions on created files by"
                " default. Must be an octal value between 0000 and 0777 or a decimal"
                " value between 0 and 511. YAML accepts both octal and decimal values,"
                " JSON requires decimal values for mode bits. Defaults to 0644."
                " Directories within the path are not affected by this setting. This"
                " might be in conflict with other options that affect the file mode,"
                " like fsGroup, and the result can be other mode bits set."
            ),
        ),
    ] = None
    items: Annotated[
        Optional[List[DownwardAPIVolumeFile]],
        Field(description="Items is a list of downward API volume file"),
    ] = None


class EnvVarSource(BaseModel):
    config_map_key_ref: Annotated[
        Optional[ConfigMapKeySelector],
        Field(alias="configMapKeyRef", description="Selects a key of a ConfigMap."),
    ] = None
    field_ref: Annotated[
        Optional[ObjectFieldSelector],
        Field(
            alias="fieldRef",
            description=(
                "Selects a field of the pod: supports metadata.name,"
                " metadata.namespace, `metadata.labels['<KEY>']`,"
                " `metadata.annotations['<KEY>']`, spec.nodeName,"
                " spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs."
            ),
        ),
    ] = None
    resource_field_ref: Annotated[
        Optional[ResourceFieldSelector],
        Field(
            alias="resourceFieldRef",
            description=(
                "Selects a resource of the container: only resources limits and"
                " requests (limits.cpu, limits.memory, limits.ephemeral-storage,"
                " requests.cpu, requests.memory and requests.ephemeral-storage) are"
                " currently supported."
            ),
        ),
    ] = None
    secret_key_ref: Annotated[
        Optional[SecretKeySelector],
        Field(
            alias="secretKeyRef",
            description="Selects a key of a secret in the pod's namespace",
        ),
    ] = None


class Lifecycle(BaseModel):
    post_start: Annotated[
        Optional[LifecycleHandler],
        Field(
            alias="postStart",
            description=(
                "PostStart is called immediately after a container is created. If the"
                " handler fails, the container is terminated and restarted according to"
                " its restart policy. Other management of the container blocks until"
                " the hook completes. More info:"
                " https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks"
            ),
        ),
    ] = None
    pre_stop: Annotated[
        Optional[LifecycleHandler],
        Field(
            alias="preStop",
            description=(
                "PreStop is called immediately before a container is terminated due to"
                " an API request or management event such as liveness/startup probe"
                " failure, preemption, resource contention, etc. The handler is not"
                " called if the container crashes or exits. The Pod's termination grace"
                " period countdown begins before the PreStop hook is executed."
                " Regardless of the outcome of the handler, the container will"
                " eventually terminate within the Pod's termination grace period"
                " (unless delayed by finalizers). Other management of the container"
                " blocks until the hook completes or until the termination grace period"
                " is reached. More info:"
                " https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks"
            ),
        ),
    ] = None


class NodeAffinity(BaseModel):
    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredSchedulingTerm]],
        Field(
            alias="preferredDuringSchedulingIgnoredDuringExecution",
            description=(
                "The scheduler will prefer to schedule pods to nodes that satisfy the"
                " affinity expressions specified by this field, but it may choose a"
                " node that violates one or more of the expressions. The node that is"
                " most preferred is the one with the greatest sum of weights, i.e. for"
                " each node that meets all of the scheduling requirements (resource"
                " request, requiredDuringScheduling affinity expressions, etc.),"
                " compute a sum by iterating through the elements of this field and"
                ' adding "weight" to the sum if the node matches the corresponding'
                " matchExpressions; the node(s) with the highest sum are the most"
                " preferred."
            ),
        ),
    ] = None
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[NodeSelector],
        Field(
            alias="requiredDuringSchedulingIgnoredDuringExecution",
            description=(
                "If the affinity requirements specified by this field are not met at"
                " scheduling time, the pod will not be scheduled onto the node. If the"
                " affinity requirements specified by this field cease to be met at some"
                " point during pod execution (e.g. due to an update), the system may or"
                " may not try to eventually evict the pod from its node."
            ),
        ),
    ] = None


class PersistentVolumeClaimSpec(BaseModel):
    access_modes: Annotated[
        Optional[List[str]],
        Field(
            alias="accessModes",
            description=(
                "accessModes contains the desired access modes the volume should have."
                " More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1"
            ),
        ),
    ] = None
    data_source: Annotated[
        Optional[TypedLocalObjectReference],
        Field(
            alias="dataSource",
            description=(
                "dataSource field can be used to specify either: * An existing"
                " VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An"
                " existing PVC (PersistentVolumeClaim) If the provisioner or an"
                " external controller can support the specified data source, it will"
                " create a new volume based on the contents of the specified data"
                " source. If the AnyVolumeDataSource feature gate is enabled, this"
                " field will always have the same contents as the DataSourceRef field."
            ),
        ),
    ] = None
    data_source_ref: Annotated[
        Optional[TypedLocalObjectReference],
        Field(
            alias="dataSourceRef",
            description=(
                "dataSourceRef specifies the object from which to populate the volume"
                " with data, if a non-empty volume is desired. This may be any local"
                " object from a non-empty API group (non core object) or a"
                " PersistentVolumeClaim object. When this field is specified, volume"
                " binding will only succeed if the type of the specified object matches"
                " some installed volume populator or dynamic provisioner. This field"
                " will replace the functionality of the DataSource field and as such if"
                " both fields are non-empty, they must have the same value. For"
                " backwards compatibility, both fields (DataSource and DataSourceRef)"
                " will be set to the same value automatically if one of them is empty"
                " and the other is non-empty. There are two important differences"
                " between DataSource and DataSourceRef: * While DataSource only allows"
                " two specific types of objects, DataSourceRef\n  allows any non-core"
                " object, as well as PersistentVolumeClaim objects.\n* While DataSource"
                " ignores disallowed values (dropping them), DataSourceRef\n  preserves"
                " all values, and generates an error if a disallowed value is\n "
                " specified.\n(Beta) Using this field requires the AnyVolumeDataSource"
                " feature gate to be enabled."
            ),
        ),
    ] = None
    resources: Annotated[
        Optional[ResourceRequirements],
        Field(
            description=(
                "resources represents the minimum resources the volume should have. If"
                " RecoverVolumeExpansionFailure feature is enabled users are allowed to"
                " specify resource requirements that are lower than previous value but"
                " must still be higher than capacity recorded in the status field of"
                " the claim. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources"
            )
        ),
    ] = None
    selector: Annotated[
        Optional[LabelSelector],
        Field(description=("selector is a label query over volumes to consider for binding.")),
    ] = None
    storage_class_name: Annotated[
        Optional[str],
        Field(
            alias="storageClassName",
            description=(
                "storageClassName is the name of the StorageClass required by the"
                " claim. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1"
            ),
        ),
    ] = None
    volume_mode: Annotated[
        Optional[str],
        Field(
            alias="volumeMode",
            description=(
                "volumeMode defines what type of volume is required by the claim. Value"
                " of Filesystem is implied when not included in claim spec."
            ),
        ),
    ] = None
    volume_name: Annotated[
        Optional[str],
        Field(
            alias="volumeName",
            description=("volumeName is the binding reference to the PersistentVolume backing" " this claim."),
        ),
    ] = None


class PersistentVolumeClaimTemplate(BaseModel):
    metadata: Annotated[
        Optional[ObjectMeta],
        Field(
            description=(
                "May contain labels and annotations that will be copied into the PVC"
                " when creating it. No other fields are allowed and will be rejected"
                " during validation."
            )
        ),
    ] = None
    spec: Annotated[
        PersistentVolumeClaimSpec,
        Field(
            description=(
                "The specification for the PersistentVolumeClaim. The entire content is"
                " copied unchanged into the PVC that gets created from this template."
                " The same fields as in a PersistentVolumeClaim are also valid here."
            )
        ),
    ]


class PodAffinity(BaseModel):
    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[WeightedPodAffinityTerm]],
        Field(
            alias="preferredDuringSchedulingIgnoredDuringExecution",
            description=(
                "The scheduler will prefer to schedule pods to nodes that satisfy the"
                " affinity expressions specified by this field, but it may choose a"
                " node that violates one or more of the expressions. The node that is"
                " most preferred is the one with the greatest sum of weights, i.e. for"
                " each node that meets all of the scheduling requirements (resource"
                " request, requiredDuringScheduling affinity expressions, etc.),"
                " compute a sum by iterating through the elements of this field and"
                ' adding "weight" to the sum if the node has pods which matches the'
                " corresponding podAffinityTerm; the node(s) with the highest sum are"
                " the most preferred."
            ),
        ),
    ] = None
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PodAffinityTerm]],
        Field(
            alias="requiredDuringSchedulingIgnoredDuringExecution",
            description=(
                "If the affinity requirements specified by this field are not met at"
                " scheduling time, the pod will not be scheduled onto the node. If the"
                " affinity requirements specified by this field cease to be met at some"
                " point during pod execution (e.g. due to a pod label update), the"
                " system may or may not try to eventually evict the pod from its node."
                " When there are multiple elements, the lists of nodes corresponding to"
                " each podAffinityTerm are intersected, i.e. all terms must be"
                " satisfied."
            ),
        ),
    ] = None


class PodAntiAffinity(BaseModel):
    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[WeightedPodAffinityTerm]],
        Field(
            alias="preferredDuringSchedulingIgnoredDuringExecution",
            description=(
                "The scheduler will prefer to schedule pods to nodes that satisfy the"
                " anti-affinity expressions specified by this field, but it may choose"
                " a node that violates one or more of the expressions. The node that is"
                " most preferred is the one with the greatest sum of weights, i.e. for"
                " each node that meets all of the scheduling requirements (resource"
                " request, requiredDuringScheduling anti-affinity expressions, etc.),"
                " compute a sum by iterating through the elements of this field and"
                ' adding "weight" to the sum if the node has pods which matches the'
                " corresponding podAffinityTerm; the node(s) with the highest sum are"
                " the most preferred."
            ),
        ),
    ] = None
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PodAffinityTerm]],
        Field(
            alias="requiredDuringSchedulingIgnoredDuringExecution",
            description=(
                "If the anti-affinity requirements specified by this field are not met"
                " at scheduling time, the pod will not be scheduled onto the node. If"
                " the anti-affinity requirements specified by this field cease to be"
                " met at some point during pod execution (e.g. due to a pod label"
                " update), the system may or may not try to eventually evict the pod"
                " from its node. When there are multiple elements, the lists of nodes"
                " corresponding to each podAffinityTerm are intersected, i.e. all terms"
                " must be satisfied."
            ),
        ),
    ] = None


class Affinity(BaseModel):
    node_affinity: Annotated[
        Optional[NodeAffinity],
        Field(
            alias="nodeAffinity",
            description="Describes node affinity scheduling rules for the pod.",
        ),
    ] = None
    pod_affinity: Annotated[
        Optional[PodAffinity],
        Field(
            alias="podAffinity",
            description=(
                "Describes pod affinity scheduling rules (e.g. co-locate this pod in"
                " the same node, zone, etc. as some other pod(s))."
            ),
        ),
    ] = None
    pod_anti_affinity: Annotated[
        Optional[PodAntiAffinity],
        Field(
            alias="podAntiAffinity",
            description=(
                "Describes pod anti-affinity scheduling rules (e.g. avoid putting this"
                " pod in the same node, zone, etc. as some other pod(s))."
            ),
        ),
    ] = None


class DownwardAPIProjection(BaseModel):
    items: Annotated[
        Optional[List[DownwardAPIVolumeFile]],
        Field(description="Items is a list of DownwardAPIVolume file"),
    ] = None


class EnvVar(BaseModel):
    name: Annotated[
        str,
        Field(description="Name of the environment variable. Must be a C_IDENTIFIER."),
    ]
    value: Annotated[
        Optional[str],
        Field(
            description=(
                "Variable references $(VAR_NAME) are expanded using the previously"
                " defined environment variables in the container and any service"
                " environment variables. If a variable cannot be resolved, the"
                " reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                ' of whether the variable exists or not. Defaults to "".'
            )
        ),
    ] = None
    value_from: Annotated[
        Optional[EnvVarSource],
        Field(
            alias="valueFrom",
            description=("Source for the environment variable's value. Cannot be used if value" " is not empty."),
        ),
    ] = None


class EphemeralVolumeSource(BaseModel):
    volume_claim_template: Annotated[
        Optional[PersistentVolumeClaimTemplate],
        Field(
            alias="volumeClaimTemplate",
            description=(
                "Will be used to create a stand-alone PVC to provision the volume. The"
                " pod in which this EphemeralVolumeSource is embedded will be the owner"
                " of the PVC, i.e. the PVC will be deleted together with the pod.  The"
                " name of the PVC will be `<pod name>-<volume name>` where `<volume"
                " name>` is the name from the `PodSpec.Volumes` array entry. Pod"
                " validation will reject the pod if the concatenated name is not valid"
                " for a PVC (for example, too long).\n\nAn existing PVC with that name"
                " that is not owned by the pod will *not* be used for the pod to avoid"
                " using an unrelated volume by mistake. Starting the pod is then"
                " blocked until the unrelated PVC is removed. If such a pre-created PVC"
                " is meant to be used by the pod, the PVC has to updated with an owner"
                " reference to the pod once the pod exists. Normally this should not be"
                " necessary, but it may be useful when manually reconstructing a broken"
                " cluster.\n\nThis field is read-only and no changes will be made by"
                " Kubernetes to the PVC after it has been created.\n\nRequired, must"
                " not be nil."
            ),
        ),
    ] = None


class PersistentVolumeClaim(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: Annotated[
        Optional[ObjectMeta],
        Field(
            description=(
                "Standard object's metadata. More info:"
                " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"
            )
        ),
    ] = None
    spec: Annotated[
        Optional[PersistentVolumeClaimSpec],
        Field(
            description=(
                "spec defines the desired characteristics of a volume requested by a"
                " pod author. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
            )
        ),
    ] = None
    status: Annotated[
        Optional[PersistentVolumeClaimStatus],
        Field(
            description=(
                "status represents the current information/status of a persistent"
                " volume claim. Read-only. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
            )
        ),
    ] = None


class VolumeProjection(BaseModel):
    config_map: Annotated[
        Optional[ConfigMapProjection],
        Field(
            alias="configMap",
            description="configMap information about the configMap data to project",
        ),
    ] = None
    downward_api: Annotated[
        Optional[DownwardAPIProjection],
        Field(
            alias="downwardAPI",
            description="downwardAPI information about the downwardAPI data to project",
        ),
    ] = None
    secret: Annotated[
        Optional[SecretProjection],
        Field(description="secret information about the secret data to project"),
    ] = None
    service_account_token: Annotated[
        Optional[ServiceAccountTokenProjection],
        Field(
            alias="serviceAccountToken",
            description=("serviceAccountToken is information about the serviceAccountToken data" " to project"),
        ),
    ] = None


class Container(BaseModel):
    args: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        Optional[List[str]],
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    env: Annotated[
        Optional[List[EnvVar]],
        Field(description=("List of environment variables to set in the container. Cannot be" " updated.")),
    ] = None
    env_from: Annotated[
        Optional[List[EnvFromSource]],
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        Optional[str],
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        Optional[str],
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        Optional[Lifecycle],
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        Optional[Probe],
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        Optional[List[ContainerPort]],
        Field(
            description=(
                "List of ports to expose from the container. Exposing a port here gives"
                " the system additional information about the network connections a"
                " container uses, but is primarily informational. Not specifying a port"
                " here DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Cannot be updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        Optional[Probe],
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resources: Annotated[
        Optional[ResourceRequirements],
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    security_context: Annotated[
        Optional[SecurityContext],
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    startup_probe: Annotated[
        Optional[Probe],
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        Optional[bool],
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        Optional[str],
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        Optional[bool],
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        Optional[List[VolumeDevice]],
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the" " container."),
        ),
    ] = None
    volume_mounts: Annotated[
        Optional[List[VolumeMount]],
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be" " updated."),
        ),
    ] = None
    working_dir: Annotated[
        Optional[str],
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class ProjectedVolumeSource(BaseModel):
    default_mode: Annotated[
        Optional[int],
        Field(
            alias="defaultMode",
            description=(
                "defaultMode are the mode bits used to set permissions on created files"
                " by default. Must be an octal value between 0000 and 0777 or a decimal"
                " value between 0 and 511. YAML accepts both octal and decimal values,"
                " JSON requires decimal values for mode bits. Directories within the"
                " path are not affected by this setting. This might be in conflict with"
                " other options that affect the file mode, like fsGroup, and the result"
                " can be other mode bits set."
            ),
        ),
    ] = None
    sources: Annotated[
        List[VolumeProjection],
        Field(description="sources is the list of volume projections"),
    ]


class Volume(BaseModel):
    aws_elastic_block_store: Annotated[
        Optional[AWSElasticBlockStoreVolumeSource],
        Field(
            alias="awsElasticBlockStore",
            description=(
                "awsElasticBlockStore represents an AWS Disk resource that is attached"
                " to a kubelet's host machine and then exposed to the pod. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
            ),
        ),
    ] = None
    azure_disk: Annotated[
        Optional[AzureDiskVolumeSource],
        Field(
            alias="azureDisk",
            description=("azureDisk represents an Azure Data Disk mount on the host and bind" " mount to the pod."),
        ),
    ] = None
    azure_file: Annotated[
        Optional[AzureFileVolumeSource],
        Field(
            alias="azureFile",
            description=("azureFile represents an Azure File Service mount on the host and bind" " mount to the pod."),
        ),
    ] = None
    cephfs: Annotated[
        Optional[CephFSVolumeSource],
        Field(description=("cephFS represents a Ceph FS mount on the host that shares a pod's" " lifetime")),
    ] = None
    cinder: Annotated[
        Optional[CinderVolumeSource],
        Field(
            description=(
                "cinder represents a cinder volume attached and mounted on kubelets"
                " host machine. More info:"
                " https://examples.k8s.io/mysql-cinder-pd/README.md"
            )
        ),
    ] = None
    config_map: Annotated[
        Optional[ConfigMapVolumeSource],
        Field(
            alias="configMap",
            description=("configMap represents a configMap that should populate this volume"),
        ),
    ] = None
    csi: Annotated[
        Optional[CSIVolumeSource],
        Field(
            description=(
                "csi (Container Storage Interface) represents ephemeral storage that is"
                " handled by certain external CSI drivers (Beta feature)."
            )
        ),
    ] = None
    downward_api: Annotated[
        Optional[DownwardAPIVolumeSource],
        Field(
            alias="downwardAPI",
            description=("downwardAPI represents downward API about the pod that should populate" " this volume"),
        ),
    ] = None
    empty_dir: Annotated[
        Optional[EmptyDirVolumeSource],
        Field(
            alias="emptyDir",
            description=(
                "emptyDir represents a temporary directory that shares a pod's"
                " lifetime. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#emptydir"
            ),
        ),
    ] = None
    ephemeral: Annotated[
        Optional[EphemeralVolumeSource],
        Field(
            description=(
                "ephemeral represents a volume that is handled by a cluster storage"
                " driver. The volume's lifecycle is tied to the pod that defines it -"
                " it will be created before the pod starts, and deleted when the pod is"
                " removed.\n\nUse this if: a) the volume is only needed while the pod"
                " runs, b) features of normal volumes like restoring from snapshot or"
                " capacity\n   tracking are needed,\nc) the storage driver is specified"
                " through a storage class, and d) the storage driver supports dynamic"
                " volume provisioning through\n   a PersistentVolumeClaim (see"
                " EphemeralVolumeSource for more\n   information on the connection"
                " between this volume type\n   and PersistentVolumeClaim).\n\nUse"
                " PersistentVolumeClaim or one of the vendor-specific APIs for volumes"
                " that persist for longer than the lifecycle of an individual"
                " pod.\n\nUse CSI for light-weight local ephemeral volumes if the CSI"
                " driver is meant to be used that way - see the documentation of the"
                " driver for more information.\n\nA pod can use both types of ephemeral"
                " volumes and persistent volumes at the same time."
            )
        ),
    ] = None
    fc: Annotated[
        Optional[FCVolumeSource],
        Field(
            description=(
                "fc represents a Fibre Channel resource that is attached to a kubelet's"
                " host machine and then exposed to the pod."
            )
        ),
    ] = None
    flex_volume: Annotated[
        Optional[FlexVolumeSource],
        Field(
            alias="flexVolume",
            description=(
                "flexVolume represents a generic volume resource that is"
                " provisioned/attached using an exec based plugin."
            ),
        ),
    ] = None
    flocker: Annotated[
        Optional[FlockerVolumeSource],
        Field(
            description=(
                "flocker represents a Flocker volume attached to a kubelet's host"
                " machine. This depends on the Flocker control service being running"
            )
        ),
    ] = None
    gce_persistent_disk: Annotated[
        Optional[GCEPersistentDiskVolumeSource],
        Field(
            alias="gcePersistentDisk",
            description=(
                "gcePersistentDisk represents a GCE Disk resource that is attached to a"
                " kubelet's host machine and then exposed to the pod. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
            ),
        ),
    ] = None
    git_repo: Annotated[
        Optional[GitRepoVolumeSource],
        Field(
            alias="gitRepo",
            description=(
                "gitRepo represents a git repository at a particular revision."
                " DEPRECATED: GitRepo is deprecated. To provision a container with a"
                " git repo, mount an EmptyDir into an InitContainer that clones the"
                " repo using git, then mount the EmptyDir into the Pod's container."
            ),
        ),
    ] = None
    glusterfs: Annotated[
        Optional[GlusterfsVolumeSource],
        Field(
            description=(
                "glusterfs represents a Glusterfs mount on the host that shares a pod's"
                " lifetime. More info:"
                " https://examples.k8s.io/volumes/glusterfs/README.md"
            )
        ),
    ] = None
    host_path: Annotated[
        Optional[HostPathVolumeSource],
        Field(
            alias="hostPath",
            description=(
                "hostPath represents a pre-existing file or directory on the host"
                " machine that is directly exposed to the container. This is generally"
                " used for system agents or other privileged things that are allowed to"
                " see the host machine. Most containers will NOT need this. More info:"
                " https://kubernetes.io/docs/concepts/storage/volumes#hostpath"
            ),
        ),
    ] = None
    iscsi: Annotated[
        Optional[ISCSIVolumeSource],
        Field(
            description=(
                "iscsi represents an ISCSI Disk resource that is attached to a"
                " kubelet's host machine and then exposed to the pod. More info:"
                " https://examples.k8s.io/volumes/iscsi/README.md"
            )
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "name of the volume. Must be a DNS_LABEL and unique within the pod."
                " More info:"
                " https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
            )
        ),
    ]
    nfs: Annotated[
        Optional[NFSVolumeSource],
        Field(
            description=(
                "nfs represents an NFS mount on the host that shares a pod's lifetime"
                " More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs"
            )
        ),
    ] = None
    persistent_volume_claim: Annotated[
        Optional[PersistentVolumeClaimVolumeSource],
        Field(
            alias="persistentVolumeClaim",
            description=(
                "persistentVolumeClaimVolumeSource represents a reference to a"
                " PersistentVolumeClaim in the same namespace. More info:"
                " https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
            ),
        ),
    ] = None
    photon_persistent_disk: Annotated[
        Optional[PhotonPersistentDiskVolumeSource],
        Field(
            alias="photonPersistentDisk",
            description=(
                "photonPersistentDisk represents a PhotonController persistent disk"
                " attached and mounted on kubelets host machine"
            ),
        ),
    ] = None
    portworx_volume: Annotated[
        Optional[PortworxVolumeSource],
        Field(
            alias="portworxVolume",
            description=(
                "portworxVolume represents a portworx volume attached and mounted on" " kubelets host machine"
            ),
        ),
    ] = None
    projected: Annotated[
        Optional[ProjectedVolumeSource],
        Field(description=("projected items for all in one resources secrets, configmaps, and" " downward API")),
    ] = None
    quobyte: Annotated[
        Optional[QuobyteVolumeSource],
        Field(description=("quobyte represents a Quobyte mount on the host that shares a pod's" " lifetime")),
    ] = None
    rbd: Annotated[
        Optional[RBDVolumeSource],
        Field(
            description=(
                "rbd represents a Rados Block Device mount on the host that shares a"
                " pod's lifetime. More info:"
                " https://examples.k8s.io/volumes/rbd/README.md"
            )
        ),
    ] = None
    scale_io: Annotated[
        Optional[ScaleIOVolumeSource],
        Field(
            alias="scaleIO",
            description=(
                "scaleIO represents a ScaleIO persistent volume attached and mounted on" " Kubernetes nodes."
            ),
        ),
    ] = None
    secret: Annotated[
        Optional[SecretVolumeSource],
        Field(
            description=(
                "secret represents a secret that should populate this volume. More"
                " info: https://kubernetes.io/docs/concepts/storage/volumes#secret"
            )
        ),
    ] = None
    storageos: Annotated[
        Optional[StorageOSVolumeSource],
        Field(description=("storageOS represents a StorageOS volume attached and mounted on" " Kubernetes nodes.")),
    ] = None
    vsphere_volume: Annotated[
        Optional[VsphereVirtualDiskVolumeSource],
        Field(
            alias="vsphereVolume",
            description=("vsphereVolume represents a vSphere volume attached and mounted on" " kubelets host machine"),
        ),
    ] = None
