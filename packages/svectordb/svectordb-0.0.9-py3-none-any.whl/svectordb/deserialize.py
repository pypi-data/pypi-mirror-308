# Code generated by smithy-python-codegen DO NOT EDIT.

from base64 import b64decode
import json
from typing import Any

from smithy_core.documents import DocumentValue
from smithy_core.utils import expect_type, limited_parse_float
from smithy_http.aio.interfaces import HTTPResponse
from smithy_http.aio.restjson import parse_rest_json_error_info

from .config import Config
from .errors import (
    AccessDeniedException,
    ApiError,
    InsufficientFundsException,
    InternalServerError,
    NotFoundException,
    QuotaExceededException,
    ServiceError,
    ServiceUnavailableError,
    ThrottlingError,
    UnknownApiError,
    ValidationException,
)
from .models import (
    DeleteItemOutput,
    EmbedOutput,
    GetItemOutput,
    Item,
    ListItemsOutput,
    MetadataValue,
    MetadataValueNumber,
    MetadataValueNumberArray,
    MetadataValueString,
    MetadataValueStringArray,
    MetadataValueUnknown,
    QueryOutput,
    QueryResultItem,
    SetItemOutput,
    ValidationExceptionField,
)


async def _deserialize_delete_item(http_response: HTTPResponse, config: Config) -> DeleteItemOutput:
    if http_response.status != 204 and http_response.status >= 300:
        raise await _deserialize_error_delete_item(http_response, config)

    kwargs: dict[str, Any] = {}

    return DeleteItemOutput(**kwargs)

async def _deserialize_error_delete_item(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_embed(http_response: HTTPResponse, config: Config) -> EmbedOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_embed(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if (body := await http_response.consume_body_async()):
        output = json.loads(body)

    if (_consumed_embedding_units := output.get("consumedEmbeddingUnits")) is not None:
        kwargs["consumed_embedding_units"] = expect_type(int, _consumed_embedding_units)

    if "vector" not in output:
        raise ServiceError('Expected to find "vector" in the operation output, but it was not present.')
    kwargs["vector"] = _deserialize_vector(output['vector'], config)

    return EmbedOutput(**kwargs)

async def _deserialize_error_embed(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_get_item(http_response: HTTPResponse, config: Config) -> GetItemOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_item(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if (body := await http_response.consume_body_async()):
        output = json.loads(body)

    if (_metadata := output.get("metadata")) is not None:
        kwargs["metadata"] = _deserialize_metadata(_metadata, config)

    if "vector" not in output:
        raise ServiceError('Expected to find "vector" in the operation output, but it was not present.')
    kwargs["vector"] = _deserialize_vector(output['vector'], config)

    if (_value := output.get("value")) is not None:
        kwargs["value"] = b64decode(expect_type(str, _value))

    if "key" not in output:
        raise ServiceError('Expected to find "key" in the operation output, but it was not present.')
    kwargs["key"] = expect_type(str, output['key'])

    return GetItemOutput(**kwargs)

async def _deserialize_error_get_item(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_list_items(http_response: HTTPResponse, config: Config) -> ListItemsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_items(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if (body := await http_response.consume_body_async()):
        output = json.loads(body)

    if "items" not in output:
        raise ServiceError('Expected to find "items" in the operation output, but it was not present.')
    kwargs["items"] = _deserialize_item_list(output['items'], config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListItemsOutput(**kwargs)

async def _deserialize_error_list_items(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_query(http_response: HTTPResponse, config: Config) -> QueryOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_query(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if (body := await http_response.consume_body_async()):
        output = json.loads(body)

    if "results" not in output:
        raise ServiceError('Expected to find "results" in the operation output, but it was not present.')
    kwargs["results"] = _deserialize_query_result(output['results'], config)

    return QueryOutput(**kwargs)

async def _deserialize_error_query(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_set_item(http_response: HTTPResponse, config: Config) -> SetItemOutput:
    if http_response.status != 204 and http_response.status >= 300:
        raise await _deserialize_error_set_item(http_response, config)

    kwargs: dict[str, Any] = {}

    return SetItemOutput(**kwargs)

async def _deserialize_error_set_item(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "serviceunavailableerror":
            return await _deserialize_error_service_unavailable_error(http_response, config, parsed_body, message)

        case "validationexception":
            return await _deserialize_error_validation_exception(http_response, config, parsed_body, message)

        case "accessdeniedexception":
            return await _deserialize_error_access_denied_exception(http_response, config, parsed_body, message)

        case "insufficientfundsexception":
            return await _deserialize_error_insufficient_funds_exception(http_response, config, parsed_body, message)

        case "notfoundexception":
            return await _deserialize_error_not_found_exception(http_response, config, parsed_body, message)

        case "quotaexceededexception":
            return await _deserialize_error_quota_exceeded_exception(http_response, config, parsed_body, message)

        case "throttlingerror":
            return await _deserialize_error_throttling_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(message)

async def _deserialize_error_validation_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> ValidationException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if (_field_list := output.get("fieldList")) is not None:
        kwargs["field_list"] = _deserialize_validation_exception_field_list(_field_list, config)

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return ValidationException(**kwargs)

async def _deserialize_error_access_denied_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> AccessDeniedException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return AccessDeniedException(**kwargs)

async def _deserialize_error_insufficient_funds_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> InsufficientFundsException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return InsufficientFundsException(**kwargs)

async def _deserialize_error_internal_server_error(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> InternalServerError:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return InternalServerError(**kwargs)

async def _deserialize_error_not_found_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> NotFoundException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return NotFoundException(**kwargs)

async def _deserialize_error_quota_exceeded_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> QuotaExceededException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return QuotaExceededException(**kwargs)

async def _deserialize_error_service_unavailable_error(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> ServiceUnavailableError:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return ServiceUnavailableError(**kwargs)

async def _deserialize_error_throttling_error(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> ThrottlingError:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return ThrottlingError(**kwargs)

def _deserialize_validation_exception_field(output: DocumentValue, config: Config) -> ValidationExceptionField:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "path" not in output:
        raise ServiceError('Expected to find "path" in the operation output, but it was not present.')
    kwargs["path"] = expect_type(str, output['path'])

    if "message" not in output:
        raise ServiceError('Expected to find "message" in the operation output, but it was not present.')
    kwargs["message"] = expect_type(str, output['message'])

    return ValidationExceptionField(**kwargs)

def _deserialize_validation_exception_field_list(output: DocumentValue, config: Config) -> list[ValidationExceptionField]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_validation_exception_field(e, config) for e in output]

def _deserialize_item(output: DocumentValue, config: Config) -> Item:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "key" not in output:
        raise ServiceError('Expected to find "key" in the operation output, but it was not present.')
    kwargs["key"] = expect_type(str, output['key'])

    if (_value := output.get("value")) is not None:
        kwargs["value"] = b64decode(expect_type(str, _value))

    if "vector" not in output:
        raise ServiceError('Expected to find "vector" in the operation output, but it was not present.')
    kwargs["vector"] = _deserialize_vector(output['vector'], config)

    if (_metadata := output.get("metadata")) is not None:
        kwargs["metadata"] = _deserialize_metadata(_metadata, config)

    return Item(**kwargs)

def _deserialize_item_list(output: DocumentValue, config: Config) -> list[Item]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_item(e, config) for e in output]

def _deserialize_metadata(output: DocumentValue, config: Config) -> dict[str, MetadataValue]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: _deserialize_metadata_value(v, config) for k, v in output.items() if v is not None}

def _deserialize_metadata_value(output: DocumentValue, config: Config) -> MetadataValue:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    if (count := len(output)) != 1:
        raise ServiceError(f"Unions must have exactly one member set, found {count}.")

    tag, value = list(output.items())[0]

    match tag:
        case "string":
            return MetadataValueString(expect_type(str, value))

        case "stringArray":
            return MetadataValueStringArray(_deserialize_string_array(value, config))

        case "number":
            return MetadataValueNumber(limited_parse_float(value))

        case "numberArray":
            return MetadataValueNumberArray(_deserialize_number_array(value, config))

        case _:
            return MetadataValueUnknown(tag)

def _deserialize_number_array(output: DocumentValue, config: Config) -> list[float]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [limited_parse_float(e) for e in output]

def _deserialize_query_result(output: DocumentValue, config: Config) -> list[QueryResultItem]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_query_result_item(e, config) for e in output]

def _deserialize_query_result_item(output: DocumentValue, config: Config) -> QueryResultItem:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "key" not in output:
        raise ServiceError('Expected to find "key" in the operation output, but it was not present.')
    kwargs["key"] = expect_type(str, output['key'])

    if "value" not in output:
        raise ServiceError('Expected to find "value" in the operation output, but it was not present.')
    kwargs["value"] = b64decode(expect_type(str, output['value']))

    if "vector" not in output:
        raise ServiceError('Expected to find "vector" in the operation output, but it was not present.')
    kwargs["vector"] = _deserialize_vector(output['vector'], config)

    if "metadata" not in output:
        raise ServiceError('Expected to find "metadata" in the operation output, but it was not present.')
    kwargs["metadata"] = _deserialize_metadata(output['metadata'], config)

    if "distance" not in output:
        raise ServiceError('Expected to find "distance" in the operation output, but it was not present.')
    kwargs["distance"] = limited_parse_float(output['distance'])

    return QueryResultItem(**kwargs)

def _deserialize_string_array(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]

def _deserialize_vector(output: DocumentValue, config: Config) -> list[float]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [limited_parse_float(e) for e in output]
