# Code generated by smithy-python-codegen DO NOT EDIT.

from base64 import b64encode
import json
from typing import AsyncIterable
from urllib.parse import quote as urlquote

from smithy_core import URI as _URI
from smithy_core.aio.types import AsyncBytesReader
from smithy_core.documents import DocumentValue
from smithy_core.utils import limited_serialize_float
from smithy_http import Field, Fields
from smithy_http.aio import HTTPRequest as _HTTPRequest
from smithy_http.aio.interfaces import HTTPRequest

from .config import Config
from .errors import ServiceError
from .models import (
    DeleteItemInput,
    EmbedInput,
    EmbeddingInput,
    EmbeddingInputImage,
    EmbeddingInputText,
    GetItemInput,
    ListItemsInput,
    MetadataValue,
    MetadataValueNumber,
    MetadataValueNumberArray,
    MetadataValueString,
    MetadataValueStringArray,
    QueryInput,
    QueryType,
    QueryTypeKey,
    QueryTypeVector,
    SetItemInput,
)


async def _serialize_delete_item(input: DeleteItemInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    if not input.key:
        raise ServiceError("key must not be empty.")

    path = "/db/{database_id}/item/{key}".format(
        database_id=urlquote(input.database_id, safe=''),
        key=urlquote(input.key, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    headers = Fields(
        [

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )

async def _serialize_embed(input: EmbedInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    if not input.model:
        raise ServiceError("model must not be empty.")

    path = "/db/{database_id}/embed/{model}".format(
        database_id=urlquote(input.database_id, safe=''),
        model=urlquote(input.model, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    result: dict[str, DocumentValue] = {}

    if input.input is not None:
        result["input"] = _serialize_embedding_input(input.input, config)

    content = json.dumps(result).encode('utf-8')
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )

async def _serialize_get_item(input: GetItemInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    if not input.key:
        raise ServiceError("key must not be empty.")

    path = "/db/{database_id}/item/{key}".format(
        database_id=urlquote(input.database_id, safe=''),
        key=urlquote(input.key, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    headers = Fields(
        [

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )

async def _serialize_list_items(input: ListItemsInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    path = "/db/{database_id}/items".format(
        database_id=urlquote(input.database_id, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    content = json.dumps(result).encode('utf-8')
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )

async def _serialize_query(input: QueryInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    path = "/db/{database_id}/query".format(
        database_id=urlquote(input.database_id, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    result: dict[str, DocumentValue] = {}

    if input.query is not None:
        result["query"] = _serialize_query_type(input.query, config)

    if input.max_results is not None:
        result["maxResults"] = input.max_results

    if input.filter is not None:
        result["filter"] = input.filter

    content = json.dumps(result).encode('utf-8')
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )

async def _serialize_set_item(input: SetItemInput, config: Config) -> HTTPRequest:
    if not input.database_id:
        raise ServiceError("database_id must not be empty.")

    if not input.key:
        raise ServiceError("key must not be empty.")

    path = "/db/{database_id}/item/{key}".format(
        database_id=urlquote(input.database_id, safe=''),
        key=urlquote(input.key, safe=''),
    )
    query: str = f''

    body: AsyncIterable[bytes] = AsyncBytesReader(b'')
    result: dict[str, DocumentValue] = {}

    if input.metadata is not None:
        result["metadata"] = _serialize_metadata(input.metadata, config)

    if input.value is not None:
        result["value"] = b64encode(input.value).decode('utf-8')

    if input.vector is not None:
        result["vector"] = input.vector

    content = json.dumps(result).encode('utf-8')
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),

        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )

def _serialize_embedding_input(input: EmbeddingInput, config: Config) -> dict[str, DocumentValue]:
    match input:
        case EmbeddingInputText():
            return {"text": input.value}

        case EmbeddingInputImage():
            return {"image": b64encode(input.value).decode('utf-8')}

        case _:
            raise ServiceError(f"Unexpected union variant: {type(input)}")

def _serialize_metadata(input: dict[str, MetadataValue], config: Config) -> dict[str, DocumentValue]:
    return {k: _serialize_metadata_value(v, config) for k, v in input.items()}

def _serialize_metadata_value(input: MetadataValue, config: Config) -> dict[str, DocumentValue]:
    match input:
        case MetadataValueString():
            return {"string": input.value}

        case MetadataValueStringArray():
            return {"stringArray": input.value}

        case MetadataValueNumber():
            return {"number": limited_serialize_float(input.value)}

        case MetadataValueNumberArray():
            return {"numberArray": input.value}

        case _:
            raise ServiceError(f"Unexpected union variant: {type(input)}")

def _serialize_number_array(input: list[float], config: Config) -> list[DocumentValue]:
    return [limited_serialize_float(e) for e in input]

def _serialize_query_type(input: QueryType, config: Config) -> dict[str, DocumentValue]:
    match input:
        case QueryTypeKey():
            return {"key": input.value}

        case QueryTypeVector():
            return {"vector": input.value}

        case _:
            raise ServiceError(f"Unexpected union variant: {type(input)}")

def _serialize_vector(input: list[float], config: Config) -> list[DocumentValue]:
    return [limited_serialize_float(e) for e in input]
