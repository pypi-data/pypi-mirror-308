{"version":3,"file":"trame_annotations.umd.cjs","sources":["../../../../vue-components/node_modules/@timohausmann/quadtree-ts/dist/quadtree.esm.js","../../../../vue-components/src/utils.ts","../../../../vue-components/src/ImageDetection.vue","../../../../vue-components/src/main.js"],"sourcesContent":["/**\n * Class representing a Quadtree node.\n *\n * @example\n * ```typescript\n * const tree = new Quadtree({\n *   width: 100,\n *   height: 100,\n *   x: 0,           // optional, default:  0\n *   y: 0,           // optional, default:  0\n *   maxObjects: 10, // optional, default: 10\n *   maxLevels: 4,   // optional, default:  4\n * });\n * ```\n *\n * @example Typescript: If you like to be explicit, you optionally can pass in a generic type for objects to be stored in the Quadtree:\n * ```typescript\n * class GameEntity extends Rectangle {\n *   ...\n * }\n * const tree = new Quadtree<GameEntity>({\n *   width: 100,\n *   height: 100,\n * });\n * ```\n */\nclass Quadtree {\n    /**\n     * Quadtree Constructor\n     * @param props - bounds and properties of the node\n     * @param level - depth level (internal use only, required for subnodes)\n     */\n    constructor(props, level = 0) {\n        this.bounds = {\n            x: props.x || 0,\n            y: props.y || 0,\n            width: props.width,\n            height: props.height,\n        };\n        this.maxObjects = (typeof props.maxObjects === 'number') ? props.maxObjects : 10;\n        this.maxLevels = (typeof props.maxLevels === 'number') ? props.maxLevels : 4;\n        this.level = level;\n        this.objects = [];\n        this.nodes = [];\n    }\n    /**\n     * Get the quadrant (subnode indexes) an object belongs to.\n     *\n     * @example Mostly for internal use but you can call it like so:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rectangle = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const indexes = tree.getIndex(rectangle);\n     * console.log(indexes); // [1]\n     * ```\n     *\n     * @param obj - object to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right).\n     */\n    getIndex(obj) {\n        return obj.qtIndex(this.bounds);\n    }\n    /**\n     * Split the node into 4 subnodes.\n     * @internal Mostly for internal use! You should only call this yourself if you know what you are doing.\n     *\n     * @example Manual split:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree); // now tree has four subnodes\n     * ```\n     */\n    split() {\n        const level = this.level + 1, width = this.bounds.width / 2, height = this.bounds.height / 2, x = this.bounds.x, y = this.bounds.y;\n        const coords = [\n            { x: x + width, y: y },\n            { x: x, y: y },\n            { x: x, y: y + height },\n            { x: x + width, y: y + height },\n        ];\n        for (let i = 0; i < 4; i++) {\n            this.nodes[i] = new Quadtree({\n                x: coords[i].x,\n                y: coords[i].y,\n                width,\n                height,\n                maxObjects: this.maxObjects,\n                maxLevels: this.maxLevels,\n            }, level);\n        }\n    }\n    /**\n     * Insert an object into the node. If the node\n     * exceeds the capacity, it will split and add all\n     * objects to their corresponding subnodes.\n     *\n     * @example you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.insert(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     *\n     * @param obj - Object to be added.\n     */\n    insert(obj) {\n        //if we have subnodes, call insert on matching subnodes\n        if (this.nodes.length) {\n            const indexes = this.getIndex(obj);\n            for (let i = 0; i < indexes.length; i++) {\n                this.nodes[indexes[i]].insert(obj);\n            }\n            return;\n        }\n        //otherwise, store object here\n        this.objects.push(obj);\n        //maxObjects reached\n        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n            //split if we don't already have subnodes\n            if (!this.nodes.length) {\n                this.split();\n            }\n            //add all objects to their corresponding subnode\n            for (let i = 0; i < this.objects.length; i++) {\n                const indexes = this.getIndex(this.objects[i]);\n                for (let k = 0; k < indexes.length; k++) {\n                    this.nodes[indexes[k]].insert(this.objects[i]);\n                }\n            }\n            //clean up this node\n            this.objects = [];\n        }\n    }\n    /**\n     * Return all objects that could collide with the given geometry.\n     *\n     * @example Just like insert, you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * tree.retrieve(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.retrieve(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.retrieve(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     *\n     * @param obj - geometry to be checked\n     * @returns Array containing all detected objects.\n     */\n    retrieve(obj) {\n        const indexes = this.getIndex(obj);\n        let returnObjects = this.objects;\n        //if we have subnodes, retrieve their objects\n        if (this.nodes.length) {\n            for (let i = 0; i < indexes.length; i++) {\n                returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(obj));\n            }\n        }\n        // remove duplicates\n        if (this.level === 0) {\n            return Array.from(new Set(returnObjects));\n        }\n        return returnObjects;\n    }\n    /**\n     * Remove an object from the tree.\n     * If you have to remove many objects, consider clearing the entire tree and rebuilding it or use the `fast` flag to cleanup after the last removal.\n     * @beta\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const circle = new Circle({ x: 25, y: 25, r: 10, data: 512 });\n     * tree.insert(circle);\n     * tree.remove(circle);\n     * ```\n     *\n     * @example Bulk fast removals and final cleanup:\n     * ```javascript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rects = [];\n     *  for(let i=0; i<20; i++) {\n     *    rects[i] = new Rectangle({ x: 25, y: 25, width: 50, height: 50 });\n     *    tree.insert(rects[i]);\n     *  }\n     *  for(let i=rects.length-1; i>0; i--) {\n     *    //fast=true – just remove the object (may leaves vacant subnodes)\n     *    //fast=false – cleanup empty subnodes (default)\n     *    const fast = (i !== 0);\n     *    tree.remove(rects[i], fast);\n     *  }\n     * ```\n     *\n     * @param obj - Object to be removed.\n     * @param fast - Set to true to increase performance temporarily by preventing cleanup of empty subnodes (optional, default: false).\n     * @returns Weather or not the object was removed from THIS node (no recursive check).\n     */\n    remove(obj, fast = false) {\n        const indexOf = this.objects.indexOf(obj);\n        // remove objects\n        if (indexOf > -1) {\n            this.objects.splice(indexOf, 1);\n        }\n        // remove from all subnodes\n        for (let i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].remove(obj);\n        }\n        // remove all empty subnodes\n        if (this.level === 0 && !fast) {\n            this.join();\n        }\n        return (indexOf !== -1);\n    }\n    /**\n     * Update an object already in the tree (shorthand for remove and insert).\n     * If you have to update many objects, consider clearing and rebuilding the\n     * entire tree or use the `fast` flag to cleanup after the last update.\n     * @beta\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100, maxObjects: 1 });\n     * const rect1 = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const rect2 = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * tree.insert(rect1);\n     * tree.insert(rect2);\n     * rect1.x = 75;\n     * rect1.y = 75;\n     * tree.update(rect1);\n     * ```\n     * @example Bulk fast update and final cleanup:\n     * ```javascript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rects = [];\n     *  for(let i=0; i<20; i++) {\n     *    rects[i] = new Rectangle({ x: 20, y: 20, width: 20, height: 20 });\n     *    tree.insert(rects[i]);\n     *  }\n     *  for(let i=rects.length-1; i>0; i--) {\n     *    rects[i].x = 20 + Math.random()*60;\n     *    rects[i].y = 20 + Math.random()*60;\n     *    //fast=true – just re-insert the object (may leaves vacant subnodes)\n     *    //fast=false – cleanup empty subnodes (default)\n     *    const fast = (i !== 0);\n     *    tree.update(rects[i], fast);\n     *  }\n     * ```\n     *\n     * @param obj - Object to be updated.\n     * @param fast - Set to true to increase performance temporarily by preventing cleanup of empty subnodes (optional, default: false).\n     */\n    update(obj, fast = false) {\n        this.remove(obj, fast);\n        this.insert(obj);\n    }\n    /**\n     * The opposite of a split: try to merge and dissolve subnodes.\n     * @beta\n     * @internal Mostly for internal use! You should only call this yourself if you know what you are doing.\n     *\n     * @example Manual join:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree.nodes.length); // 4\n     * tree.join();\n     * console.log(tree.nodes.length); // 0\n     * ```\n     *\n     * @returns The objects from this node and all subnodes combined.\n     */\n    join() {\n        // recursive join\n        let allObjects = Array.from(this.objects);\n        for (let i = 0; i < this.nodes.length; i++) {\n            const bla = this.nodes[i].join();\n            allObjects = allObjects.concat(bla);\n        }\n        // remove duplicates\n        const uniqueObjects = Array.from(new Set(allObjects));\n        if (uniqueObjects.length <= this.maxObjects) {\n            this.objects = uniqueObjects;\n            for (let i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].objects = [];\n            }\n            this.nodes = [];\n        }\n        return allObjects;\n    }\n    /**\n     * Clear the Quadtree.\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10 }));\n     * tree.clear();\n     * console.log(tree); // tree.objects and tree.nodes are empty\n     * ```\n     */\n    clear() {\n        this.objects = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            if (this.nodes.length) {\n                this.nodes[i].clear();\n            }\n        }\n        this.nodes = [];\n    }\n}\n\n/**\n * Class representing a Rectangle\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const rectangle = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const rectangle = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const rectangle1 = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const rectangle2 = new Rectangle<ObjectData>({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * rectangle2.data = entity;\n * ```\n *\n * @example With custom class extending Rectangle (implements {@link RectangleGeometry} (x, y, width, height)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Box extends Rectangle {\n *\n *   constructor(props) {\n *     // call super to set x, y, width, height (and data, if given)\n *     super(props);\n *     this.content = props.content;\n *   }\n * }\n *\n * const box = new Box({\n *   content: 'Gravity Boots',\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * ```\n *\n * @example With custom class and mapping {@link RectangleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement RectangleGeometry\n * class Box {\n *\n *   constructor(content) {\n *     this.content = content;\n *     this.position = [10, 20];\n *     this.size = [30, 40];\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to RectangleGeometry\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   }\n * }\n *\n * const box = new Box('Gravity Boots');\n * ```\n *\n * @example With custom object that implements {@link RectangleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 30,\n *   qtIndex: Rectangle.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link RectangleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   position: [10, 20],\n *   size: [30, 40],\n *   qtIndex: function(node) {\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Rectangle {\n    constructor(props) {\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this rectangle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], boundsCenterX = node.x + (node.width / 2), boundsCenterY = node.y + (node.height / 2);\n        const startIsNorth = this.y < boundsCenterY, startIsWest = this.x < boundsCenterX, endIsEast = this.x + this.width > boundsCenterX, endIsSouth = this.y + this.height > boundsCenterY;\n        //top-right quad\n        if (startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        //top-left quad\n        if (startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n        //bottom-left quad\n        if (startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n        //bottom-right quad\n        if (endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n        return indexes;\n    }\n}\n\n/**\n * Class representing a Circle.\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const circle = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const circle = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const circle1 = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const circle2 = new Circle<ObjectData>({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n * });\n * circle2.data = entity;\n * ```\n *\n * @example With custom class extending Circle (implements {@link CircleGeometry} (x, y, r)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Bomb extends Circle {\n *\n *   constructor(props) {\n *     // call super to set x, y, r (and data, if given)\n *     super(props);\n *     this.countdown = props.countdown;\n *   }\n * }\n *\n * const bomb = new Bomb({\n *   countdown: 5,\n *   x: 10,\n *   y: 20,\n *   r: 30,\n * });\n * ```\n *\n * @example With custom class and mapping {@link CircleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement CircleGeometry\n * class Bomb {\n *\n *   constructor(countdown) {\n *     this.countdown = countdown;\n *     this.position = [10, 20];\n *     this.radius = 30;\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to CircleGeometry\n *     return Circle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       r: this.radius,\n *     }, node);\n *   }\n * }\n *\n * const bomb = new Bomb(5);\n * ```\n *\n * @example With custom object that implements {@link CircleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x: 10,\n *   y: 20,\n *   r: 30,\n *   qtIndex: Circle.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link CircleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   position: [10, 20],\n *   radius: 30,\n *   qtIndex: function(node) {\n *     return Circle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       r: this.radius,\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Circle {\n    /**\n     * Circle Constructor\n     * @param props - Circle properties\n     * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n     */\n    constructor(props) {\n        this.x = props.x;\n        this.y = props.y;\n        this.r = props.r;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this circle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], w2 = node.width / 2, h2 = node.height / 2, x2 = node.x + w2, y2 = node.y + h2;\n        //an array of node origins where the array index equals the node index\n        const nodes = [\n            [x2, node.y],\n            [node.x, node.y],\n            [node.x, y2],\n            [x2, y2],\n        ];\n        //test all nodes for circle intersections\n        for (let i = 0; i < nodes.length; i++) {\n            if (Circle.intersectRect(this.x, this.y, this.r, nodes[i][0], nodes[i][1], nodes[i][0] + w2, nodes[i][1] + h2)) {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n    /**\n     * Check if a circle intersects an axis aligned rectangle.\n     * @beta\n     * @see https://yal.cc/rectangle-circle-intersection-test/\n     * @param x - circle center X\n     * @param y - circle center Y\n     * @param r - circle radius\n     * @param minX - rectangle start X\n     * @param minY - rectangle start Y\n     * @param maxX - rectangle end X\n     * @param maxY - rectangle end Y\n     * @returns true if circle intersects rectangle\n     *\n     * @example Check if a circle intersects a rectangle:\n     * ```javascript\n     * const circ = { x: 10, y: 20, r: 30 };\n     * const rect = { x: 40, y: 50, width: 60, height: 70 };\n     * const intersect = Circle.intersectRect(\n     *   circ.x,\n     *   circ.y,\n     *   circ.r,\n     *   rect.x,\n     *   rect.y,\n     *   rect.x + rect.width,\n     *   rect.y + rect.height,\n     * );\n     * console.log(circle, rect, 'intersect?', intersect);\n     * ```\n     */\n    static intersectRect(x, y, r, minX, minY, maxX, maxY) {\n        const deltaX = x - Math.max(minX, Math.min(x, maxX));\n        const deltaY = y - Math.max(minY, Math.min(y, maxY));\n        return (deltaX * deltaX + deltaY * deltaY) < (r * r);\n    }\n}\n\n/**\n * Class representing a Line\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const line = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const line = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const line1 = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const line2 = new Line<ObjectData>({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * line2.data = entity;\n * ```\n *\n * @example With custom class extending Line (implements {@link LineGeometry} (x1, y1, x2, y2)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Laser extends Line {\n *\n *   constructor(props) {\n *     // call super to set x1, y1, x2, y2 (and data, if given)\n *     super(props);\n *     this.color = props.color;\n *   }\n * }\n *\n * const laser = new Laser({\n *   color: 'green',\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * ```\n *\n * @example With custom class and mapping {@link LineGeometry}:\n * ```javascript\n * // no need to extend if you don't implement LineGeometry\n * class Laser {\n *\n *   constructor(color) {\n *     this.color = color;\n *     this.start = [10, 20];\n *     this.end = [30, 40];\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to LineGeometry\n *     return Line.prototype.qtIndex.call({\n *       x1: this.start[0],\n *       y1: this.start[1],\n *       x2: this.end[0],\n *       y2: this.end[1],\n *     }, node);\n *   }\n * }\n *\n * const laser = new Laser('green');\n * ```\n *\n * @example With custom object that implements {@link LineGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   qtIndex: Line.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link LineGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   start: [10, 20],\n *   end: [30, 40],\n *   qtIndex: function(node) {\n *     return Line.prototype.qtIndex.call({\n *       x1: this.start[0],\n *       y1: this.start[1],\n *       x2: this.end[0],\n *       y2: this.end[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Line {\n    /**\n     * Line Constructor\n     * @param props - Line properties\n     * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n     */\n    constructor(props) {\n        this.x1 = props.x1;\n        this.y1 = props.y1;\n        this.x2 = props.x2;\n        this.y2 = props.y2;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this line belongs to.\n     * @beta\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], w2 = node.width / 2, h2 = node.height / 2, x2 = node.x + w2, y2 = node.y + h2;\n        //an array of node origins where the array index equals the node index\n        const nodes = [\n            [x2, node.y],\n            [node.x, node.y],\n            [node.x, y2],\n            [x2, y2],\n        ];\n        //test all nodes for line intersections\n        for (let i = 0; i < nodes.length; i++) {\n            if (Line.intersectRect(this.x1, this.y1, this.x2, this.y2, nodes[i][0], nodes[i][1], nodes[i][0] + w2, nodes[i][1] + h2)) {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n    /**\n     * check if a line segment (the first 4 parameters) intersects an axis aligned rectangle (the last 4 parameters)\n     * @beta\n     *\n     * @remarks\n     * There is a bug where detection fails on corner intersections\n     * when the line enters/exits the node exactly at corners (45°)\n     * {@link https://stackoverflow.com/a/18292964/860205}\n     *\n     * @param x1 - line start X\n     * @param y1 - line start Y\n     * @param x2 - line end X\n     * @param y2 - line end Y\n     * @param minX - rectangle start X\n     * @param minY - rectangle start Y\n     * @param maxX - rectangle end X\n     * @param maxY - rectangle end Y\n     * @returns true if the line segment intersects the axis aligned rectangle\n     */\n    static intersectRect(x1, y1, x2, y2, minX, minY, maxX, maxY) {\n        // Completely outside\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        // Single point inside\n        if ((x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY) || (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY))\n            return true;\n        const m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY)\n            return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY)\n            return true;\n        let x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX)\n            return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX)\n            return true;\n        return false;\n    }\n}\n\nexport { Circle, Line, Quadtree, Rectangle };\n","import {\n  ref,\n  type Ref,\n  getCurrentScope,\n  onScopeDispose,\n  watchEffect,\n} from \"vue\";\n\n/**\n * Call onScopeDispose() if it's inside an effect scope lifecycle, if not, do nothing\n *\n * @param fn\n */\nexport function tryOnScopeDispose(fn: () => void) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Reactively track `window.devicePixelRatio`.\n *  Modified from vueuse\n * @see https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicePixelRatio/index.ts\n */\nexport function useDevicePixelRatio() {\n  const pixelRatio = ref(1);\n\n  if (window) {\n    let media: MediaQueryList;\n\n    function observe() {\n      pixelRatio.value = window!.devicePixelRatio;\n      cleanup();\n      media = window!.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe, { once: true });\n    }\n\n    function cleanup() {\n      media?.removeEventListener(\"change\", observe);\n    }\n\n    observe();\n    tryOnScopeDispose(cleanup);\n  }\n\n  return { pixelRatio };\n}\n\nexport type UseDevicePixelRatioReturn = ReturnType<typeof useDevicePixelRatio>;\n\nexport function useResizeObserver(element: Ref<HTMLElement | undefined>) {\n  const width = ref(0);\n  let observer: ResizeObserver | null = null;\n  let currentElement: HTMLElement | undefined;\n\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n    currentElement = undefined;\n  };\n\n  const setupObserver = () => {\n    observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        width.value = entry.contentRect.width;\n      }\n    });\n  };\n\n  watchEffect(() => {\n    if (\n      currentElement &&\n      (!element.value || element.value !== currentElement)\n    ) {\n      cleanup();\n    }\n\n    if (!element.value) return;\n\n    if (!observer) {\n      setupObserver();\n    }\n\n    currentElement = element.value;\n    observer?.observe(currentElement);\n    width.value = currentElement.clientWidth;\n  });\n\n  tryOnScopeDispose(cleanup);\n\n  return {\n    width,\n  };\n}\n","<script setup lang=\"ts\">\nimport { ref, watchEffect, computed, onMounted, unref } from \"vue\";\n\nimport { Quadtree, Rectangle } from \"@timohausmann/quadtree-ts\";\nimport { useDevicePixelRatio, useResizeObserver } from \"./utils.js\";\n\nconst CATEGORY_COLORS = [\n  [255, 0, 0],\n  [0, 255, 0],\n  [0, 0, 255],\n  [255, 255, 0],\n  [255, 0, 255],\n  [0, 255, 255],\n] as const as readonly [number, number, number][];\n\nconst LINE_OPACITY = 0.9;\nconst LINE_WIDTH = 2; // in pixels\n\ntype Box = [number, number, number, number];\n\ntype Annotation = {\n  id: number;\n  category_id: number;\n  label: string; // fallback if category_id has no match\n  bbox: Box;\n};\n\ntype Category = {\n  id: number;\n  name: string;\n};\n\nconst TOOLTIP_OFFSET = [8, 8];\nconst TOOLTIP_PADDING = 16; // fudge to keep tooltip from clipping/overflowing. In pixels\n\nlet annotationsTree: Quadtree<Rectangle<number>> | undefined = undefined;\n\nfunction doRectanglesOverlap(\n  recA: Rectangle<unknown>,\n  recB: Rectangle<unknown>,\n): boolean {\n  const noHOverlap =\n    recB.x >= recA.x + recA.width || recA.x >= recB.x + recB.width;\n\n  if (noHOverlap) {\n    return false;\n  }\n\n  const noVOverlap =\n    recB.y >= recA.y + recA.height || recA.y >= recB.y + recB.height;\n\n  return !noVOverlap;\n}\n\nconst props = defineProps<{\n  identifier: string;\n  src: string;\n  annotations?: Annotation[];\n  categories: { [key: number]: Category };\n  selected: boolean;\n  containerSelector?: string;\n  lineWidth?: number;\n  lineOpacity?: number;\n}>();\n\nconst visibleCanvas = ref<HTMLCanvasElement>();\nconst visibleCtx = computed(() =>\n  visibleCanvas.value?.getContext(\"2d\", { alpha: true }),\n);\nconst pickingCanvas = ref<HTMLCanvasElement>();\nconst pickingCtx = computed(() =>\n  pickingCanvas.value?.getContext(\"2d\", { willReadFrequently: true }),\n);\nconst labelContainer = ref<HTMLDivElement>();\n\nconst imageSize = ref({ width: 0, height: 0 });\nconst img = ref<HTMLImageElement>();\nconst onImageLoad = () => {\n  imageSize.value = {\n    width: img.value?.naturalWidth ?? 0,\n    height: img.value?.naturalHeight ?? 0,\n  };\n};\n\nconst annotations = computed(() => unref(props.annotations) ?? []);\n\nconst annotationsWithColor = computed(() => {\n  return annotations.value.map((annotation) => {\n    const mutex = annotation.category_id ?? 0;\n    const color = CATEGORY_COLORS[mutex % CATEGORY_COLORS.length];\n    return { ...annotation, color };\n  });\n});\n\nconst dpi = useDevicePixelRatio();\n\nconst { width } = useResizeObserver(visibleCanvas);\n\nconst displayScale = computed(() => {\n  if (!visibleCanvas.value) return 1;\n  return imageSize.value.width / width.value;\n});\n\nconst validLineWidth = computed(() => {\n  return props.lineWidth ?? LINE_WIDTH;\n});\n\nconst lineWidthInDisplay = computed(\n  () => validLineWidth.value * dpi.pixelRatio.value * displayScale.value,\n);\n\nconst lineOpacity = computed(() => props.lineOpacity ?? LINE_OPACITY);\n// draw visible annotations\nwatchEffect(() => {\n  if (!visibleCanvas.value || !visibleCtx.value) {\n    return;\n  }\n  const canvas = visibleCanvas.value;\n  const ctx = visibleCtx.value;\n\n  canvas.width = imageSize.value.width;\n  canvas.height = imageSize.value.height;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.globalCompositeOperation = \"lighter\"; // additive blend mode\n  ctx.lineWidth = lineWidthInDisplay.value;\n  const alpha = lineOpacity.value;\n  annotationsWithColor.value.forEach(({ color, bbox }) => {\n    ctx.strokeStyle = `rgba(${[...color, alpha].join(\",\")})`;\n    ctx.strokeRect(bbox[0], bbox[1], bbox[2], bbox[3]);\n  });\n});\n\n// draw picking annotations\nwatchEffect(() => {\n  if (!pickingCtx.value || !pickingCanvas.value) {\n    return;\n  }\n  const canvas = pickingCanvas.value;\n  const ctx = pickingCtx.value;\n\n  canvas.width = imageSize.value.width;\n  canvas.height = imageSize.value.height;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  annotationsTree = new Quadtree({\n    width: canvas.width,\n    height: canvas.height,\n    maxLevels: 8,\n    maxObjects: 10,\n  });\n\n  annotations.value.forEach((annotation, i) => {\n    const treeNode = new Rectangle({\n      x: annotation.bbox[0],\n      y: annotation.bbox[1],\n      width: annotation.bbox[2],\n      height: annotation.bbox[3],\n      data: i,\n    });\n    annotationsTree?.insert(treeNode);\n    ctx.fillStyle = `rgb(255, 0, 0)`;\n    ctx.fillRect(\n      annotation.bbox[0],\n      annotation.bbox[1],\n      annotation.bbox[2],\n      annotation.bbox[3],\n    );\n  });\n});\n\ninterface HoverEvent {\n  id: string;\n}\n\ntype Events = {\n  hover: [HoverEvent];\n};\n\nconst emit = defineEmits<Events>();\n\nfunction hideLabel() {\n  if (labelContainer.value) labelContainer.value.style.visibility = \"hidden\";\n}\n\nonMounted(hideLabel);\n\nfunction mouseEnter() {\n  emit(\"hover\", { id: props.identifier });\n}\nfunction mouseLeave() {\n  emit(\"hover\", { id: \"\" });\n  hideLabel();\n}\n\nfunction displayToPixel(\n  x: number,\n  y: number,\n  canvas: HTMLCanvasElement,\n): [number, number] {\n  const canvasBounds = canvas.getBoundingClientRect();\n\n  const pixelX = (canvas.width * (x - canvasBounds.left)) / canvasBounds.width;\n  const pixelY = (canvas.height * (y - canvasBounds.top)) / canvasBounds.height;\n\n  return [pixelX, pixelY];\n}\n\nconst mounted = ref(false);\nonMounted(() => {\n  mounted.value = true;\n});\nconst container = computed(() => {\n  if (!mounted.value || !props.containerSelector) return null;\n  return document.querySelector(props.containerSelector);\n});\n\nfunction mouseMove(e: MouseEvent) {\n  if (\n    !pickingCanvas.value ||\n    pickingCanvas.value.width === 0 ||\n    !labelContainer.value ||\n    !annotationsTree ||\n    !props.categories ||\n    !props.annotations\n  ) {\n    return;\n  }\n  const ctx = pickingCtx.value;\n  if (!ctx) {\n    return;\n  }\n\n  const [pixelX, pixelY] = displayToPixel(\n    e.clientX,\n    e.clientY,\n    pickingCanvas.value,\n  );\n  const pixelValue = ctx.getImageData(pixelX, pixelY, 1, 1).data[0];\n  const pickedSomething = pixelValue > 0;\n\n  if (!pickedSomething) {\n    labelContainer.value.style.visibility = \"hidden\";\n    return;\n  }\n\n  labelContainer.value.style.visibility = \"visible\";\n\n  const pixelRectangle = new Rectangle({\n    x: pixelX,\n    y: pixelY,\n    width: 2,\n    height: 2,\n  });\n  const hits = annotationsTree\n    .retrieve(pixelRectangle)\n    .filter((rect) => doRectanglesOverlap(rect, pixelRectangle))\n    .filter((hit) => hit.data != undefined)\n    .map((hit) => {\n      const annotation = annotationsWithColor.value[hit.data!];\n      const name =\n        props.categories[annotation.category_id]?.name ?? annotation.label;\n      const color = annotation.color;\n      const category = document.createElement(\"li\");\n      category.style.textShadow = `rgba(${color.join(\",\")},0.6) 1px 1px 3px`;\n      const annotationId = annotation.id ? ` : ${annotation.id}` : \"\";\n      category.textContent = `${name}${annotationId}`;\n      return category;\n    });\n\n  labelContainer.value.replaceChildren(...hits);\n\n  // Position the tooltip\n  const [x, y] = [e.offsetX, e.offsetY];\n  let posX = x + TOOLTIP_OFFSET[0];\n  let posY = y + TOOLTIP_OFFSET[1];\n\n  const tooltipRect = labelContainer.value.getBoundingClientRect();\n  const parentRect = pickingCanvas.value.getBoundingClientRect();\n  const containerRect = container.value?.getBoundingClientRect() ?? {\n    left: 0,\n    top: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n\n  const toolTipInContainer = {\n    left: parentRect.left + posX - containerRect.left,\n    top: parentRect.top + posY - containerRect.top,\n    width: tooltipRect.width + TOOLTIP_PADDING,\n    height: tooltipRect.height + TOOLTIP_PADDING,\n  };\n\n  // if text goes off the edge, move up and/or left\n  if (\n    toolTipInContainer.left + toolTipInContainer.width >\n    containerRect.width\n  ) {\n    posX = x - tooltipRect.width - TOOLTIP_OFFSET[0];\n  }\n  if (\n    toolTipInContainer.top + toolTipInContainer.height >\n    containerRect.height\n  ) {\n    posY = y - tooltipRect.height - TOOLTIP_OFFSET[1];\n  }\n\n  labelContainer.value.style.left = `${posX}px`;\n  labelContainer.value.style.top = `${posY}px`;\n}\n\nconst borderSize = computed(() => (props.selected ? \"4\" : \"0\"));\n\nconst src = computed(() => unref(props.src));\n</script>\n\n<template>\n  <div style=\"position: relative\">\n    <img\n      ref=\"img\"\n      :src=\"src\"\n      :style=\"{ outlineWidth: borderSize + 'px' }\"\n      style=\"width: 100%; outline-style: dotted; outline-color: red\"\n      @load=\"onImageLoad\"\n    />\n    <canvas\n      ref=\"visibleCanvas\"\n      style=\"width: 100%; position: absolute; left: 0; top: 0\"\n    />\n    <canvas\n      ref=\"pickingCanvas\"\n      style=\"opacity: 0; width: 100%; position: absolute; left: 0; top: 0\"\n      @mouseenter=\"mouseEnter\"\n      @mousemove=\"mouseMove\"\n      @mouseleave=\"mouseLeave\"\n    />\n    <ul\n      ref=\"labelContainer\"\n      style=\"\n        position: absolute;\n        z-index: 10;\n        padding: 0.4rem;\n        white-space: pre;\n        font-size: small;\n        border-radius: 0.2rem;\n        border-color: rgba(127, 127, 127, 0.75);\n        border-style: solid;\n        border-width: thin;\n        background-color: #efefef;\n        list-style-type: none;\n      \"\n    />\n  </div>\n</template>\n","import ImageDetection from \"./ImageDetection.vue\";\n\nconst components = {\n  ImageDetection,\n};\n\nexport function install(Vue) {\n  Object.entries(components).forEach(([name, component]) => {\n    Vue.component(name, component);\n  });\n}\n"],"names":["Quadtree","props","level","obj","width","height","x","y","coords","i","indexes","k","returnObjects","fast","indexOf","allObjects","bla","uniqueObjects","Rectangle","node","boundsCenterX","boundsCenterY","startIsNorth","startIsWest","endIsEast","endIsSouth","tryOnScopeDispose","fn","getCurrentScope","onScopeDispose","useDevicePixelRatio","pixelRatio","ref","observe","cleanup","media","useResizeObserver","element","observer","currentElement","setupObserver","entries","entry","watchEffect","LINE_OPACITY","LINE_WIDTH","TOOLTIP_PADDING","components","CATEGORY_COLORS","TOOLTIP_OFFSET","annotationsTree","doRectanglesOverlap","recA","recB","__props","visibleCanvas","visibleCtx","computed","_a","pickingCanvas","pickingCtx","labelContainer","imageSize","img","onImageLoad","_b","annotations","unref","annotationsWithColor","annotation","mutex","color","dpi","displayScale","validLineWidth","lineWidthInDisplay","lineOpacity","canvas","ctx","alpha","bbox","treeNode","emit","__emit","hideLabel","onMounted","mouseEnter","mouseLeave","displayToPixel","canvasBounds","pixelX","pixelY","mounted","container","mouseMove","e","pixelRectangle","hits","rect","hit","name","category","annotationId","posX","posY","tooltipRect","parentRect","containerRect","toolTipInContainer","borderSize","src","install","Vue","component"],"mappings":"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","x_google_ignoreList":[0]}