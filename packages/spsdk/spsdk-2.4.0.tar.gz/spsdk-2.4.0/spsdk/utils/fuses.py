#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2024 NXP
#
# SPDX-License-Identifier: BSD-3-Clause
"""Module for generating scripts for writing fuses."""

from typing import Any, Optional

from spsdk import version as spsdk_version
from spsdk.exceptions import SPSDKError, SPSDKValueError
from spsdk.utils.database import DatabaseManager, get_db
from spsdk.utils.misc import Endianness, get_abs_path, value_to_int, write_file
from spsdk.utils.registers import Registers


class FuseScript:
    """Class for generating scripts for writing fuses."""

    BLHOST_FUSE_WRITE_CMD = "efuse-program-once"
    NXPELE_FUSE_WRITE_CMD = "write-fuse"

    BLHOST_INDEX = ""
    NXPELE_INDEX = "--index "

    BLHOST_DATA = ""
    NXPELE_DATA = "--data "

    def __init__(
        self,
        family: str,
        revision: str,
        feature: str,
        index: Optional[int] = None,
        fuses_key: str = "fuses",
    ):
        """Initialize FuseScript object."""
        self.feature = feature
        self.family = family
        self.revision = revision

        self.db = get_db(family, revision)

        if not DatabaseManager.FUSES in self.db.features:
            raise SPSDKError(f"The {self.family} has no fuses definition")

        self.fuses = Registers(
            family=family,
            feature=DatabaseManager.FUSES,
            revision=revision,
            base_endianness=Endianness.LITTLE,
        )

        self.tool = self.db.get_str(DatabaseManager.FUSES, "tool", "blhost")

        if index is not None:
            # if index is present append it to the fuses key,
            # like fuses_0, fuses_1, etc.
            fuses_key += f"_{index}"

        self.fuses_db = self.db.get_dict(feature, fuses_key)

        # No verify flag means that fuse won't be verified after write
        # It is needed for read protected OTP (blhost --no-verify)
        self.no_verify = self.fuses_db.get("_no_verify", False)
        self.name = self.fuses_db.get("_name", "Fuse Script")

    def get_fuse_write_cmd(self, index: int, value: str) -> str:
        """Get fuse write command."""
        command = {"blhost": self.BLHOST_FUSE_WRITE_CMD, "nxpele": self.NXPELE_FUSE_WRITE_CMD}[
            self.tool
        ]

        index_cmd = {"blhost": self.BLHOST_INDEX, "nxpele": self.NXPELE_INDEX}[self.tool]
        data_cmd = {"blhost": self.BLHOST_DATA, "nxpele": self.NXPELE_DATA}[self.tool]

        no_verify = " --no-verify" if (self.no_verify and self.tool == "blhost") else ""
        return f"{command} {index_cmd}{index} {data_cmd}{value}{no_verify}"

    def generate_file_header(self) -> str:
        """Generate file header."""
        return (
            f"# {self.tool} {self.name} fuses programming script\n"
            f"# Generated by SPSDK {spsdk_version}\n"
            f"# Family: {self.family} Revision: {self.revision}"
        )

    @staticmethod
    def get_object_value(value: str, attributes_object: object) -> Any:
        """Return object value if attributes object has attribute with the value name."""
        if value.startswith("__"):
            value = value[2:]
            if hasattr(attributes_object, value):
                return getattr(attributes_object, value)
        raise SPSDKValueError(f"Fuses: Object does not contain {value}")

    def generate_script(self, attributes_object: object, info_only: bool = False) -> str:
        """Generate script for writing fuses.

        This method generates a script for writing fuses based on the provided attributes object.
        The script includes the file header and the commands for setting the fuse values.


        Special attributes:
        - __str_value: Value with double underscore represents attribute of the object.

        :param attributes_object: An object containing the attributes used to set the fuse values.
        :param info_only: If True, only the information about the fuses is generated.
        :return: The generated script for writing fuses.
        """
        script = self.generate_file_header() + "\n"
        info = ""

        for key, value in self.fuses_db.items():
            extra_info = ""
            if key.startswith("_"):  # Skip private attributes
                continue
            reg = self.fuses.get_reg(key)
            if isinstance(value, (int, bool)):  # RAW int value or boolean
                reg.set_value(value_to_int(value), raw=True)

            elif isinstance(value, dict):  # value contains bitfields
                for sub_key, sub_value in value.items():
                    bitfield = reg.get_bitfield(sub_key)
                    if isinstance(sub_value, (int, bool)):
                        bitfield.set_value(value_to_int(sub_value), raw=True)
                    elif isinstance(sub_value, str):
                        sub_value = self.get_object_value(sub_value, attributes_object)
                        if sub_value:
                            bitfield.set_value(sub_value)

                    extra_info += (
                        f"# Bitfield: {bitfield.name}"
                        + f", Description: {bitfield.description}"
                        + f", Value: {bitfield.get_hex_value()}\n"
                    )
            elif isinstance(value, str):  # Value from object
                value = self.get_object_value(value, attributes_object)
                if value:
                    reg.set_value(value)

            script += f"\n# Value: {hex(reg.get_value())}\n"
            script += f"# Description: {reg.description}\n"
            script += extra_info
            if extra_info:
                script += "# WARNING! Partially set register, check all bitfields before writing\n"
            if reg.sub_regs:
                script += f"# Grouped register name: {reg.name}\n\n"
                info += f"\n --== Grouped register name: {reg.name} ==-- \n"
                for reg in reg.sub_regs:
                    script += f"# OTP ID: {reg.name}, Value: {hex(reg.get_value())}\n"
                    if reg.otp_index is None:
                        raise SPSDKError(f"OTP index is not defined for {reg.name}")
                    script += (
                        self.get_fuse_write_cmd(reg.otp_index, reg.get_hex_value(raw=True)) + "\n"
                    )
                    info += f"OTP ID: {reg.otp_index}, Value: {hex(reg.get_value(raw=True))}\n"
            else:
                script += f"# OTP ID: {reg.name}\n\n"
                if reg.otp_index is None:
                    raise SPSDKError(f"OTP index is not defined for {reg.name}")
                script += self.get_fuse_write_cmd(reg.otp_index, reg.get_hex_value(raw=True)) + "\n"
                info += f"OTP ID: {reg.otp_index}, Value: {hex(reg.get_value(raw=True))}\n"

        if info_only:
            return info
        return script

    def write_script(self, filename: str, output_dir: str, attributes_object: Any) -> str:
        """Write script to file.

        :return: The path to the generated script file.
        """
        script_content = self.generate_script(attributes_object)
        output = get_abs_path(f"{filename}_{self.tool}.bcf", output_dir)
        write_file(script_content, output)
        return output
