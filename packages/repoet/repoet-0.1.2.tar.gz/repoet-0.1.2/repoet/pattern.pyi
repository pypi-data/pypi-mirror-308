from typing import Callable, Iterator, Match, Optional
from typing import Pattern as RePattern
from typing import Union, overload

class Pattern:
    _pattern: str
    _regex: Optional[RePattern]

    def __init__(self, pattern: str) -> None: ...
    def __str__(self) -> str: ...

    # Re.Pattern properties
    @property
    def pattern(self) -> str: ...
    @property
    def groups(self) -> int: ...
    @property
    def flags(self) -> int: ...
    @property
    def groupindex(self) -> dict[str, int]: ...

    # Regular expression methods
    def match(
        self, string: str, pos: int = ..., endpos: int = ...
    ) -> Optional[Match]: ...
    def fullmatch(
        self, string: str, pos: int = ..., endpos: int = ...
    ) -> Optional[Match]: ...
    def search(
        self, string: str, pos: int = ..., endpos: int = ...
    ) -> Optional[Match]: ...
    def findall(self, string: str, pos: int = ..., endpos: int = ...) -> list[str]: ...
    def finditer(
        self, string: str, pos: int = ..., endpos: int = ...
    ) -> Iterator[Match]: ...
    def split(self, string: str, maxsplit: int = ...) -> list[str]: ...
    def sub(self, repl: Union[str, Callable], string: str, count: int = ...) -> str: ...
    def subn(
        self, repl: Union[str, Callable], string: str, count: int = ...
    ) -> tuple[str, int]: ...

    # Pattern combination methods
    @overload
    def __add__(self, other: str) -> "Pattern": ...
    @overload
    def __add__(self, other: "Pattern") -> "Pattern": ...
    def __radd__(self, other: str) -> "Pattern": ...
    @overload
    def __or__(self, other: str) -> "Pattern": ...
    @overload
    def __or__(self, other: "Pattern") -> "Pattern": ...
    def __mul__(self, n: int) -> "Pattern": ...
