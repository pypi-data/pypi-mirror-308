import os
import socket
from fasteners import InterProcessLock
import sys
import psutil
import tarfile
import dirhash
from exploitfarm import __version__

DEFAULT_SERVER_PORT = 5050
DEV_MODE = __version__ == "0.0.0"
EXCLUDE_FILE_EXPLOIT_TAR = [".flag_queue.json"]

class ExploitFarmClientError(Exception):
    pass

def parse_address(address:str, default_port:int|None = None) -> tuple[str, int]:
    parts = address.split(":")
    address = parts[0].strip()
    port = int(parts[1]) if len(parts) > 1 else default_port
    if port is None:
        raise ValueError("Port is required")
    return address, port

def mem_usage() -> float:
    mem_stats = psutil.virtual_memory()
    return round((mem_stats.used / mem_stats.total)*100, 1)

def try_tcp_connection(address:str, timeout:float|None = 3) -> tuple[bool, str|None]:
    address, port = parse_address(address, default_port=DEFAULT_SERVER_PORT)
    s = socket.socket()
    try:
        s.settimeout(timeout)
        s.connect((address, port))
    except Exception as e: 
        return False, f"Connection to {address}:{port} Failed: {e}"
    finally:
        s.close()
    return True, None

def create_lock(name:str) -> InterProcessLock:
    file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), name)
    base_path = os.path.dirname(file_path)
    if not os.path.exists(base_path):
        os.makedirs(base_path)
    return InterProcessLock(file_path)

def restart_program():
    """Restarts the current program, with file objects and descriptors
       cleanup
    """

    try:
        p = psutil.Process(os.getpid())
        for handler in p.get_open_files() + p.connections():
            os.close(handler.fd)
    except Exception:
        pass

    python = sys.executable
    os.execl(python, python, *sys.argv)


def make_tarfile(output_filename, source_dir):
    with tarfile.open(output_filename, "w:gz") as tar:
        tar.add(source_dir, arcname=os.path.basename(source_dir))

def calc_hash(path) -> str:
    return dirhash.dirhash(path, 'sha256', ignore=EXCLUDE_FILE_EXPLOIT_TAR)

def exploit_tar_filter(tarinfo):
    if os.path.basename(tarinfo.name) in EXCLUDE_FILE_EXPLOIT_TAR:
        return None
    else:
        return tarinfo

def clear_exploit_folder(path: str):
    for root, dirs, files in os.walk(path):
        for file in files:
            if file not in EXCLUDE_FILE_EXPLOIT_TAR:
                os.remove(os.path.join(root, file))
        for dir in dirs:
            os.rmdir(os.path.join(root, dir))
